[08/31 14:08:55]  --------------------------------------------------------------------------------
[08/31 14:08:55]  Iteration: 1 (0 solution, 0 counterexamples)
[08/31 14:08:55]  Generator returned sat in 0.004435 secs.
[08/31 14:08:55]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:08:56]  Improved gap from 0.1 to 100
[08/31 14:08:56]  Improved number of small numbers from 114 to 114 out of a max of 114
[08/31 14:08:56]  Verifer returned sat in 0.465398 secs.
[08/31 14:08:56]  Counter example: 
[93m   tot_arrival_t  tot_service_t  wasted_t  arrival_0,t  cwnd_0,t  service_0,t  losts_0,t  queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0       -799.800        -800.00     699.9     -799.800     0.100      -800.00      0.000     0.20            0.20       8.0              -800.00                -1.0            -1      True
1       -600.100        -799.70     699.9     -600.100   199.900      -799.70      0.000   199.60           99.90       1.0              -800.00                 0.0         False      True
2       -599.900        -600.00     699.9     -599.900   199.800      -600.00      0.000     0.10            0.10       1.0              -599.90                 0.0         False      True
3       -566.650        -566.75     699.9     -566.650    33.350      -566.75      0.000     0.10          -66.65       1.0              -566.65                 0.0         False      True
4       -166.850        -499.90     699.9     -166.850   399.900      -499.90      0.000   333.05          233.15       1.0              -566.65                 0.0         False      True
5        549.650        -300.00     699.9      549.650  1049.550      -300.00    616.500   233.15          233.15       2.0              -566.65                 0.0         False      True
6        616.500        -300.00     699.9      616.500   300.000      -300.00    616.500   300.00          200.00       2.0                 0.00                 0.0         False      True
7       1166.625        -100.00     699.9     1166.625   850.125      -100.00   1033.475   233.15          233.15       3.0                 0.00                 0.0         False      True
8       1333.375         -99.90     699.9     1333.375   399.900       -99.90   1100.225   333.05          233.15       4.0               233.15                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=3, loss_amount=44009/40, 
, buffer=4663/20.[0m
[08/31 14:08:57]  --------------------------------------------------------------------------------
[08/31 14:08:57]  Iteration: 2 (0 solution, 1 counterexamples)
[08/31 14:08:57]  Generator returned sat in 0.053601 secs.
[08/31 14:08:57]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:08:57]  Improved gap from 0.0 to 100
[08/31 14:08:57]  Improved number of small numbers from 114 to 114 out of a max of 114
[08/31 14:08:57]  Verifer returned sat in 0.406516 secs.
[08/31 14:08:57]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t   cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0     349.644583     149.644583 -249.744583   349.644583    0.00250   149.644583    0.00000  200.00000       200.00000       2.0           149.644583                -1.0            -1      True
1     349.644583     249.644583 -249.744583   349.644583    0.00125   249.644583    0.00000  100.00000       100.00000       2.0           349.644583                 0.0         False      True
2     649.644583     349.644583 -249.744583   649.644583  400.00000   349.644583    0.00000  300.00000       300.00000       3.0           349.644583                 0.0         False      True
3     649.653333     349.644583 -249.744583   649.653333  300.00875   349.644583    0.00000  300.00875       200.00875       3.0           649.653333                 0.0         False      True
4     649.653333     449.644583 -249.744583   649.653333    0.01000   449.644583    0.00000  200.00875       100.00875       3.0           649.653333                 0.0         False      True
5     649.653333     649.643333 -249.744583   649.653333    0.01000   649.643333    0.00000    0.01000         0.00875       4.0           649.653333                 0.0         False      True
6     649.653333     649.644583 -249.744583   649.653333    0.01000   649.644583    0.00000    0.00875       -99.99125       5.0           649.653333                 0.0         False      True
7    1249.664583     849.644583 -249.744583  1249.664583  600.02000   849.644583    0.01875  400.00125       400.00125       1.0           649.653333                 1.0         False     False
8    1249.664583     849.645833 -249.744583  1249.664583  200.00000   849.645833    0.01875  400.00000       300.00125       2.0          1249.645833                 0.0         False      True
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=3/160, 
, buffer=320001/800.[0m
[08/31 14:08:58]  --------------------------------------------------------------------------------
[08/31 14:08:58]  Iteration: 3 (0 solution, 2 counterexamples)
[08/31 14:08:58]  Generator returned sat in 0.133857 secs.
[08/31 14:08:58]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:08:58]  Improved number of small numbers from 88 to 113 out of a max of 113
[08/31 14:08:58]  Verifer returned sat in 0.347724 secs.
[08/31 14:08:58]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t     cwnd_0,t  service_0,t   losts_0,t      queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0     466.593262      66.493408 -249.744385   466.593262   400.050000    66.493408    0.000000   400.099854      316.949951       2.0            66.493408                -1.0            -1      True
1     466.593262     249.643311 -249.744385   466.593262   400.050000   249.643311    0.000000   216.949951      216.949951       3.0            66.493408                 0.0         False      True
2     649.643311     349.593262 -249.744385   649.643311   400.000000   349.593262    0.000000   300.050049      300.000000       3.0           649.643311                 1.0          True     False
3     749.593262     349.643311 -249.744385   749.593262   400.000000   349.643311    0.000000   399.949951      299.949951       4.0           649.643311                 1.0         False     False
4    1315.943115     466.643311 -249.744385  1315.943115   966.299805   466.643311    0.000000   849.299805      766.299805       3.0           649.643311                 1.0         False     False
5    1866.943115     649.643311 -249.744385  1866.943115  1400.299805   649.643311    0.000000  1217.299805     1217.299805       4.0           649.643311                 1.0         False     False
6    2650.043213     649.643311 -249.744385  2650.043213  2000.399902   649.643311  683.100098  1317.299805     1217.299805       4.0           649.643311                 1.0         False     False
7    2650.043213     849.643311 -249.744385  2650.043213   300.000000   849.643311  683.100098  1117.299805     1117.299805       4.0          1966.943115                 1.0         False      True
8    2650.043213     949.643066 -249.744385  2650.043213  1066.000000   949.643066  683.100098  1017.300049     1017.299805       5.0          1966.943115                 1.0         False     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=1398989/2048, 
, buffer=1246515/1024.[0m
[08/31 14:08:59]  --------------------------------------------------------------------------------
[08/31 14:08:59]  Iteration: 4 (0 solution, 3 counterexamples)
[08/31 14:08:59]  Generator returned sat in 0.076878 secs.
[08/31 14:08:59]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:08:59]  Improved gap from 0.0 to 100
[08/31 14:09:00]  Improved number of small numbers from 66 to 72 out of a max of 114
[08/31 14:09:00]  Verifer returned sat in 1.406336 secs.
[08/31 14:09:00]  Counter example: 
[93m   tot_arrival_t  tot_service_t   wasted_t  arrival_0,t     cwnd_0,t  service_0,t    losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0      66.493164    -133.481738  33.380664    66.493164     0.012451  -133.481738     0.000000  199.974902      199.974902       2.0          -133.481738                -1.0            -1     False
1      66.493164    -133.444238  33.380664    66.493164   199.962500  -133.444238     0.000000  199.937402       99.974902       2.0          -133.481738                 0.0         False     False
2      66.505762      66.493262  33.380664    66.505762   199.950000    66.493262     0.000000    0.012500       -0.012500       1.0            66.505762                 0.0         False     False
3     466.593262      66.518262  33.380664   466.593262   400.100000    66.518262     0.012500  400.062500      300.062500       1.0            66.505762                 0.0         False     False
4     466.593262     266.518262  33.380664   466.593262   400.050000   266.518262     0.012500  200.062500      200.062500       2.0           466.580762                 0.0         False      True
5    1266.568262     266.568262  33.380664  1266.568262  1000.037500   266.568262   599.987500  400.012500      300.062500       3.0           466.580762                 0.0         False      True
6    1566.649512     466.518262  33.380664  1566.649512   700.093750   466.518262   800.068750  300.062500      300.062500       4.0           766.580762                 0.0         False      True
7    2016.633887     496.593262  33.380664  2016.633887   750.046875   496.593262  1150.053125  369.987500      300.062500       3.0           766.580762                 1.0         False      True
8    2251.744824     666.518066  33.380664  2251.744824   605.098438   666.518066  1285.164062  300.062695      300.062500       4.0           966.580762                 0.0         False      True
fefficient=True, bounded_queue=False, bounded_loss_count=False, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=4, loss_amount=822497/640, 
, buffer=4801/16.[0m
[08/31 14:09:01]  --------------------------------------------------------------------------------
[08/31 14:09:01]  Iteration: 5 (0 solution, 4 counterexamples)
[08/31 14:09:01]  Generator returned sat in 0.165287 secs.
[08/31 14:09:01]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:02]  Improved number of small numbers from 58 to 67 out of a max of 113
[08/31 14:09:02]  Verifer returned sat in 1.041294 secs.
[08/31 14:09:02]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t     cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0     166.518262     166.514404  133.390625   166.518262     0.001250   166.514404    0.00000    0.003857        0.003711       3.0           166.514404                -1.0            -1     False
1     166.518262     166.515762  233.386914   166.518262     0.002500   166.515762    0.00000    0.002500        0.000000       3.0           166.514404                 0.0         False     False
2     166.518262     166.518262  333.386914   166.518262     0.001465   166.518262    0.00000    0.000000        0.000000       3.0           166.518262                 0.0         False     False
3     666.568262     166.518311  333.386914   666.568262   500.050000   166.518311    0.00125  500.048701      400.048750       1.0           166.518262                 0.0         False     False
4     666.568262     266.518262  333.386914   666.568262     0.010000   266.518262    0.00125  400.048750      300.048750       2.0           666.567012                 0.0         False      True
5     666.568262     366.518262  333.386914   666.568262   150.023750   366.518262    0.00125  300.048750      200.048750       3.0           666.567012                 0.0         False      True
6     966.567012     566.518262  333.386914   966.567012   600.047500   566.518262    0.00125  400.047500      400.047500       4.0           666.567012                 0.0         False      True
7    1766.614512     666.517090  333.386914  1766.614512  1200.095000   666.517090  700.04750  400.049922      400.048750       5.0           666.567012                 1.0         False     False
8    1766.614512     666.518262  333.386914  1766.614512     0.010000   666.518262  700.04750  400.048750      300.048750       6.0          1066.567012                 1.0         False      True
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=560037/800, 
, buffer=320039/800.[0m
[08/31 14:09:03]  --------------------------------------------------------------------------------
[08/31 14:09:03]  Iteration: 6 (0 solution, 5 counterexamples)
[08/31 14:09:03]  Generator returned sat in 0.175891 secs.
[08/31 14:09:03]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:04]  Improved gap from 0.1 to 100
[08/31 14:09:04]  Improved number of small numbers from 59 to 65 out of a max of 114
[08/31 14:09:04]  Verifer returned sat in 1.131098 secs.
[08/31 14:09:04]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    -933.483154    -933.682988  1233.588164  -933.483154    0.199951  -933.682988       0.00    0.199834        0.199834       1.0          -933.682988                -1.0            -1     False
1    -933.483154    -933.682988  1233.588164  -933.483154    0.100098  -933.682988       0.00    0.199834      -99.800166       1.0          -933.483154                 0.0         False     False
2    -483.482988    -733.682988  1233.588164  -483.482988  450.200000  -733.682988     250.00    0.200000        0.200000       1.0          -933.483154                 0.0         False     False
3     -33.582988    -633.682988  1233.588164   -33.582988  450.100000  -633.682988     599.90    0.200000        0.200000       1.0          -633.482988                 0.0         False      True
4     416.217012    -633.682988  1233.588164   416.217012  450.000000  -633.682988     949.70  100.200000        0.200000       1.0          -533.482988                 0.0         False      True
5     766.017012    -533.382988  1233.588164   766.017012  450.000000  -533.382988    1199.50   99.900000        0.200000       1.0          -533.482988                 0.0         False      True
6     966.567012    -433.682988  1233.588164   966.567012  300.450000  -433.682988    1300.05  100.200000        0.200000       2.0          -333.482988                 0.0         False      True
7    1166.367012    -233.782988  1233.588164  1166.367012  300.000000  -233.782988    1399.85    0.300000        0.200000       1.0          -233.482988                 1.0         False      True
8    1765.917012    -233.682988  1233.588164  1765.917012  599.850000  -233.682988    1899.40  100.200000        0.200000       2.0          -233.482988                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=False, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=5, loss_amount=9497/10, 
, buffer=1/5.[0m
[08/31 14:09:05]  --------------------------------------------------------------------------------
[08/31 14:09:05]  Iteration: 7 (0 solution, 6 counterexamples)
[08/31 14:09:05]  Generator returned sat in 0.055611 secs.
[08/31 14:09:05]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:06]  Improved number of small numbers from 46 to 113 out of a max of 113
[08/31 14:09:06]  Verifer returned sat in 0.326461 secs.
[08/31 14:09:06]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t    losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    -933.483154    -933.682861  1233.588135  -933.483154    0.199951  -933.682861     0.000000    0.199707        0.199707       1.0          -933.682861                -1.0            -1     False
1    -933.483154    -933.682861  1233.588135  -933.483154    0.100098  -933.682861     0.000000    0.199707      -99.800293       1.0          -933.483154                 0.0         False     False
2    -483.482910    -833.333252  1233.588135  -483.482910  450.199951  -833.333252   250.000000   99.850342        0.199951       1.0          -933.483154                 0.0         False     False
3    -133.233154    -633.682861  1233.588135  -133.233154  450.100098  -633.682861   500.249756    0.199951        0.199951       1.0          -633.482910                 0.0         False      True
4     166.566895    -633.682861  1233.588135   166.566895  300.000000  -633.682861   700.049805  100.199951        0.199951       1.0          -533.482910                 0.0         False      True
5     366.366943    -533.383057  1233.588135   366.366943  300.000000  -533.383057   799.849854   99.900146        0.199951       1.0          -533.482910                 0.0         False      True
6     566.416992    -433.557861  1233.588135   566.416992  299.950195  -433.557861   899.899902  100.074951        0.199951       2.0          -333.482910                 0.0         False      True
7     666.467041    -233.782959  1233.588135   666.467041  200.125000  -233.782959   899.949951    0.300049        0.199951       1.0          -233.482910                 0.0         False      True
8    1066.066895    -233.682861  1233.588135  1066.066895  399.899902  -233.682861  1199.549805  100.199951        0.199951       2.0          -233.482910                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=False, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=5, loss_amount=999/2, 
, buffer=819/4096.[0m
[08/31 14:09:06]  --------------------------------------------------------------------------------
[08/31 14:09:06]  Iteration: 8 (0 solution, 7 counterexamples)
[08/31 14:09:07]  Generator returned sat in 0.342102 secs.
[08/31 14:09:07]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:07]  Improved gap from 0.001875 to 100
[08/31 14:09:08]  Improved number of small numbers from 56 to 62 out of a max of 114
[08/31 14:09:08]  Verifer returned sat in 1.008824 secs.
[08/31 14:09:08]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    -983.494141    -983.494248  1183.411188  -983.494141    0.000488  -983.494248    0.000000    0.000107      -99.988226       9.0          -983.494248                -1.0            -1       -1
1    -783.493623    -783.505915  1183.411188  -783.493623  200.000625  -783.505915    0.000000    0.012292        0.012292       1.0          -983.494248                 1.0         False    False
2    -583.505602    -783.493311  1183.411188  -583.505602  200.000313  -783.493311    0.000313  199.987396      100.000000       1.0          -583.505915                 0.0         False    False
3    -583.505602    -683.505915  1183.411188  -583.505602    0.000313  -683.505915    0.000313  100.000000        0.000000       2.0          -583.505915                 0.0         False     True
4    -233.522790    -483.505915  1183.411188  -233.522790  449.982813  -483.505915  149.983125  100.000000      100.000000       1.0          -583.505915                 0.0         False     True
5    -233.522790    -483.505915  1183.411188  -233.522790    0.010000  -483.505915  149.983125  100.000000        0.000000       1.0          -383.505915                 0.0         False     True
6     116.468304    -383.505615  1183.411188   116.468304  449.991094  -383.505615  299.974219  199.999701      100.000000       1.0          -383.505915                 0.0         False     True
7     116.468304    -183.506227  1183.411188   116.468304    0.010000  -183.506227  299.974219    0.000313        0.000000       2.0          -183.505915                 0.0         False     True
8     566.477523    -183.505859  1183.411188   566.477523  450.009531  -183.505859  549.983438  199.999945      100.000000       1.0          -183.505915                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=3, loss_amount=1280001/3200, 
, buffer=100.[0m
[08/31 14:09:08]  --------------------------------------------------------------------------------
[08/31 14:09:08]  Iteration: 9 (0 solution, 8 counterexamples)
[08/31 14:09:09]  Generator returned sat in 0.321505 secs.
[08/31 14:09:09]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][5]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:10]  Improved number of small numbers from 86 to 88 out of a max of 113
[08/31 14:09:10]  Verifer returned sat in 0.666143 secs.
[08/31 14:09:10]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    -483.505026    -883.506104  1183.411133  -483.505026  399.999756  -883.506104   0.000833  400.000244      400.000000       2.0          -883.506104                -1.0            -1       -1
1    -483.505026    -783.506693  1183.411133  -483.505026  399.999756  -783.506693   0.000833  300.000833      300.000000       2.0          -883.506104                 0.0         False     True
2    -483.504193    -783.505859  1183.411133  -483.504193  300.001667  -783.505859   0.000833  300.000833      200.000833       3.0          -483.505026                 0.0         False     True
3    -483.504193    -583.506104  1183.411133  -483.504193    0.010833  -583.506104   0.000833  100.001077      100.000833       4.0          -483.505026                 0.0         False     True
4    -483.504193    -483.515625  1183.411133  -483.504193    0.010000  -483.515625   0.000833    0.010599        0.000833       5.0          -483.505026                 0.0         False     True
5    -483.504193    -483.505859  1183.411133  -483.504193    0.010000  -483.505859   0.000833    0.000833      -99.999167       6.0          -483.505026                 0.0         False     True
6     116.509974    -383.505859  1183.411133   116.509974  600.015000  -383.505859   0.015833  500.000000      400.000000       1.0          -483.505026                 1.0         False    False
7     116.509974    -183.506104  1183.411133   116.509974    0.010000  -183.506104   0.015833  300.000244      300.000000       2.0           116.494141                 0.0         False     True
8     116.509974    -183.505859  1183.411133   116.509974    0.010000  -183.505859   0.015833  300.000000      200.000000       3.0           116.494141                 0.0         False     True
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=3/200, 
, buffer=400.[0m
[08/31 14:09:10]  --------------------------------------------------------------------------------
[08/31 14:09:10]  Iteration: 10 (0 solution, 9 counterexamples)
[08/31 14:09:11]  Generator returned sat in 0.548577 secs.
[08/31 14:09:11]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:11]  Improved gap from 22.723076923076924 to 100
[08/31 14:09:12]  Improved number of small numbers from 87 to 89 out of a max of 114
[08/31 14:09:12]  Verifer returned sat in 1.125777 secs.
[08/31 14:09:12]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    -782.404785    -882.355859  1182.261133  -782.404785    0.050049  -882.355859    0.000833   99.950241       99.950241       2.0          -882.355859                -1.0            -1     False
1    -782.355026    -782.355859  1182.261133  -782.355026  100.000000  -782.355859    0.000833    0.000000        0.000000       1.0          -882.355859                 0.0         False     False
2    -482.305026    -748.922526  1182.261133  -482.305026  300.050000  -748.922526    0.050833  266.566667      200.000000       1.0          -882.355859                 0.0         False     False
3    -482.305026    -682.355859  1182.261133  -482.305026    0.050000  -682.355859    0.050833  200.000000      100.000000       2.0          -482.355859                 0.0         False      True
4    -482.305026    -482.355859  1182.261133  -482.305026  100.075000  -482.355859    0.050833    0.000000        0.000000       3.0          -482.355859                 0.0         False      True
5    -182.192526    -482.305859  1182.261133  -182.192526  300.112500  -482.305859    0.163333  299.950000      200.000000       1.0          -482.355859                 0.0         False      True
6    -182.192526    -349.030859  1182.261133  -182.192526  133.308333  -349.030859    0.163333  166.675000      100.000000       2.0          -182.355859                 0.0         False      True
7      17.757474    -182.355859  1182.261133    17.757474  366.625000  -182.355859    0.163333  199.950000      199.950000       3.0          -182.355859                 0.0         False      True
8     517.744974    -182.355713  1182.261133   517.744974  699.937500  -182.355713  400.100833  299.999854      200.000000       2.0          -182.355859                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=8001/20, 
, buffer=200.[0m
[08/31 14:09:13]  --------------------------------------------------------------------------------
[08/31 14:09:13]  Iteration: 11 (0 solution, 10 counterexamples)
[08/31 14:09:13]  Generator returned sat in 0.220969 secs.
[08/31 14:09:13]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:14]  Improved gap from 0.0 to 100
[08/31 14:09:14]  Improved number of small numbers from 60 to 114 out of a max of 114
[08/31 14:09:14]  Verifer returned sat in 0.819365 secs.
[08/31 14:09:14]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t    losts_0,t      queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   -2717.346680   -3417.246582  3617.151855 -2717.346680     0.100098 -3417.246582     0.000000   699.899902      599.899902       6.0         -3417.246582                -1.0            -1      True
1   -2643.346680   -3217.246582  3617.151855 -2643.346680   773.899902 -3217.246582     0.000000   573.899902      573.899902       6.0         -3417.246582                 0.0         False      True
2   -2516.613037   -3117.246826  3617.151855 -2516.613037   700.633545 -3117.246826     0.000000   600.633789      600.633545       7.0         -2516.613037                 0.0         False      True
3   -2516.613037   -3017.246582  3617.151855 -2516.613037   600.533203 -3017.246582     0.000000   500.633545      500.633545       8.0         -2516.613037                 0.0         False      True
4   -1716.446777   -2917.246582  3617.151855 -1716.446777  1300.799805 -2917.246582     0.099854  1200.699951     1200.699951       8.0         -2516.613037                 1.0         False     False
5   -1716.446777   -2917.246582  3617.151855 -1716.446777   800.399902 -2917.246582     0.099854  1200.699951     1100.699951       8.0         -1716.546631                 1.0         False      True
6   -1516.546631   -2717.246582  3617.151855 -1516.546631  1400.600098 -2717.246582     0.099854  1200.600098     1200.600098       6.0         -1716.546631                 1.0         False     False
7    -316.246582   -2643.246826  3617.151855  -316.246582  2400.900146 -2643.246826  1100.300049  1226.700195     1200.699951       6.0         -1716.546631                 0.0         False     False
8    -205.496826   -2517.246582  3617.151855  -205.496826  1337.449951 -2517.246582  1111.049805  1200.699951     1200.699951       7.0         -1316.546631                 0.0         False      True
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=3, loss_amount=4550451/4096, 
, buffer=4918067/4096.[0m
[08/31 14:09:15]  --------------------------------------------------------------------------------
[08/31 14:09:15]  Iteration: 12 (0 solution, 11 counterexamples)
[08/31 14:09:15]  Generator returned sat in 0.162557 secs.
[08/31 14:09:15]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:17]  Improved number of small numbers from 59 to 63 out of a max of 113
[08/31 14:09:17]  Verifer returned sat in 1.197670 secs.
[08/31 14:09:17]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   -2117.056885   -2217.256777  2417.162051 -2117.056885    0.099854 -2217.256777    0.000000  100.199893        0.199893       1.0         -2217.256777                -1.0            -1     False
1   -2017.156777   -2117.256777  2417.162051 -2017.156777  200.100000 -2117.256777    0.000000  100.100000        0.100000       2.0         -2217.256777                 0.0         False     False
2   -1917.256777   -2017.256777  2417.162051 -1917.256777  200.000000 -2017.256777    0.000000  100.000000        0.000000       2.0         -1917.256777                 1.0          True     False
3   -1816.956777   -1883.723444  2417.162051 -1816.956777  200.300000 -1883.723444    0.100000   66.666667        0.200000       1.0         -1917.256777                 1.0         False     False
4   -1716.856777   -1750.790111  2417.162051 -1716.856777  166.766667 -1750.790111    0.200000   33.733333        0.200000       1.0         -1717.056777                 0.0         False      True
5   -1567.356777   -1617.256777  2417.162051 -1567.356777  183.233333 -1617.256777   49.700000    0.200000        0.200000       1.0         -1717.056777                 0.0         False      True
6   -1367.556777   -1529.256777  2417.162051 -1367.556777  200.000000 -1529.256777  149.500000   12.200000        0.200000       1.0         -1717.056777                 0.0         False      True
7   -1202.523444   -1417.256777  2417.162051 -1202.523444  177.233333 -1417.256777  214.533333    0.200000        0.200000       1.0         -1417.056777                 0.0         False      True
8   -1035.956777   -1417.156738  2417.162051 -1035.956777  166.766667 -1417.156738  281.100000  100.099961        0.200000       2.0         -1317.056777                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=False, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=5, loss_amount=2809/10, 
, buffer=1/5.[0m
[08/31 14:09:17]  --------------------------------------------------------------------------------
[08/31 14:09:17]  Iteration: 13 (0 solution, 12 counterexamples)
[08/31 14:09:18]  Generator returned sat in 0.209724 secs.
[08/31 14:09:18]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:18]  Improved gap from 0.001 to 100
[08/31 14:09:18]  Improved number of small numbers from 59 to 114 out of a max of 114
[08/31 14:09:18]  Verifer returned sat in 0.458946 secs.
[08/31 14:09:18]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   -2117.029297   -2117.031738  1916.951904 -2117.029297    0.002686 -2117.031738    0.000000    0.002441      -99.997559       2.0         -2117.031738                -1.0            -1     False
1   -1817.034424   -1917.031738  1916.951904 -1817.034424  299.997314 -1917.031738    0.000000   99.997314       99.997314       1.0         -2117.031738                 0.0         False     False
2   -1617.036621   -1917.031738  1916.951904 -1617.036621  299.995117 -1917.031738   99.995117  200.000000      100.000000       1.0         -1717.031738                 0.0         False     False
3   -1517.034180   -1717.034180  1916.951904 -1517.034180  300.002441 -1717.034180   99.997559  100.002441      100.000000       2.0         -1717.031738                 0.0         False      True
4   -1517.034180   -1717.031738  1916.951904 -1517.034180    0.010000 -1717.031738   99.997559  100.000000        0.000000       3.0         -1617.031738                 0.0         False      True
5   -1317.034180   -1585.033203  1916.951904 -1317.034180  300.000000 -1585.033203   99.997559  168.001465      100.000000       1.0         -1617.031738                 0.0         False      True
6    -987.037842   -1517.031738  1916.951904  -987.037842  497.997803 -1517.031738  329.993896  200.000000      100.000000       2.0         -1617.031738                 0.0         False      True
7    -987.037842   -1409.029297  1916.951904  -987.037842    0.010000 -1409.029297  329.993896   91.997559        0.000000       2.0         -1317.031738                 0.0         False      True
8    -617.031738   -1317.029297  1916.951904  -617.031738  462.003662 -1317.029297  500.000000  199.997559      100.000000       1.0         -1317.031738                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=819205/2048, 
, buffer=100.[0m
[08/31 14:09:19]  --------------------------------------------------------------------------------
[08/31 14:09:19]  Iteration: 14 (0 solution, 13 counterexamples)
[08/31 14:09:19]  Generator returned sat in 0.069371 secs.
[08/31 14:09:19]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:20]  Improved number of small numbers from 113 to 113 out of a max of 113
[08/31 14:09:20]  Verifer returned sat in 0.196560 secs.
[08/31 14:09:20]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   -2117.029297   -2117.031738  1916.951904 -2117.029297    0.002686 -2117.031738    0.000000    0.002441      -99.997559       2.0         -2117.031738                -1.0            -1     False
1   -1817.034424   -1917.031738  1916.951904 -1817.034424  299.997314 -1917.031738    0.000000   99.997314       99.997314       1.0         -2117.031738                 0.0         False     False
2   -1617.036621   -1917.031738  1916.951904 -1617.036621  299.995117 -1917.031738   99.995117  200.000000      100.000000       1.0         -1717.031738                 0.0         False     False
3   -1517.034180   -1717.031738  1916.951904 -1517.034180  300.002441 -1717.031738   99.997559  100.000000      100.000000       2.0         -1717.031738                 0.0         False      True
4   -1517.034180   -1717.031738  1916.951904 -1517.034180    0.010000 -1717.031738   99.997559  100.000000        0.000000       2.0         -1617.031738                 0.0         False      True
5   -1317.034180   -1585.033203  1916.951904 -1317.034180  300.000000 -1585.033203   99.997559  168.001465      100.000000       1.0         -1617.031738                 0.0         False      True
6    -987.037842   -1517.031738  1916.951904  -987.037842  497.997803 -1517.031738  329.993896  200.000000      100.000000       2.0         -1617.031738                 0.0         False      True
7    -987.037842   -1409.029297  1916.951904  -987.037842    0.010000 -1409.029297  329.993896   91.997559        0.000000       2.0         -1317.031738                 0.0         False      True
8    -617.031738   -1317.029297  1916.951904  -617.031738  462.003662 -1317.029297  500.000000  199.997559      100.000000       1.0         -1317.031738                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=819205/2048, 
, buffer=100.[0m
[08/31 14:09:20]  --------------------------------------------------------------------------------
[08/31 14:09:20]  Iteration: 15 (0 solution, 14 counterexamples)
[08/31 14:09:21]  Generator returned sat in 0.085256 secs.
[08/31 14:09:21]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:22]  Improved number of small numbers from 50 to 64 out of a max of 113
[08/31 14:09:22]  Verifer returned sat in 1.110488 secs.
[08/31 14:09:22]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   -2167.032715   -2167.032959  1916.951904 -2167.032715    0.002197 -2167.032959    0.000000    0.000244      -99.999535       2.0         -2167.032959                -1.0            -1     False
1   -1967.026855   -1967.033180  1916.951904 -1967.026855  200.006104 -1967.033180    0.000000    0.006324        0.006324       1.0         -2167.032959                 0.0         False     False
2   -1767.027569   -1967.033180  1916.951904 -1767.027569  200.005610 -1967.033180    0.000610  200.005000      100.005000       1.0         -1767.028180                 0.0         False     False
3   -1667.026959   -1767.033180  1916.951904 -1667.026959  300.005610 -1767.033180    0.001221  100.005000      100.005000       2.0         -1767.028180                 0.0         False      True
4   -1667.026959   -1767.033180  1916.951904 -1667.026959    0.010000 -1767.033180    0.001221  100.005000        0.005000       2.0         -1667.028180                 0.0         False      True
5   -1467.026959   -1567.033180  1916.951904 -1467.026959  300.005000 -1567.033180    0.001221  100.005000      100.005000       1.0         -1667.028180                 0.0         False      True
6    -817.029459   -1467.033203  1916.951904  -817.029459  750.002500 -1467.033203  549.998721  100.005024      100.005000       2.0         -1667.028180                 0.0         False      True
7    -817.029459   -1429.033180  1916.951904  -817.029459    0.010000 -1429.033180  549.998721   62.005000        0.005000       2.0         -1367.028180                 0.0         False      True
8    -372.029459   -1367.027344  1916.951904  -372.029459  507.005000 -1367.027344  794.998721  199.999164      100.005000       1.0         -1367.028180                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=317999/400, 
, buffer=20001/200.[0m
[08/31 14:09:23]  --------------------------------------------------------------------------------
[08/31 14:09:23]  Iteration: 16 (0 solution, 15 counterexamples)
[08/31 14:09:24]  Generator returned sat in 0.836307 secs.
[08/31 14:09:24]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:24]  Improved gap from 0.010625 to 100
[08/31 14:09:24]  Improved number of small numbers from 59 to 114 out of a max of 114
[08/31 14:09:24]  Verifer returned sat in 0.277966 secs.
[08/31 14:09:24]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0   -2767.013184   -2767.014404  2616.930664 -2767.013184  100.002441 -2767.014404    0.000000    0.001221       -0.001221       2.0         -2767.014404                -1.0            -1       -1
1   -2667.011963   -2767.011963  2616.930664 -2667.011963  100.002441 -2767.011963    0.000000  100.000000        0.000000       1.0         -2767.014404                 1.0         False    False
2   -2566.999512   -2567.011963  2616.930664 -2566.999512  200.012451 -2567.011963    0.001221    0.011230        0.011230       1.0         -2767.014404                 0.0         False    False
3   -2366.998047   -2467.011963  2616.930664 -2366.998047  200.012695 -2467.011963  100.002686    0.011230        0.011230       1.0         -2767.014404                 0.0         False     True
4   -2366.998047   -2467.011963  2616.930664 -2366.998047    0.010000 -2467.011963  100.002686    0.011230      -99.988770       1.0         -2467.000732                 0.0         False     True
5   -1767.009277   -2267.011963  2616.930664 -1767.009277  600.000000 -2267.011963  499.991455    0.011230        0.011230       1.0         -2467.000732                 0.0         False     True
6   -1767.009277   -2267.011963  2616.930664 -1767.009277    0.010000 -2267.011963  499.991455    0.011230      -99.988770       1.0         -2267.000732                 0.0         False     True
7   -1367.020508   -2167.011963  2616.930664 -1367.020508  400.000000 -2167.011963  699.980225  100.011230        0.011230       1.0         -2267.000732                 0.0         False     True
8   -1367.020508   -2067.011963  2616.930664 -1367.020508    0.010000 -2067.011963  699.980225    0.011230      -99.988770       2.0         -2067.000732                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=614377/1024, 
, buffer=23/2048.[0m
[08/31 14:09:25]  --------------------------------------------------------------------------------
[08/31 14:09:25]  Iteration: 17 (0 solution, 16 counterexamples)
[08/31 14:09:26]  Generator returned sat in 0.898088 secs.
[08/31 14:09:26]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:36]  Improved gap from 0.0 to 0
[08/31 14:09:37]  Improved number of small numbers from 61 to 77 out of a max of 114
[08/31 14:09:37]  Verifer returned sat in 10.558697 secs.
[08/31 14:09:37]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   -2332.301514   -2432.298920  2517.948164 -2332.301514    0.002686 -2432.298920        0.0   99.997407       99.997407       2.0          -2432.29892                -1.0            -1      True
1   -2130.266420   -2332.299072  2517.948164 -2130.266420  302.032500 -2332.299072        0.0  202.032652      202.032500       1.0          -2432.29892                 0.0         False      True
2   -2130.264160   -2233.331420  2517.948164 -2130.264160  202.034912 -2233.331420        0.0  103.067260      102.034760       2.0          -2130.26416                 0.0         False      True
3   -2031.296420   -2232.298920  2517.948164 -2031.296420  202.035000 -2232.298920        0.0  201.002500      101.002500       3.0          -2130.26416                 0.0         False      True
4   -2031.281420   -2130.266602  2517.948164 -2031.281420  201.017500 -2130.266602        0.0   98.985181        1.017500       4.0          -2031.28142                 0.0         False      True
5   -2031.281420   -2031.293945  2616.930664 -2031.281420    0.010000 -2031.293945        0.0    0.012525        0.000000       2.0          -2031.28142                 1.0         False     False
6   -2031.281420   -2031.281420  2716.930420 -2031.281420    0.010000 -2031.281420        0.0    0.000000       -0.000244       3.0          -2031.28142                 0.0         False     False
7   -2031.271420   -2031.278920  2816.920654 -2031.271420    0.010000 -2031.278920        0.0    0.007500       -0.000010       1.0          -2031.28142                 0.0         False     False
8   -2031.268920   -2031.269043  2816.920654 -2031.268920    0.010000 -2031.269043        0.0    0.000123      -99.997510       1.0          -2031.28142                 0.0         False     False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=40407/200.[0m
[08/31 14:09:37]  --------------------------------------------------------------------------------
[08/31 14:09:37]  Iteration: 18 (0 solution, 17 counterexamples)
[08/31 14:09:38]  Generator returned sat in 0.361245 secs.
[08/31 14:09:38]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:39]  Improved gap from 0.0 to 100
[08/31 14:09:39]  Improved number of small numbers from 59 to 114 out of a max of 114
[08/31 14:09:39]  Verifer returned sat in 0.716920 secs.
[08/31 14:09:39]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   -2395.432861   -2473.444092  2559.093262 -2395.432861   22.288818 -2473.444092    0.000000   78.011230       78.011230       1.0         -2473.444092                -1.0            -1     False
1   -2395.432861   -2395.532959  2559.093262 -2395.432861   22.288818 -2395.532959    0.000000    0.100098      -21.988770       2.0         -2473.444092                 0.0         False     False
2   -2373.343994   -2373.443848  2559.093262 -2373.343994   22.188965 -2373.443848    0.000000    0.099854      -99.899902       1.0         -2373.343994                 1.0          True     False
3   -1899.014160   -2232.747803  2559.093262 -1899.014160  474.429688 -2232.747803  196.418701  137.314941       78.011230       1.0         -2373.343994                 0.0         False     False
4   -1799.114258   -2073.444092  2559.093262 -1799.114258  237.214844 -2073.444092  196.418701   77.911133       77.911133       1.0         -1995.532959                 0.0         False      True
5   -1521.203125   -1973.444092  2559.093262 -1521.203125  355.822266 -1973.444092  374.229736   78.011230       78.011230       1.0         -1995.532959                 0.0         False      True
6   -1421.303223   -1973.444092  2559.093262 -1421.303223  177.911133 -1973.444092  374.229736  177.911133       77.911133       1.0         -1795.532959                 0.0         False      True
7   -1332.347656   -1773.444092  2559.093262 -1332.347656  266.866699 -1773.444092  374.229736   66.866699       66.866699       1.0         -1795.532959                 0.0         False      True
8    -998.914307   -1773.343750  2559.093262  -998.914307  400.300049 -1773.343750  596.518555  177.910889       78.011230       2.0         -1795.532959                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=1638809/4096, 
, buffer=159767/2048.[0m
[08/31 14:09:40]  --------------------------------------------------------------------------------
[08/31 14:09:40]  Iteration: 19 (0 solution, 18 counterexamples)
[08/31 14:09:41]  Generator returned sat in 1.118194 secs.
[08/31 14:09:41]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:42]  Improved gap from 0.0008333333333333334 to 100
[08/31 14:09:43]  Improved number of small numbers from 66 to 70 out of a max of 114
[08/31 14:09:43]  Verifer returned sat in 1.590590 secs.
[08/31 14:09:43]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   -1750.071045   -1750.071660  2559.093262 -1750.071045  200.001709 -1750.071660    0.000000    0.000615       -0.000635       1.0          -1750.07166                -1.0            -1     False
1   -1550.069785   -1750.070410  2559.093262 -1550.069785  200.001875 -1750.070410    0.000625  200.000000      100.000000       1.0          -1750.07166                 0.0         False     False
2   -1550.069785   -1550.071035  2559.093262 -1550.069785  199.999512 -1550.071035    0.000625    0.000625        0.000000       2.0          -1550.07041                 0.0         False      True
3   -1350.069160   -1450.070410  2559.093262 -1350.069160  200.001250 -1450.070410    0.001250  100.000000      100.000000       1.0          -1550.07041                 1.0         False     False
4   -1350.069160   -1450.070410  2559.093262 -1350.069160    0.010000 -1450.070410    0.001250  100.000000        0.000000       1.0          -1350.07041                 0.0         False      True
5   -1000.069160   -1250.070410  2559.093262 -1000.069160  450.000000 -1250.070410  150.001250  100.000000      100.000000       1.0          -1350.07041                 0.0         False      True
6   -1000.069160   -1250.070410  2559.093262 -1000.069160    0.010000 -1250.070410  150.001250  100.000000        0.000000       1.0          -1150.07041                 0.0         False      True
7    -800.069160   -1110.070160  2559.093262  -800.069160  300.000000 -1110.070160  150.001250  159.999750      100.000000       1.0          -1150.07041                 0.0         False      True
8    -450.068535    -950.070557  2559.093262  -450.068535  510.000375  -950.070557  400.001875  100.000146      100.000000       2.0          -1150.07041                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=640001/1600, 
, buffer=100.[0m
[08/31 14:09:44]  --------------------------------------------------------------------------------
[08/31 14:09:44]  Iteration: 20 (0 solution, 19 counterexamples)
[08/31 14:09:44]  Generator returned sat in 0.156845 secs.
[08/31 14:09:44]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:45]  Improved gap from 0.025 to 100
[08/31 14:09:46]  Improved number of small numbers from 68 to 79 out of a max of 114
[08/31 14:09:46]  Verifer returned sat in 1.746194 secs.
[08/31 14:09:46]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   -2056.023438   -2155.923584  2559.093262 -2056.023438  200.199951 -2155.923584    0.000000   99.900146       -0.099767       1.0         -2155.923584                -1.0            -1     False
1   -1955.823730   -2055.923670  2559.093262 -1955.823730  200.099854 -2055.923670    0.000000  100.099940        0.099940       1.0         -1955.823730                 0.0         False     False
2   -1855.623670   -1893.792901  2559.093262 -1855.623670  200.300000 -1893.792901    0.100000   38.069231        0.200000       1.0         -1955.823730                 0.0         False     False
3   -1755.523670   -1755.923670  2559.093262 -1755.523670  138.169231 -1755.923670    0.200000    0.200000        0.200000       1.0         -1755.723670                 0.0         False      True
4   -1686.639055   -1686.939055  2559.093262 -1686.639055   69.084615 -1686.939055    0.200000    0.100000      -30.915385       1.0         -1686.839055                 0.0         False      True
5   -1133.262132   -1555.923670  2559.093262 -1133.262132  553.476923 -1555.923670  422.461538    0.200000        0.200000       1.0         -1686.839055                 0.0         False      True
6    -856.723670   -1455.923670  2559.093262  -856.723670  276.738462 -1455.923670  599.000000    0.200000        0.200000       1.0         -1455.723670                 0.0         False      True
7    -718.554440   -1356.023670  2559.093262  -718.554440  138.369231 -1356.023670  637.169231    0.300000        0.200000       1.0         -1355.723670                 0.0         False      True
8    -649.669824   -1355.923584  2559.093262  -649.669824   69.184615 -1355.923584  637.169231   69.084529      -30.915385       2.0         -1286.839055                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=3, loss_amount=41403/65, 
, buffer=1/5.[0m
[08/31 14:09:47]  --------------------------------------------------------------------------------
[08/31 14:09:47]  Iteration: 21 (0 solution, 20 counterexamples)
[08/31 14:09:48]  Generator returned sat in 0.133322 secs.
[08/31 14:09:48]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:49]  Improved gap from 0.0 to 23.4375
[08/31 14:09:50]  Improved number of small numbers from 63 to 114 out of a max of 114
[08/31 14:09:50]  Verifer returned sat in 2.039047 secs.
[08/31 14:09:50]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t   cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0     877.480225     828.612793  2331.412109   877.480225   0.000732   828.612793        0.0  48.867432        0.001465       1.0           828.612793                -1.0            -1      True
1     877.481445     877.480713  2407.972656   877.481445  48.868652   877.480713        0.0   0.000732      -23.436768       1.0           828.612793                 0.0         False      True
2     900.921387     900.920654  2484.532715   900.921387  23.440674   900.920654        0.0   0.000732      -23.436768       1.0           900.921387                 0.0         False      True
3     949.794922     926.360352  2559.093018   949.794922  48.874268   926.360352        0.0  23.434570       -0.002930       1.0           900.921387                 0.0         False      True
4     975.234131     975.233154  2610.218994   975.234131  48.873779   975.233154        0.0   0.000977      -23.437744       1.0           975.234131                 0.0         False      True
5    1024.109375     998.672119  2684.780762  1024.109375  48.876221   998.672119        0.0  25.437256       -0.000732       1.0           975.234131                 0.0         False      True
6    1047.547852    1024.110352  2761.343018  1047.547852  48.875732  1024.110352        0.0  23.437500        0.000000       1.0          1047.547852                 0.0         False      True
7    1072.985352    1047.547852  2835.905518  1072.985352  48.875000  1047.547852        0.0  25.437500        0.000000       2.0          1072.985352                 0.0         False      True
8    1072.985352    1072.985352  2912.467529  1072.985352   0.010000  1072.985352        0.0   0.000000      -23.437988       2.0          1072.985352                 1.0         False     False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=3/2048.[0m
[08/31 14:09:50]  --------------------------------------------------------------------------------
[08/31 14:09:50]  Iteration: 22 (0 solution, 21 counterexamples)
[08/31 14:09:52]  Generator returned sat in 1.278303 secs.
[08/31 14:09:52]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:53]  Improved gap from 0.01 to 100
[08/31 14:09:54]  Improved number of small numbers from 60 to 64 out of a max of 114
[08/31 14:09:54]  Verifer returned sat in 1.335176 secs.
[08/31 14:09:54]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t   cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0     278.624023     278.621543  2930.266826   278.624023    0.00125   278.621543    0.00125    0.00123        -0.00127       6.0           278.621543                -1.0            -1       -1
1     478.640293     278.624043  2930.266826   478.640293  200.01750   278.624043    0.00125  200.01500       100.01500       1.0           278.621543                 1.0         False     True
2     578.624043     478.624043  2930.266826   578.624043  299.99875   478.624043    0.00125   99.99875        99.99875       2.0           278.621543                 0.0         False     True
3     678.642793     578.624043  2930.266826   678.642793  200.01750   578.624043    0.00250  100.01625       100.01625       1.0           678.640293                 1.0          True    False
4     678.642793     578.624043  2930.266826   678.642793    0.01000   578.624043    0.00250  100.01625         0.01625       1.0           678.640293                 0.0         False     True
5    1028.641543     778.624043  2930.266826  1028.641543  450.01500   778.624043  150.00125  100.01625       100.01625       1.0           678.640293                 0.0         False     True
6    1028.641543     778.624043  2930.266826  1028.641543    0.01000   778.624043  150.00125  100.01625         0.01625       1.0           878.640293                 0.0         False     True
7    1228.640293     878.641543  2930.266826  1228.640293  300.01500   878.641543  150.00125  199.99750       100.01500       1.0           878.640293                 0.0         False     True
8    1928.691543    1078.624023  2930.266826  1928.691543  900.04875  1078.624023  750.05125  100.01627       100.01625       2.0           878.640293                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=600039/800, 
, buffer=80013/800.[0m
[08/31 14:09:54]  --------------------------------------------------------------------------------
[08/31 14:09:54]  Iteration: 23 (0 solution, 22 counterexamples)
[08/31 14:09:55]  Generator returned sat in 0.214763 secs.
[08/31 14:09:55]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:09:55]  Improved gap from 99.99515625 to 100
[08/31 14:09:57]  Improved number of small numbers from 46 to 51 out of a max of 114
[08/31 14:09:57]  Verifer returned sat in 1.401110 secs.
[08/31 14:09:57]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0     278.642334     178.642480  2930.262764   278.642334    0.001250   178.642480    0.000156   99.999697        0.014072       7.0           178.642480                -1.0            -1       -1
1     378.643105     278.642480  2930.262764   378.643105  200.000469   278.642480    0.000156  100.000469        0.014844       1.0           178.642480                 1.0         False     True
2     478.643105     378.642949  2930.262764   478.643105  200.000469   378.642949    0.000156  100.000000        0.014844       2.0           178.642480                 0.0         False     True
3     578.643418     578.628105  2930.262764   578.643418  200.000313   578.628105    0.000313    0.015000        0.015000       1.0           578.643105                 1.0          True    False
4     578.643418     578.628105  2930.262764   578.643418    0.010000   578.628105    0.000313    0.015000      -99.985000       1.0           578.643105                 0.0         False     True
5     878.629043     778.628105  2930.262764   878.629043  300.000625   778.628105   99.985938    0.015000        0.015000       1.0           578.643105                 0.0         False     True
6     878.629043     778.628105  2930.262764   878.629043    0.010000   778.628105   99.985938    0.015000      -99.985000       1.0           778.643105                 0.0         False     True
7    1078.629043     878.628105  2930.262764  1078.629043  200.015000   878.628105   99.985938  100.015000        0.015000       1.0           778.643105                 0.0         False     True
8    1578.636543     978.628174  2930.262764  1578.636543  600.022500   978.628174  499.993438  100.014932        0.015000       2.0           778.643105                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=799989/1600, 
, buffer=3/200.[0m
[08/31 14:09:57]  --------------------------------------------------------------------------------
[08/31 14:09:57]  Iteration: 24 (0 solution, 23 counterexamples)
[08/31 14:09:59]  Generator returned sat in 0.745662 secs.
[08/31 14:09:59]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:10:00]  Improved number of small numbers from 58 to 101 out of a max of 113
[08/31 14:10:00]  Verifer returned sat in 1.131163 secs.
[08/31 14:10:00]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0     193.765869    -377.489746  3130.25293   193.765869  571.455566  -377.489746        0.0  571.255615      471.255859       4.0          -377.489746                -1.0            -1      True
1     193.865967    -224.926796  3130.25293   193.865967  571.355713  -224.926796        0.0  418.792763      371.355957       4.0           193.865967                 0.0         False      True
2     193.965796    -177.489746  3130.25293   193.965796  418.892593  -177.489746        0.0  371.455543      271.455787       5.0           193.965796                 0.0         False      True
3     779.343506      22.410400  3130.25293   779.343506  956.833252    22.410400        0.0  756.933105      756.833496       6.0           193.965796                 0.0         False      True
4     779.343506      22.510241  3130.25293   779.343506  399.900146    22.510241        0.0  756.833265      656.833496       7.0           779.343506                 0.0         False      True
5     779.343506     193.765869  3130.25293   779.343506  247.437037   193.765869        0.0  585.577637      556.833496       8.0           779.343506                 0.0         False      True
6     779.343506     222.510254  3130.25293   779.343506  371.155556   222.510254        0.0  556.833252      456.833496       4.0           779.343506                 1.0         False     False
7     779.343506     379.243574  3130.25293   779.343506  556.733333   379.243574        0.0  400.099932      356.833496       5.0           779.343506                 0.0         False     False
8    1214.343574     422.510254  3130.25293  1214.343574  835.100000   422.510254        0.0  791.833320      691.833564       6.0           779.343506                 0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=0, loss_amount=0, 
, buffer=3100399/4096.[0m
[08/31 14:10:00]  --------------------------------------------------------------------------------
[08/31 14:10:00]  Iteration: 25 (0 solution, 24 counterexamples)
[08/31 14:10:02]  Generator returned sat in 1.284561 secs.
[08/31 14:10:02]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:10:11]  Improved gap from 50.00644230769231 to 50.0
[08/31 14:10:12]  Improved number of small numbers from 58 to 74 out of a max of 114
[08/31 14:10:12]  Verifer returned sat in 9.433799 secs.
[08/31 14:10:12]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0     579.342773     579.341927  3080.279053   579.342773  100.000977   579.341927    0.000000    0.000847       -0.000681       2.0           579.341927                -1.0            -1     False
1     679.342322     579.343506  3080.279541   679.342322  100.000395   579.343506    0.000000   99.998816       -0.000645       1.0           679.342322                 0.0         False     False
2     679.343994     679.343018  3080.279791   679.343994  100.000488   679.343018    0.000000    0.000977      -99.998722       1.0           679.342322                 0.0         False     False
3     779.343506     779.342716  3080.279791   779.343506  100.000488   779.342716    0.000000    0.000789      -99.999211       1.0           679.342322                 0.0         False     False
4     979.343506     979.342716  3080.279791   979.343506  200.000789   979.342716    0.000000    0.000789        0.000789       1.0           679.342322                 0.0         False     False
5    1379.341927    1079.342716  3080.279791  1379.341927  399.999211  1079.342716  299.997632    0.001579        0.001579       1.0           679.342322                 0.0         False     False
6    1379.350348    1079.351927  3130.252686  1379.350348    0.010000  1079.351927  299.997632    0.000789      -50.017105       1.0          1079.352716                 0.0         False      True
7    1529.359164    1229.360743  3130.252686  1529.359164  150.009605  1229.360743  299.997632    0.000789       -0.008289       1.0          1079.352716                 0.0         False      True
8    1729.372190    1229.369873  3130.252686  1729.372190  200.013816  1229.369873  400.000789  100.001528        0.001579       1.0          1079.352716                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=1520003/3800, 
, buffer=3/1900.[0m
[08/31 14:10:13]  --------------------------------------------------------------------------------
[08/31 14:10:13]  Iteration: 26 (0 solution, 25 counterexamples)
[08/31 14:10:14]  Generator returned sat in 0.275766 secs.
[08/31 14:10:14]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:10:17]  Improved gap from 0.05 to 100
[08/31 14:10:19]  Improved number of small numbers from 59 to 63 out of a max of 114
[08/31 14:10:19]  Verifer returned sat in 4.878605 secs.
[08/31 14:10:19]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0     446.016846     412.933681  3246.688826   446.016846  100.099854   412.933681    0.000000   33.083164       33.083164       2.0           412.933681                -1.0            -1     False
1     512.933681     412.933681  3246.688826   512.933681  100.000000   412.933681    0.000000  100.000000        0.000000       2.0           512.933681                 0.0         False     False
2     512.933681     512.933681  3246.688826   512.933681   99.900146   512.933681    0.000000    0.000000     -100.000000       2.0           512.933681                 0.0         False     False
3     712.933681     612.933681  3246.688826   712.933681  200.000000   612.933681    0.000000  100.000000        0.000000       1.0           512.933681                 0.0         False     False
4     812.933681     812.733681  3246.688826   812.933681  200.000000   812.733681    0.000000    0.200000        0.000000       1.0           512.933681                 0.0         False     False
5    1212.533681     912.933681  3246.688826  1212.533681  399.800000   912.933681  266.516667   33.083333       33.083333       1.0           512.933681                 0.0         False     False
6    1379.350348    1012.933681  3246.688826  1379.350348  199.900000  1012.933681  333.333333   33.083333       33.083333       1.0          1046.017015                 0.0         False      True
7    1446.217015    1112.783681  3246.688826  1446.217015   99.950000  1112.783681  333.333333    0.100000       -0.050000       1.0          1112.883681                 0.0         False      True
8    1646.117015    1112.983887  3246.688826  1646.117015  200.000000  1112.983887  400.100000  133.033128       33.083333       1.0          1112.883681                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=3, loss_amount=4001/10, 
, buffer=397/12.[0m
[08/31 14:10:19]  --------------------------------------------------------------------------------
[08/31 14:10:19]  Iteration: 27 (0 solution, 26 counterexamples)
[08/31 14:10:22]  Generator returned sat in 1.677738 secs.
[08/31 14:10:22]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:10:34]  Improved gap from 0.0 to 18.75
[08/31 14:10:35]  Improved number of small numbers from 59 to 114 out of a max of 114
[08/31 14:10:35]  Verifer returned sat in 13.559176 secs.
[08/31 14:10:35]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t   cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0     312.468506     312.460938  3347.154053   312.468506   0.002686   312.460938   0.002441   0.005127       -0.002441       9.0           312.460938                -1.0            -1       -1
1     331.218506     312.468506  3428.404053   331.218506  18.755127   312.468506   0.002441  18.747559       -0.002441       1.0           312.460938                 1.0         False     True
2     331.223633     331.218506  3509.654053   331.223633  18.752686   331.218506   0.002441   0.002686      -18.747314       1.0           331.221191                 0.0         False     True
3     353.913574     349.968506  3590.904053   353.913574  22.692627   349.968506   0.002441   3.942627      -14.807373       1.0           331.221191                 0.0         False     True
4     380.071045     368.718506  3672.154053   380.071045  30.100098   368.718506   0.002441  11.350098       -7.399902       1.0           331.221191                 0.0         False     True
5     411.895996     387.468750  3747.726562   411.895996  43.175049   387.468750   0.002441  24.424805       -0.002441       1.0           331.221191                 0.0         False     True
6     437.183838     411.895996  3822.441162   437.183838  49.712646   411.895996   0.002441  25.285400        0.000000       1.0           331.221191                 0.0         False     True
7     467.718506     437.181396  3891.906494   467.718506  55.820068   437.181396   0.002441  30.534668        0.000000       2.0           331.221191                 0.0         False     True
8     467.718506     467.716064  3891.906494   467.718506   0.010000   467.716064   0.002441   0.000000     -100.000000       2.0           467.716064                 1.0          True    False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=21/4096.[0m
[08/31 14:10:36]  --------------------------------------------------------------------------------
[08/31 14:10:36]  Iteration: 28 (0 solution, 27 counterexamples)
[08/31 14:10:37]  Generator returned sat in 0.389260 secs.
[08/31 14:10:37]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:10:37]  Improved gap from 0.70650634765625 to 100
[08/31 14:10:38]  Improved number of small numbers from 85 to 114 out of a max of 114
[08/31 14:10:38]  Verifer returned sat in 0.546536 secs.
[08/31 14:10:38]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0     362.543457     262.393555  3428.403809   362.543457  200.150000   262.393555    0.000000  100.149902       49.949951       9.0           262.393555                -1.0            -1       -1
1     462.493408     312.593506  3428.403809   462.493408  200.099854   312.593506    0.000000  149.899902       49.899902       9.0           462.493408                 1.0         False    False
2     512.643555     512.593506  3428.403809   512.643555  200.050049   512.593506    0.000000    0.050049        0.050049       1.0           512.643555                 1.0         False    False
3     812.393311     612.593506  3428.403809   812.393311  299.799805   612.593506  149.849854   49.949951       49.949951       1.0           512.643555                 0.0         False    False
4     912.343262     712.593506  3428.403809   912.343262  149.899902   712.593506  149.849854   49.899902       49.899902       1.0           762.493408                 0.0         False     True
5    1262.443359     762.593506  3428.403809  1262.443359  400.000000   762.593506  399.899902   99.949951       49.949951       1.0           762.493408                 0.0         False     True
6    1362.493408     912.593506  3428.403809  1362.493408  200.000000   912.593506  399.949951   49.949951       49.949951       1.0           962.543457                 0.0         False     True
7    1412.543457    1012.543457  3428.403809  1412.543457  100.000000  1012.543457  399.949951    0.050049        0.000000       1.0          1012.593506                 0.0         False     True
8    1712.443359    1012.643311  3428.403809  1712.443359  299.949951  1012.643311  549.899902  149.900146       49.949951       1.0          1012.593506                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=3, loss_amount=1638605/4096, 
, buffer=204595/4096.[0m
[08/31 14:10:38]  --------------------------------------------------------------------------------
[08/31 14:10:38]  Iteration: 29 (0 solution, 28 counterexamples)
[08/31 14:10:41]  Generator returned sat in 1.597524 secs.
[08/31 14:10:41]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:10:41]  Improved number of small numbers from 91 to 91 out of a max of 113
[08/31 14:10:41]  Verifer returned sat in 0.506456 secs.
[08/31 14:10:41]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0     462.543457     262.393555  3428.403809   462.543457  200.150000   262.393555  100.000000  100.149902       49.949951       8.0           262.393555                -1.0            -1       -1
1     462.568359     362.543457  3428.403809   462.568359  100.174805   362.543457  100.000000    0.024902      -50.025146       9.0           362.568359                 1.0         False    False
2     512.618408     412.593506  3428.403809   512.618408   50.074951   412.593506  100.000000    0.024902      -99.975098       1.0           412.618408                 1.0         False    False
3     812.393311     612.593506  3428.403809   812.393311  299.799805   612.593506  149.849854   49.949951       49.949951       1.0           412.618408                 0.0         False    False
4     912.343262     662.568359  3428.403809   912.343262  149.899902   662.568359  149.849854   99.925049       49.899902       1.0           762.493408                 0.0         False     True
5    1337.292969     762.593506  3428.403809  1337.292969  524.874756   762.593506  474.749512   99.949951       49.949951       1.0           762.493408                 0.0         False     True
6    1499.780396     881.374817  3428.403809  1499.780396  262.437378   881.374817  537.236938   81.168640       49.949951       1.0           962.543457                 0.0         False     True
7    1549.830444    1012.543457  3428.403809  1549.830444  131.218689  1012.543457  537.236938    0.050049        0.000000       1.0          1012.593506                 0.0         False     True
8    2096.583527    1012.643311  3428.403809  2096.583527  546.803131  1012.643311  934.040070  149.900146       49.949951       1.0          1012.593506                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=3, loss_amount=25696345/32768, 
, buffer=204595/4096.[0m
[08/31 14:10:42]  --------------------------------------------------------------------------------
[08/31 14:10:42]  Iteration: 30 (0 solution, 29 counterexamples)
[08/31 14:10:45]  Generator returned sat in 2.201902 secs.
[08/31 14:10:45]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][6]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:10:45]  Improved gap from 0.00125 to 100
[08/31 14:10:46]  Improved number of small numbers from 59 to 70 out of a max of 114
[08/31 14:10:46]  Verifer returned sat in 1.194803 secs.
[08/31 14:10:46]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    1337.283203    1037.282959  3328.402142  1337.283203  299.999756  1037.282959   0.000000  300.000244      300.000234       6.0          1037.282959                -1.0            -1      True
1    1337.283203    1037.291302  3328.402142  1337.283203  299.999756  1037.291302   0.000000  299.991901      200.000234       5.0          1037.282959                 0.0         False      True
2    1337.291302    1137.291302  3328.402142  1337.291302  300.000000  1137.291302   0.000000  200.000000      100.008333       5.0          1037.282959                 0.0         False      True
3    1337.291302    1337.282135  3328.402142  1337.291302    0.010986  1337.282135   0.000000    0.009167        0.008333       6.0          1337.291302                 0.0         False      True
4    1337.292135    1337.282969  3328.402142  1337.292135    0.010000  1337.282969   0.000000    0.009167      -99.990833       7.0          1337.292135                 0.0         False      True
5    1787.270469    1437.282969  3328.402142  1787.270469  449.987500  1437.282969   0.000000  349.987500      249.987500       1.0          1337.292135                 1.0         False     False
6    1887.270469    1637.273802  3328.402142  1887.270469  449.987500  1637.273802   0.000000  249.996667      249.987500       2.0          1337.292135                 0.0         False     False
7    2087.261302    1677.274635  3328.402142  2087.261302  449.987500  1677.274635   0.000000  409.986667      349.978333       3.0          1337.292135                 0.0         False     False
8    2187.262135    1837.282959  3328.402142  2187.262135  509.987500  1837.282959   0.000833  349.978343      349.978333       3.0          1337.292135                 0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=1/1200, 
, buffer=209987/600.[0m
[08/31 14:10:47]  --------------------------------------------------------------------------------
[08/31 14:10:47]  Iteration: 31 (0 solution, 30 counterexamples)
[08/31 14:10:51]  Generator returned sat in 2.728876 secs.
[08/31 14:10:51]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][6]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:10:51]  Improved gap from 0.0 to 100
[08/31 14:10:51]  Improved number of small numbers from 59 to 114 out of a max of 114
[08/31 14:10:51]  Verifer returned sat in 0.434951 secs.
[08/31 14:10:51]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    1137.427734     737.340576  3528.344727  1137.427734    0.012695   737.340576   0.000000  400.087158      300.087158       6.0           737.340576                -1.0            -1     False
1    1237.390381     937.340576  3528.344727  1237.390381  500.049805   937.340576   0.000000  300.049805      300.049805       6.0           737.340576                 0.0         False     False
2    1437.378174     937.340576  3528.344727  1437.378174  500.037598   937.340576  99.950195  400.087402      300.087402       6.0          1337.427979                 0.0         False     False
3    1537.315674    1037.340576  3528.344727  1537.315674  500.024902  1037.340576  99.950195  400.024902      300.024902       5.0          1437.365479                 0.0         False      True
4    1637.315674    1137.340576  3528.344727  1637.315674  500.024902  1137.340576  99.950195  400.024902      300.024902       5.0          1437.365479                 0.0         False      True
5    1737.315674    1237.402832  3528.344727  1737.315674  500.024902  1237.402832  99.950195  399.962646      300.024902       4.0          1437.365479                 0.0         False      True
6    1837.377930    1337.403076  3528.344727  1837.377930  500.024902  1337.403076  99.950195  400.024658      300.087158       5.0          1437.365479                 0.0         False      True
7    1937.378174    1437.415283  3528.344727  1937.378174  500.024902  1437.415283  99.950195  400.012695      300.087402       4.0          1437.365479                 0.0         False      True
8    2037.390381    1537.403076  3528.344727  2037.390381  500.024902  1537.403076  99.962402  400.024902      300.087402       4.0          1437.365479                 0.0         False      True
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=25/2048, 
, buffer=614579/2048.[0m
[08/31 14:10:52]  --------------------------------------------------------------------------------
[08/31 14:10:52]  Iteration: 32 (0 solution, 31 counterexamples)
[08/31 14:10:54]  Generator returned sat in 1.428261 secs.
[08/31 14:10:54]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:10:55]  Improved gap from 0.000625 to 23.4375
[08/31 14:10:55]  Improved number of small numbers from 95 to 114 out of a max of 114
[08/31 14:10:55]  Verifer returned sat in 0.752830 secs.
[08/31 14:10:55]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    1413.902832    1313.902832  3051.782227  1413.902832    0.099854  1313.902832   0.100098  99.899902       99.899658       2.0          1313.902832                -1.0            -1       -1
1    1514.002930    1413.902832  3051.782227  1514.002930  200.000000  1413.902832   0.199951  99.900146       99.899902       1.0          1313.902832                 0.0         False     True
2    1613.902832    1513.902832  3051.782227  1613.902832  199.800049  1513.902832   0.199951  99.800049       99.799805       1.0          1613.702881                 0.0         False     True
3    1613.902832    1613.603271  3051.782227  1613.902832   23.537354  1613.603271   0.199951   0.099609       -0.200195       2.0          1613.702881                 0.0         False     True
4    1637.340576    1613.903076  3128.344727  1637.340576   23.537354  1613.903076   0.199951  23.237549       -0.199951       1.0          1613.702881                 0.0         False     True
5    1637.640381    1637.340576  3204.907227  1637.640381   23.537354  1637.340576   0.199951   0.099854      -23.337646       1.0          1613.702881                 0.0         False     True
6    1661.077881    1660.778076  3281.469727  1661.077881   23.537354  1660.778076   0.199951   0.099854      -23.337646       1.0          1613.702881                 0.0         False     True
7    1684.515381    1684.215576  3358.032227  1684.515381   23.537354  1684.215576   0.199951   0.099854      -23.337646       1.0          1613.702881                 0.0         False     True
8    1707.952881    1707.653076  3434.594482  1707.952881   23.537354  1707.653076   0.199951   0.099854      -23.337891       1.0          1613.702881                 0.0         False     True
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=204595/2048.[0m
[08/31 14:10:55]  --------------------------------------------------------------------------------
[08/31 14:10:55]  Iteration: 33 (0 solution, 32 counterexamples)
[08/31 14:10:59]  Generator returned sat in 2.947775 secs.
[08/31 14:10:59]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:11:00]  Improved gap from 0.001 to 100
[08/31 14:11:00]  Improved number of small numbers from 56 to 83 out of a max of 114
[08/31 14:11:00]  Verifer returned sat in 0.838749 secs.
[08/31 14:11:00]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0     707.728027     707.703125  3351.802153   707.728027    0.099854   707.703125    0.000000    0.024902      -99.974976       2.0           707.703125                -1.0            -1     False
1    1107.677979     907.702881  3351.802153  1107.677979  399.974854   907.702881    0.000000  199.975098      199.974976       1.0           707.703125                 0.0         False     False
2    1307.653076     907.703125  3351.802153  1307.653076  399.950195   907.703125    0.000000  399.949951      299.950073       2.0          1307.653076                 0.0         False     False
3    1307.653076    1107.702881  3351.802153  1307.653076   79.022208  1107.702881    0.000000  199.950195      199.950073       2.0          1307.653076                 0.0         False     False
4    1307.653076    1107.727783  3351.802153  1307.653076  118.533312  1107.727783    0.000000  199.925293       99.950073       3.0          1307.653076                 0.0         False     False
5    1307.653076    1207.703125  3351.802153  1307.653076  177.799967  1207.703125    0.000000   99.949951       -0.049927       4.0          1307.653076                 0.0         False     False
6    1474.403076    1407.678040  3351.802153  1474.403076  266.699951  1407.678040    0.000000   66.725037       66.700073       1.0          1307.653076                 0.0         False     False
7    1807.727966    1407.703003  3351.802153  1807.727966  400.049927  1407.703003    0.000000  400.024963      300.024963       2.0          1307.653076                 0.0         False     False
8    2007.777893    1607.702881  3351.802153  2007.777893  600.074890  1607.702881  100.049927  300.025085      300.024963       2.0          1307.653076                 0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=819609/8192, 
, buffer=4915609/16384.[0m
[08/31 14:11:01]  --------------------------------------------------------------------------------
[08/31 14:11:01]  Iteration: 34 (0 solution, 33 counterexamples)
[08/31 14:11:03]  Generator returned sat in 0.686402 secs.
[08/31 14:11:03]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:11:03]  Improved gap from 0.2 to 100
[08/31 14:11:03]  Improved number of small numbers from 74 to 114 out of a max of 114
[08/31 14:11:03]  Verifer returned sat in 0.396598 secs.
[08/31 14:11:03]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0     857.852783     657.953125  3401.552246   857.852783   299.899902   657.953125    0.000000  199.899658       99.899658       9.0           657.953125                -1.0            -1       -1
1     957.853027     857.952881  3401.552246   957.853027   299.899902   857.952881    0.000000   99.900146       99.899902       1.0           657.953125                 1.0         False    False
2    1057.853027     857.953125  3401.552246  1057.853027   199.900146   857.953125    0.000000  199.899902       99.899902       2.0          1057.853027                 0.0         False    False
3    1057.853027     957.953125  3401.552246  1057.853027    50.000000   957.953125    0.000000   99.899902       -0.100098       2.0          1057.853027                 0.0         False    False
4    1057.953125    1057.953125  3401.552246  1057.953125   100.000000  1057.953125    0.000000    0.000000     -100.000000       1.0          1057.853027                 0.0         False    False
5    1257.953125    1157.953125  3401.552246  1257.953125   200.000000  1157.953125    0.000000  100.000000        0.000000       1.0          1057.853027                 0.0         False    False
6    1557.953125    1258.053223  3401.552246  1557.953125   400.000000  1258.053223    0.000000  299.899902      200.000000       1.0          1057.853027                 0.0         False    False
7    2058.053223    1457.953125  3401.552246  2058.053223   800.000000  1457.953125    0.000000  600.100098      600.100098       2.0          1057.853027                 0.0         False    False
8    3057.953125    1557.952881  3401.552246  3057.953125  1600.000000  1557.952881  899.899902  600.100342      600.100098       3.0          1057.853027                 0.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=1842995/2048, 
, buffer=1229005/2048.[0m
[08/31 14:11:04]  --------------------------------------------------------------------------------
[08/31 14:11:04]  Iteration: 35 (0 solution, 34 counterexamples)
[08/31 14:11:06]  Generator returned sat in 1.072398 secs.
[08/31 14:11:06]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:11:08]  Improved gap from 0.0 to 23.4375
[08/31 14:11:09]  Improved number of small numbers from 83 to 103 out of a max of 114
[08/31 14:11:09]  Verifer returned sat in 2.898161 secs.
[08/31 14:11:09]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t   cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    2632.808350    2532.849545  1626.655826  2632.808350  24.137784  2532.849545        0.0  99.958804       99.958804       4.0          2532.849545                -1.0            -1      True
1    2632.808350    2632.272949  1626.655826  2632.808350  24.096436  2632.272949        0.0   0.535400       -0.041196       2.0          2632.808350                 0.0         False      True
2    2656.328125    2632.849545  1703.135986  2656.328125  24.055176  2632.849545        0.0  23.478580       -0.041260       1.0          2656.328125                 0.0         False      True
3    2656.410625    2656.369432  1779.698242  2656.410625  23.561080  2656.369432        0.0   0.041193      -23.396504       1.0          2656.410625                 0.0         False      True
4    2718.129375    2689.482910  1841.375996  2718.129375  61.759943  2689.482910        0.0  28.646465        0.000000       1.0          2656.410625                 0.0         False      True
5    2718.129375    2718.129375  1917.938496  2718.129375  28.604980  2718.129375        0.0   0.000000      -23.437500       2.0          2718.129375                 0.0         False      True
6    2760.769290    2741.566875  1994.500977  2760.769290  42.639915  2741.566875        0.0  19.202415       -4.235105       1.0          2718.129375                 0.0         False      True
7    2784.165597    2765.004395  2071.063477  2784.165597  42.598722  2765.004395        0.0  19.161202       -4.276298       1.0          2784.165597                 0.0         False      True
8    2802.765137    2788.441895  2071.063477  2802.765137  37.760742  2788.441895        0.0  14.323242      -85.676758       1.0          2802.765137                 0.0         False      True
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=51179/512.[0m
[08/31 14:11:09]  --------------------------------------------------------------------------------
[08/31 14:11:09]  Iteration: 36 (0 solution, 35 counterexamples)
[08/31 14:11:11]  Generator returned sat in 0.468486 secs.
[08/31 14:11:11]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:11:30]  Improved gap from 0.0 to 0
[08/31 14:11:31]  Improved number of small numbers from 87 to 100 out of a max of 114
[08/31 14:11:31]  Verifer returned sat in 19.993508 secs.
[08/31 14:11:31]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    2756.376953    2356.374512  1803.130859  2756.376953    0.002500  2356.374512     0.0025  399.999941      399.999941       2.0          2356.374512                -1.0            -1       -1
1    2756.376953    2456.374432  1803.130859  2756.376953    0.002686  2456.374432     0.0025  300.000021      299.999941       2.0          2356.374512                 0.0         False     True
2    2855.361932    2457.392090  1803.130859  2855.361932  398.985000  2457.392090     0.0025  397.967342      298.984920       3.0          2356.374512                 0.0         False     True
3    2855.361932    2556.374512  1803.130859  2855.361932  397.964844  2556.374512     0.0025  298.984920      198.984920       4.0          2855.359432                 0.0         False     True
4    2855.361932    2756.374268  1803.130859  2855.361932  298.982422  2756.374268     0.0025   98.985164       98.984920       5.0          2855.359432                 0.0         False     True
5    2855.361932    2855.351932  1804.143555  2855.361932    0.010000  2855.351932     0.0025    0.007500       -0.002385       4.0          2855.359432                 1.0         False    False
6    2855.364432    2855.361932  1904.143439  2855.364432    0.010000  2855.361932     0.0025    0.000000        0.000000       1.0          2855.359432                 0.0         False    False
7    2855.374432    2855.361932  2004.133439  2855.374432    0.010000  2855.361932     0.0025    0.010000        0.000000       1.0          2855.359432                 0.0         False    False
8    2855.374432    2855.371932  2004.133545  2855.374432    0.010000  2855.371932     0.0025    0.000000      -99.999894       2.0          2855.359432                 0.0         False    False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=400.[0m
[08/31 14:11:32]  --------------------------------------------------------------------------------
[08/31 14:11:32]  Iteration: 37 (0 solution, 36 counterexamples)
[08/31 14:11:39]  Generator returned sat in 6.423335 secs.
[08/31 14:11:39]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:11:39]  Improved gap from 0.0 to 100
[08/31 14:11:40]  Improved number of small numbers from 60 to 72 out of a max of 114
[08/31 14:11:40]  Verifer returned sat in 0.885308 secs.
[08/31 14:11:40]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    2557.405215    2057.393311  2102.112031  2557.405215    0.000488  2057.393311     0.0025  500.009404      500.009375       7.0          2057.393311                -1.0            -1       -1
1    2557.405215    2157.392578  2102.112031  2557.405215    0.000625  2157.392578     0.0025  400.010137      400.009375       4.0          2057.393311                 0.0         False     True
2    2557.405215    2157.393555  2102.112031  2557.405215    0.000732  2157.393555     0.0025  400.009160      300.009375       4.0          2057.393311                 0.0         False     True
3    2557.405215    2257.427715  2102.112031  2557.405215    0.042500  2257.427715     0.0025  299.975000      200.009375       5.0          2057.393311                 0.0         False     True
4    2557.405215    2457.393340  2102.112031  2557.405215    0.021250  2457.393340     0.0025  100.009375      100.009375       6.0          2557.402715                 0.0         False     True
5    2557.405215    2557.393340  2102.112031  2557.405215    0.010625  2557.393340     0.0025    0.009375        0.009375       7.0          2557.402715                 0.0         False     True
6    2557.405840    2557.402715  2102.112031  2557.405840    0.010000  2557.402715     0.0025    0.000625      -99.990000       8.0          2557.403340                 0.0         False     True
7    2857.395215    2657.393340  2102.112031  2857.395215  299.990000  2657.393340     0.0025  199.999375       99.999375       1.0          2557.403340                 1.0         False    False
8    3307.380840    2857.393311  2102.112031  3307.380840  649.985000  2857.393311     0.0025  449.985029      449.985000       1.0          2557.403340                 0.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=0, loss_amount=0, 
, buffer=160003/320.[0m
[08/31 14:11:41]  --------------------------------------------------------------------------------
[08/31 14:11:41]  Iteration: 38 (0 solution, 37 counterexamples)
[08/31 14:11:44]  Generator returned sat in 2.496710 secs.
[08/31 14:11:45]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:11:56]  Improved gap from 0.0 to 23.4375
[08/31 14:11:57]  Improved number of small numbers from 71 to 101 out of a max of 114
[08/31 14:11:57]  Verifer returned sat in 12.172926 secs.
[08/31 14:11:57]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t   cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    2431.991699    2431.973668  2102.111816  2431.991699  51.071429  2431.973668        0.0   0.018032        0.017578       1.0          2431.973668                -1.0            -1      True
1    2483.027239    2455.447021  2151.040771  2483.027239  51.053571  2455.447021        0.0  27.580218       -0.017927       1.0          2483.027239                 0.0         False      True
2    2483.062988    2483.045166  2227.567627  2483.062988  27.615967  2483.045166        0.0   0.017822      -23.455322       1.0          2483.062988                 0.0         False      True
3    2529.937988    2506.518311  2304.130127  2529.937988  46.892822  2506.518311        0.0  23.419678       -0.017822       1.0          2483.062988                 0.0         False      True
4    2543.790632    2529.955811  2376.692627  2543.790632  37.272321  2529.955811        0.0  13.834821      -13.602679       1.0          2543.790632                 0.0         False      True
5    2567.210205    2557.393311  2453.255127  2567.210205  37.254395  2557.393311        0.0   9.816895      -13.620605       1.0          2567.210205                 0.0         False      True
6    2594.567383    2580.830811  2529.817383  2594.567383  37.174072  2580.830811        0.0  13.736572       -9.701172       1.0          2594.567383                 0.0         False      True
7    2617.987061    2604.500453  2606.147949  2617.987061  37.156250  2604.500453        0.0  13.486607       -9.950928       1.0          2617.987061                 0.0         False      True
8    2641.772775    2627.937988  2606.147949  2641.772775  37.272321  2627.937988        0.0  13.834787      -86.165213       1.0          2617.987061                 0.0         False      True
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=73/2048.[0m
[08/31 14:11:57]  --------------------------------------------------------------------------------
[08/31 14:11:57]  Iteration: 39 (0 solution, 38 counterexamples)
[08/31 14:12:02]  Generator returned sat in 3.072922 secs.
[08/31 14:12:02]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:12:03]  Improved gap from 0.0 to 23.4375
[08/31 14:12:03]  Improved number of small numbers from 66 to 114 out of a max of 114
[08/31 14:12:03]  Verifer returned sat in 1.627433 secs.
[08/31 14:12:03]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t   cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    1447.999756    1447.899414  3053.554932  1447.999756   0.100098  1447.899414        0.0   0.100342      -32.531006       4.0          1447.899414                -1.0            -1     False
1    1509.018066    1480.530762  3115.773682  1509.018066  61.118652  1480.530762        0.0  28.487305       -9.293945       1.0          1447.899414                 0.0         False     False
2    1541.649658    1518.312012  3192.336182  1541.649658  61.118896  1518.312012        0.0  23.337646       -0.099854       1.0          1447.899414                 0.0         False     False
3    1565.337158    1541.749512  3268.748535  1565.337158  47.025146  1541.749512        0.0  23.587646        0.000000       1.0          1565.337158                 0.0         False     False
4    1588.674561    1574.380859  3336.267334  1588.674561  46.925049  1574.380859        0.0  14.293701       -9.143799       1.0          1588.674561                 0.0         False     False
5    1621.305908    1602.968262  3407.679932  1621.305908  46.925049  1602.968262        0.0  18.337646       -5.099854       1.0          1588.674561                 0.0         False     False
6    1645.296387    1626.405762  3484.242432  1645.296387  42.328125  1626.405762        0.0  18.890625       -4.546875       1.0          1645.296387                 0.0         False     False
7    1668.733887    1649.843262  3560.804688  1668.733887  42.328125  1649.843262        0.0  18.890625       -4.547119       1.0          1645.296387                 0.0         False     False
8    1687.574463    1673.281006  3560.804688  1687.574463  37.731201  1673.281006        0.0  14.293457      -85.706543       1.0          1687.574463                 0.0         False     False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=205/1024.[0m
[08/31 14:12:04]  --------------------------------------------------------------------------------
[08/31 14:12:04]  Iteration: 40 (0 solution, 39 counterexamples)
[08/31 14:12:13]  Generator returned sat in 8.219551 secs.
[08/31 14:12:13]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:12:15]  Improved number of small numbers from 91 to 93 out of a max of 113
[08/31 14:12:15]  Verifer returned sat in 1.747078 secs.
[08/31 14:12:15]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    1174.383545    1174.380859  3259.70459  1174.383545  200.102539  1174.380859     0.0000    0.002686      -99.997314       2.0          1174.380859                -1.0            -1      True
1    1374.480859    1374.380859  3259.70459  1374.480859  200.100000  1374.380859     0.0000    0.100000        0.100000       1.0          1374.480859                 0.0         False      True
2    1674.300859    1374.483359  3259.70459  1674.300859  299.920000  1374.483359    99.9025  199.915000      100.017500       1.0          1374.480859                 0.0         False      True
3    1774.303359    1574.280859  3259.70459  1774.303359  299.917500  1574.280859    99.9050  100.117500      100.017500       2.0          1674.398359                 0.0         False      True
4    1774.303359    1574.380859  3259.70459  1774.303359    0.010000  1574.380859    99.9050  100.017500        0.017500       3.0          1674.398359                 0.0         False      True
5    1774.303359    1674.398359  3259.70459  1774.303359  100.015000  1674.398359    99.9050    0.000000      -99.982500       3.0          1674.398359                 0.0         False      True
6    2074.283359    1874.380859  3259.70459  2074.283359  299.980000  1874.380859    99.9050   99.997500       99.997500       1.0          1674.398359                 0.0         False      True
7    2574.305859    1974.380615  3259.70459  2574.305859  600.020000  1974.380615   499.9075  100.017744      100.017500       1.0          1674.398359                 0.0         False      True
8    2574.305859    1974.380859  3259.70459  2574.305859    0.010000  1974.380859   499.9075  100.017500        0.017500       2.0          2074.398359                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=160001/400, 
, buffer=40007/400.[0m
[08/31 14:12:16]  --------------------------------------------------------------------------------
[08/31 14:12:16]  Iteration: 41 (0 solution, 40 counterexamples)
[08/31 14:12:18]  Generator returned sat in 1.157462 secs.
[08/31 14:12:18]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:12:19]  Improved number of small numbers from 88 to 93 out of a max of 113
[08/31 14:12:19]  Verifer returned sat in 0.846741 secs.
[08/31 14:12:19]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    1274.487061    1174.487109  3359.598145  1274.487061    0.002686  1174.487109    0.00000   99.999951       99.999756       2.0          1174.487109                -1.0            -1      True
1    1274.487061    1174.487305  3359.598145  1274.487061    0.001465  1174.487305    0.00000   99.999756       -0.000244       2.0          1274.487061                 0.0         False      True
2    1474.487061    1274.522109  3359.598145  1474.487061  299.999756  1274.522109    0.00000  199.964951       99.999756       1.0          1274.487061                 0.0         False      True
3    1474.487061    1474.478776  3359.598340  1474.487061  166.675000  1474.478776    0.00000    0.008285       -0.000049       2.0          1474.487061                 0.0         False      True
4    1874.487109    1474.488359  3359.598340  1874.487109  400.008333  1474.488359    0.00125  399.997500      299.998750       1.0          1474.487061                 0.0         False      True
5    1874.487109    1674.487109  3359.598340  1874.487109    0.010000  1674.487109    0.00125  199.998750      199.998750       2.0          1874.485859                 0.0         False      True
6    1874.487109    1674.487109  3359.598340  1874.487109  199.997500  1674.487109    0.00125  199.998750       99.998750       2.0          1874.485859                 0.0         False      True
7    2074.488776    1874.487109  3359.598340  2074.488776  400.000417  1874.487109    0.00125  200.000417      200.000417       1.0          1874.485859                 0.0         False      True
8    2674.488359    1874.488281  3359.598340  2674.488359  800.000000  1874.488281  400.00250  399.997578      299.998750       2.0          1874.485859                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=320001/800, 
, buffer=239999/800.[0m
[08/31 14:12:20]  --------------------------------------------------------------------------------
[08/31 14:12:20]  Iteration: 42 (0 solution, 41 counterexamples)
[08/31 14:12:24]  Generator returned sat in 3.309405 secs.
[08/31 14:12:24]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][5]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:12:25]  Improved gap from 0.0 to 100
[08/31 14:12:25]  Improved number of small numbers from 60 to 68 out of a max of 114
[08/31 14:12:25]  Verifer returned sat in 1.033561 secs.
[08/31 14:12:25]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0      74.529541      74.527526  4459.557923    74.529541   599.988525    74.527526    0.000000    0.002015        0.002015       3.0            74.527526                -1.0            -1     False
1     674.514401      74.531276  4459.557923   674.514401   599.986875    74.531276    0.001875  599.981250      499.985000       1.0           674.512526                 0.0         False     False
2     674.520026     274.525879  4459.557923   674.520026   599.986875   274.525879    0.001875  399.992272      399.990625       2.0           674.512526                 0.0         False      True
3     674.520026     274.527526  4459.557923   674.520026   349.992500   274.527526    0.001875  399.990625      299.990625       3.0           674.518151                 0.0         False      True
4     974.514401     474.527526  4459.557923   974.514401   699.985000   474.527526    0.001875  499.985000      499.985000       4.0           674.518151                 0.0         False      True
5    1874.499401     574.527344  4459.557923  1874.499401  1399.970000   574.527344  799.986875  499.985182      499.985000       5.0           674.518151                 0.0         False      True
6    1874.499401     674.512526  4459.557923  1874.499401     0.010000   674.512526  799.986875  400.000000      399.985000       6.0          1074.512526                 0.0         False      True
7    1874.499401     674.527526  4459.557923  1874.499401   400.000000   674.527526  799.986875  399.985000      299.985000       4.0          1074.512526                 1.0         False     False
8    2274.514401     874.527344  4459.557923  2274.514401   800.000000   874.527344  900.001875  499.985182      499.985000       5.0          1074.512526                 0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=900, 
, buffer=99997/200.[0m
[08/31 14:12:26]  --------------------------------------------------------------------------------
[08/31 14:12:26]  Iteration: 43 (0 solution, 42 counterexamples)
[08/31 14:12:28]  Generator returned sat in 0.630526 secs.
[08/31 14:12:28]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][5]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:12:28]  Improved number of small numbers from 95 to 113 out of a max of 113
[08/31 14:12:28]  Verifer returned sat in 0.308311 secs.
[08/31 14:12:28]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0     174.510010      74.512207  4459.557617   174.510010  400.000000    74.512207    0.000000   99.997803       99.997559       2.0            74.512207                -1.0            -1     False
1     474.512207     174.512207  4459.557617   474.512207  400.000000   174.512207    0.000000  300.000000      299.999756       1.0            74.512207                 0.0         False     False
2     774.514893     274.512451  4459.557617   774.514893  600.002686   274.512451    0.002441  500.000000      500.000000       2.0            74.512207                 0.0         False     False
3     774.514893     374.509766  4459.557617   774.514893  200.000000   374.509766    0.002441  400.002686      400.000000       3.0           774.512451                 0.0         False      True
4     774.514893     374.512451  4459.557617   774.514893  400.000000   374.512451    0.002441  400.000000      300.000000       4.0           774.512451                 0.0         False      True
5    1174.514893     474.512451  4459.557617  1174.514893  800.000000   474.512451  100.002441  600.000000      500.000000       4.0           774.512451                 0.0         False      True
6    1174.514893     674.512451  4459.557617  1174.514893    0.010000   674.512451  100.002441  400.000000      400.000000       5.0          1074.512451                 0.0         False      True
7    1174.514893     774.512451  4459.557617  1174.514893    0.020000   774.512451  100.002441  300.000000      300.000000       6.0          1074.512451                 0.0         False      True
8    1274.514893     774.512451  4459.557617  1274.514893  400.000000   774.512451  100.002441  400.000000      300.000000       6.0          1074.512451                 1.0         False     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=100, 
, buffer=500.[0m
[08/31 14:12:29]  --------------------------------------------------------------------------------
[08/31 14:12:29]  Iteration: 44 (0 solution, 43 counterexamples)
[08/31 14:12:32]  Generator returned sat in 2.107997 secs.
[08/31 14:12:33]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:12:41]  Improved gap from 0.0008333333333333334 to 31.25
[08/31 14:12:42]  Improved number of small numbers from 67 to 87 out of a max of 114
[08/31 14:12:42]  Verifer returned sat in 9.283807 secs.
[08/31 14:12:42]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0     172.332520     172.330078  4193.022461   172.332520   31.253662   172.330078    0.00000    0.002441        0.002412       5.0           172.330078                -1.0            -1       -1
1     203.582520     172.333496  4261.769043   203.582520   31.252441   172.333496    0.00000   31.249023       -0.001006       1.0           203.582520                 1.0         False    False
2     203.584717     203.583701  4322.057617   203.584717   31.251221   203.583701    0.00000    0.001016      -39.710234       1.0           203.584717                 0.0         False    False
3     474.546201     339.062451  4322.057617   474.546201  270.962500   339.062451    0.00125  135.482500      131.250000       1.0           203.584717                 0.0         False    False
4     474.546201     443.293701  4322.057617   474.546201  135.481250   443.293701    0.00125   31.251250       31.250000       2.0           474.544951                 0.0         False     True
5     474.546201     443.294951  4390.807617   474.546201    0.010000   443.294951    0.00125   31.250000        0.000000       3.0           474.544951                 0.0         False     True
6     474.546201     474.544951  4459.557617   474.546201    0.010000   474.544951    0.00125    0.000000      -31.250000       4.0           474.544951                 0.0         False     True
7     542.292451     505.794951  4523.060303   542.292451   67.746250   505.794951    0.00125   36.496250       -0.001064       1.0           474.544951                 1.0         False    False
8     570.919951     542.292480  4523.060303   570.919951   65.123750   542.292480    0.00125   28.626221      -71.373564       1.0           570.918701                 0.0         False    False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=525/4.[0m
[08/31 14:12:42]  --------------------------------------------------------------------------------
[08/31 14:12:42]  Iteration: 45 (0 solution, 44 counterexamples)
[08/31 14:12:49]  Generator returned sat in 4.739986 secs.
[08/31 14:12:49]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:12:50]  Improved number of small numbers from 65 to 75 out of a max of 113
[08/31 14:12:50]  Verifer returned sat in 1.108482 secs.
[08/31 14:12:50]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t   losts_0,t      queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0     371.063721    -160.934814  4426.287617   371.063721  1180.045000  -160.934814     0.00000   531.998535      431.998770       9.0          -160.934814                -1.0            -1       -1
1    1019.108887      39.064951  4426.287617  1019.108887  1180.043701    39.064951     0.00000   980.043936      980.043936       8.0          1019.108887                 1.0         False    False
2    1219.107451     139.064951  4426.287617  1219.107451  1180.042500   139.064951     0.00125  1080.041250     1080.041250       8.0          1219.106201                 0.0         False    False
3    1319.108701     139.064951  4426.287617  1319.108701  1180.042500   139.064951     0.00250  1180.041250     1080.041250       8.0          1219.106201                 0.0         False     True
4    1319.108701     239.064951  4426.287617  1319.108701     0.010000   239.064951     0.00250  1080.041250      980.041250       9.0          1319.106201                 0.0         False     True
5    1319.108701     371.064951  4426.287617  1319.108701   300.020000   371.064951     0.00250   948.041250      880.041250       5.0          1319.106201                 1.0         False    False
6    1319.108701     539.064951  4426.287617  1319.108701   948.040000   539.064951     0.00250   780.041250      780.041250       6.0          1319.106201                 0.0         False    False
7    3035.147451     639.063721  4426.287617  3035.147451  2496.080000   639.063721  1316.04125  1080.042480     1080.041250       7.0          1319.106201                 0.0         False    False
8    3035.147451     639.064951  4426.287617  3035.147451     0.010000   639.064951  1316.04125  1080.041250      980.041250       8.0          1719.106201                 0.0         False     True
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=1052831/800, 
, buffer=864033/800.[0m
[08/31 14:12:50]  --------------------------------------------------------------------------------
[08/31 14:12:50]  Iteration: 46 (0 solution, 45 counterexamples)
[08/31 14:12:54]  Generator returned sat in 2.052115 secs.
[08/31 14:12:54]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:12:54]  Improved gap from 0.00125 to 100
[08/31 14:12:55]  Improved number of small numbers from 59 to 65 out of a max of 114
[08/31 14:12:55]  Verifer returned sat in 1.188962 secs.
[08/31 14:12:55]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    4221.064697    4121.065387  144.287181  4221.064697    0.000977  4121.065387    0.000000   99.999310       -0.000690       4.0          4121.065387                -1.0            -1     False
1    4321.067887    4221.065387  144.287181  4321.067887  200.002500  4221.065387    0.000833  100.001667        0.001667       1.0          4121.065387                 0.0         False     False
2    4421.066221    4321.068721  144.287181  4421.066221  200.000000  4321.068721    0.000833   99.996667        0.000000       1.0          4421.065387                 0.0         False      True
3    4521.068721    4521.065387  144.287181  4521.068721  199.999167  4521.065387    0.001667    0.001667        0.001667       1.0          4521.067054                 0.0         False      True
4    4521.077054    4521.074554  144.287181  4521.077054    0.010000  4521.074554    0.001667    0.000833      -99.990000       1.0          4521.075387                 0.0         False      True
5    4821.085387    4621.065430  144.287181  4821.085387  300.009167  4621.065430  100.018333  100.001624        0.001667       1.0          4521.075387                 0.0         False      True
6    4821.085387    4721.065804  144.287181  4821.085387    0.010000  4721.065804  100.018333    0.001250      -99.998333       2.0          4721.067054                 0.0         False      True
7    5021.084554    4921.065387  144.287181  5021.084554  200.000417  4921.065387  100.018333    0.000833        0.000833       1.0          4721.067054                 0.0         False      True
8    5421.074554    4921.067139  144.287181  5421.074554  399.990833  4921.067139  400.007500   99.999915        0.001667       1.0          4721.067054                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=480007/1200, 
, buffer=1/600.[0m
[08/31 14:12:56]  --------------------------------------------------------------------------------
[08/31 14:12:56]  Iteration: 47 (0 solution, 46 counterexamples)
[08/31 14:12:59]  Generator returned sat in 1.770847 secs.
[08/31 14:12:59]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:13:03]  Improved number of small numbers from 58 to 66 out of a max of 113
[08/31 14:13:03]  Verifer returned sat in 3.508136 secs.
[08/31 14:13:03]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    4521.027832    4321.028304  244.306139  4521.027832  200.000625  4321.028304   0.000625  199.998903       99.998903       4.0          4321.028304                -1.0            -1       -1
1    4521.028929    4521.027679  244.306139  4521.028929  200.000000  4521.027679   0.000625    0.000625        0.000000       1.0          4521.028304                 0.0         False     True
2    4921.028929    4521.028320  244.306139  4921.028929  400.000625  4521.028320   0.000625  399.999984      300.000000       1.0          4521.028304                 0.0         False     True
3    4921.028929    4654.359137  244.306139  4921.028929  133.334896  4654.359137   0.000625  266.669167      200.000000       2.0          4921.028304                 0.0         False     True
4    4921.029554    4721.028304  244.306139  4921.029554  266.669792  4721.028304   0.000625  200.000625      100.000625       3.0          4921.028304                 0.0         False     True
5    5254.368512    4821.028320  244.306139  5254.368512  533.339583  4821.028320  33.339583  400.000609      300.000625       4.0          4921.028304                 0.0         False     True
6    5254.368512    4921.028304  244.306139  5254.368512    0.010000  4921.028304  33.339583  300.000625      200.000625       5.0          5221.028929                 0.0         False     True
7    5254.368512    5121.028304  244.306139  5254.368512  133.339583  5121.028304  33.339583  100.000625      100.000625       3.0          5221.028929                 1.0         False    False
8    5421.037679    5187.697266  244.306139  5421.037679  266.669792  5187.697266  33.339583  200.000830      166.669792       4.0          5221.028929                 0.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=160027/4800, 
, buffer=480001/1600.[0m
[08/31 14:13:03]  --------------------------------------------------------------------------------
[08/31 14:13:03]  Iteration: 48 (0 solution, 47 counterexamples)
[08/31 14:13:08]  Generator returned sat in 3.405073 secs.
[08/31 14:13:08]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:13:08]  Improved gap from 0.0016666666666666668 to 100
[08/31 14:13:09]  Improved number of small numbers from 59 to 114 out of a max of 114
[08/31 14:13:09]  Verifer returned sat in 0.477450 secs.
[08/31 14:13:09]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    4520.928711    4120.728760  444.605469  4520.928711  500.299805  4120.728760   0.099854  400.100098      300.100098       7.0          4120.728760                -1.0            -1       -1
1    4621.028809    4220.729004  444.605469  4621.028809  500.200195  4220.729004   0.199951  400.099854      300.100098       8.0          4620.828857                 0.0         False     True
2    4621.028809    4420.129150  444.605469  4621.028809  400.000000  4420.129150   0.199951  200.699707      200.100098       9.0          4620.828857                 1.0         False     True
3    4820.628906    4520.229004  444.605469  4820.628906  400.299805  4520.229004   0.199951  300.199951      299.700195       9.0          4620.828857                 1.0         False    False
4    4920.728760    4620.428955  444.605469  4920.728760  400.299805  4620.428955   0.199951  300.099854      299.800049       4.0          4620.828857                 1.0         False    False
5    5020.928711    4720.428955  444.605469  5020.928711  400.299805  4720.428955   0.199951  300.299805      300.000000       3.0          4620.828857                 0.0         False    False
6    5120.928711    4820.529053  444.605469  5120.928711  400.299805  4820.529053   0.199951  300.199707      300.000000       3.0          4620.828857                 0.0         False    False
7    5221.028809    4920.629150  444.605469  5221.028809  400.299805  4920.629150   0.199951  300.199707      300.100098       3.0          4620.828857                 0.0         False    False
8    5321.128906    4920.729004  444.605469  5321.128906  400.299805  4920.729004   0.300049  400.099854      300.100098       4.0          4620.828857                 0.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=205/2048, 
, buffer=614605/2048.[0m
[08/31 14:13:09]  --------------------------------------------------------------------------------
[08/31 14:13:09]  Iteration: 49 (0 solution, 48 counterexamples)
[08/31 14:13:12]  Generator returned sat in 0.882202 secs.
[08/31 14:13:12]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:13:12]  Improved gap from 0.0003125 to 100
[08/31 14:13:13]  Improved number of small numbers from 54 to 66 out of a max of 114
[08/31 14:13:13]  Verifer returned sat in 1.483553 secs.
[08/31 14:13:13]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    4320.934814    4320.832607  1044.561719  4320.934814    0.002441  4320.832607    0.099854    0.002354      -99.997646       2.0          4320.832607                -1.0            -1      True
1    4520.932461    4420.832764  1044.561719  4520.932461  200.000000  4420.832764    0.099854   99.999844        0.000000       1.0          4320.832607                 0.0         False      True
2    4720.932617    4570.875107  1044.561719  4720.932617  300.000000  4570.875107    0.099854  149.957656      100.000156       1.0          4320.832607                 0.0         False      True
3    4720.932617    4620.832607  1044.561719  4720.932617  149.955000  4620.832607    0.099854  100.000156        0.000156       2.0          4720.832764                 0.0         False      True
4    5070.842461    4720.835107  1044.561719  5070.842461  449.910000  4720.835107   50.009854  299.997500      200.000000       1.0          4720.832764                 0.0         False      True
5    5070.842461    4820.832607  1044.561719  5070.842461    0.010000  4820.832607   50.009854  200.000000      100.000000       2.0          5020.832607                 0.0         False      True
6    5070.842461    4920.832607  1044.561719  5070.842461  124.998750  4920.832607   50.009854  100.000000        0.000000       3.0          5020.832607                 0.0         False      True
7    5370.839961    5120.832607  1044.561719  5370.839961  399.997500  5120.832607   50.009854  199.997500      199.997500       1.0          5020.832607                 0.0         False      True
8    6170.836211    5120.834961  1044.561719  6170.836211  999.993750  5120.834961  750.003604  299.997646      200.000000       2.0          5020.832607                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=111999/160, 
, buffer=200.[0m
[08/31 14:13:14]  --------------------------------------------------------------------------------
[08/31 14:13:14]  Iteration: 50 (0 solution, 49 counterexamples)
[08/31 14:13:20]  Generator returned sat in 4.919286 secs.
[08/31 14:13:20]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:13:22]  Improved number of small numbers from 75 to 99 out of a max of 113
[08/31 14:13:22]  Verifer returned sat in 1.134127 secs.
[08/31 14:13:22]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t  losts_0,t      queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    4470.647461    3970.647461  1394.746826  4470.647461   699.900000  3970.647461      0.000   500.000000      400.000000       5.0          3970.647461                -1.0            -1     False
1    4670.447266    4070.647461  1394.746826  4670.447266   699.799805  4070.647461      0.000   599.799805      499.799805       5.0          4670.447266                 0.0         False     False
2    4670.547607    4270.647461  1394.746826  4670.547607   599.900146  4270.647461      0.000   399.900146      399.900146       6.0          4670.547607                 0.0         False     False
3    4670.547607    4370.647461  1394.746826  4670.547607   266.933333  4370.647461      0.000   299.900146      299.900146       7.0          4670.547607                 0.0         False     False
4    5571.047461    4470.547607  1394.746826  5571.047461  1200.400000  4470.547607      0.100  1100.399854     1100.300000       8.0          4670.547607                 0.0         False     False
5    5571.047461    4470.647461  1394.746826  5571.047461   600.200000  4470.647461      0.100  1100.300000     1000.300000       9.0          5570.947461                 0.0         False      True
6    5771.047461    4670.647461  1394.746826  5771.047461  1300.300000  4670.647461      0.100  1100.300000     1100.300000       3.0          5570.947461                 1.0         False     False
7    7221.197461    4770.647461  1394.746826  7221.197461  2550.450000  4770.647461   1350.250  1100.300000     1100.300000       4.0          5570.947461                 0.0         False     False
8    7396.122461    4770.747559  1394.746826  7396.122461  1275.225000  4770.747559   1425.175  1200.199902     1100.300000       5.0          5970.947461                 0.0         False      True
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=3, loss_amount=57003/40, 
, buffer=11003/10.[0m
[08/31 14:13:22]  --------------------------------------------------------------------------------
[08/31 14:13:22]  Iteration: 51 (0 solution, 50 counterexamples)
[08/31 14:13:26]  Generator returned sat in 1.849544 secs.
[08/31 14:13:26]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:13:26]  Improved number of small numbers from 104 to 104 out of a max of 113
[08/31 14:13:26]  Verifer returned sat in 0.586521 secs.
[08/31 14:13:26]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t  cwnd_0,t  service_0,t  losts_0,t  queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    3470.197266    3170.247266  2295.147021  3470.197266      0.05  3170.247266       0.00   299.95          299.95       8.0          3170.247266                -1.0            -1     False
1    3470.197266    3270.247266  2295.147021  3470.197266      0.05  3270.247266       0.00   199.95          199.95       8.0          3170.247266                 0.0         False     False
2    4670.497266    3370.247266  2295.147021  4670.497266   1400.25  3370.247266       0.00  1300.25         1300.25       9.0          3170.247266                 0.0         False     False
3    4670.497266    3370.247266  2295.147021  4670.497266      0.05  3370.247266       0.00  1300.25         1200.25       9.0          4670.497266                 1.0          True     False
4    4670.497266    3470.247266  2295.147021  4670.497266    400.10  3470.247266       0.00  1200.25         1100.25       3.0          4670.497266                 1.0         False     False
5    4670.497266    3670.247266  2295.147021  4670.497266   1200.20  3670.247266       0.00  1000.25         1000.25       4.0          4670.497266                 0.0         False     False
6    6670.647266    3770.247266  2295.147021  6670.647266   3000.40  3770.247266    1500.25  1400.15         1400.15       5.0          4670.497266                 0.0         False     False
7    6770.697266    3870.247266  2295.147021  6770.697266   1500.20  3870.247266    1500.30  1400.15         1400.15       6.0          5270.397266                 0.0         False      True
8    6770.697266    3970.247266  2295.147021  6770.697266    750.10  3970.247266    1500.30  1300.15         1300.15       7.0          5270.397266                 0.0         False      True
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=15003/10, 
, buffer=28003/20.[0m
[08/31 14:13:27]  --------------------------------------------------------------------------------
[08/31 14:13:27]  Iteration: 52 (0 solution, 51 counterexamples)
[08/31 14:13:38]  Generator returned sat in 9.814133 secs.
[08/31 14:13:38]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:13:48]  Improved gap from 0.0008333333333333334 to 0
[08/31 14:13:49]  Improved number of small numbers from 36 to 48 out of a max of 114
[08/31 14:13:49]  Verifer returned sat in 10.882122 secs.
[08/31 14:13:49]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    4270.187744    4170.238099  1995.160355  4270.187744    0.000833  4170.238099  99.948089    0.001556        0.001556       4.0          4170.238099                -1.0            -1       -1
1    4370.188688    4170.238770  1995.160355  4370.188688  100.002500  4170.238770  99.948923  100.000996        0.001667       2.0          4170.238099                 0.0         False     True
2    4370.188688    4270.238932  2095.158688  4370.188688  100.000000  4270.238932  99.948923    0.000833        0.000000       2.0          4270.239766                 0.0         False     True
3    4470.191188    4270.240723  2095.158688  4470.191188  100.003333  4270.240723  99.949756  100.000710        0.001667       1.0          4270.239766                 0.0         False     True
4    4470.191188    4370.240599  2195.156982  4470.191188   50.001667  4370.240599  99.949756    0.000833       -0.000039       2.0          4370.241432                 0.0         False     True
5    4470.200355    4370.242266  2295.147217  4470.200355    0.010000  4370.242266  99.949756    0.008333       -0.000638       1.0          4370.250599                 0.0         False     True
6    4470.202021    4370.251432  2395.145996  4470.202021    0.010000  4370.251432  99.949756    0.000833       -0.000192       1.0          4370.250599                 0.0         False     True
7    4470.211188    4370.253099  2495.136963  4470.211188    0.010000  4370.253099  99.949756    0.008333       -0.000059       1.0          4370.250599                 0.0         False     True
8    4470.212855    4370.262451  2495.137207  4470.212855    0.010000  4370.262451  99.949756    0.000648      -99.998148       1.0          4370.250599                 0.0         False     True
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=1/600.[0m
[08/31 14:13:50]  --------------------------------------------------------------------------------
[08/31 14:13:50]  Iteration: 53 (0 solution, 52 counterexamples)
[08/31 14:14:02]  Generator returned sat in 10.558825 secs.
[08/31 14:14:02]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][6]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:14:11]  Improved gap from 0.0008333333333333334 to 0
[08/31 14:14:12]  Improved number of small numbers from 61 to 80 out of a max of 114
[08/31 14:14:12]  Verifer returned sat in 9.808473 secs.
[08/31 14:14:12]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    4271.263916    3970.238747  2195.159707  4271.263916    0.001221  3970.238747    0.00125  301.023919      301.023919       4.0          3970.238747                -1.0            -1       -1
1    4271.263916    4070.238525  2195.159707  4271.263916    0.001221  4070.238525    0.00125  201.024141      201.023919       4.0          3970.238747                 0.0         False     True
2    4271.263916    4071.253906  2195.159707  4271.263916    0.001465  4071.253906    0.00125  200.008760      101.023919       5.0          3970.238747                 0.0         False     True
3    4271.263916    4170.243747  2195.159707  4271.263916  200.007500  4170.243747    0.00125  101.018919        1.023919       6.0          3970.238747                 0.0         False     True
4    4370.251247    4271.262451  2195.159707  4370.251247  200.006250  4271.262451    0.00125   98.987546        0.011250       7.0          4370.249997                 0.0         False     True
5    4370.251247    4370.238770  2295.148457  4370.251247    0.010000  4370.238770    0.00125    0.011227        0.000000       2.0          4370.249997                 1.0         False    False
6    4370.251247    4370.249997  2395.148438  4370.251247    0.010000  4370.249997    0.00125    0.000000       -0.000020       3.0          4370.249997                 0.0         False    False
7    4370.261247    4370.258747  2495.137207  4370.261247    0.010000  4370.258747    0.00125    0.001250       -0.001250       1.0          4370.249997                 0.0         False    False
8    4370.269997    4370.261475  2495.137207  4370.269997    0.010000  4370.261475    0.00125    0.007272      -99.992500       1.0          4370.249997                 0.0         False    False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=616497/2048.[0m
[08/31 14:14:13]  --------------------------------------------------------------------------------
[08/31 14:14:13]  Iteration: 54 (0 solution, 53 counterexamples)
[08/31 14:14:15]  Generator returned sat in 1.205417 secs.
[08/31 14:14:16]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:14:33]  Improved gap from 1.953125e-05 to 0
[08/31 14:14:34]  Improved number of small numbers from 61 to 75 out of a max of 114
[08/31 14:14:34]  Verifer returned sat in 17.968810 secs.
[08/31 14:14:34]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    9306.333747    9006.333747  2095.159707  9306.333747    0.000833  9006.333747        0.0  300.000000      300.000000       6.0          9006.333747                -1.0            -1      True
1    9306.333747    9006.333984  2095.159707  9306.333747  299.999756  9006.333984        0.0  299.999762      200.000000       6.0          9006.333747                 0.0         False      True
2    9306.333984    9206.333740  2095.159707  9306.333984  300.000000  9206.333740        0.0  100.000244      100.000238       7.0          9006.333747                 0.0         False      True
3    9306.333984    9206.333747  2095.159707  9306.333984    0.021667  9206.333747        0.0  100.000238        0.000238       7.0          9306.333984                 0.0         False      True
4    9306.344580    9306.333747  2195.148874  9306.344580  100.010833  9306.333747        0.0    0.010833        0.000000       8.0          9306.333984                 0.0         False      True
5    9306.344580    9306.344580  2295.147217  9306.344580    0.010000  9306.344580        0.0    0.000000       -0.001657       2.0          9306.344580                 1.0         False     False
6    9306.354580    9306.346247  2395.138672  9306.354580    0.010000  9306.346247        0.0    0.008333       -0.000202       1.0          9306.344580                 0.0         False     False
7    9306.356247    9306.355413  2495.136963  9306.356247    0.010000  9306.355413        0.0    0.000833       -0.000244       1.0          9306.344580                 0.0         False     False
8    9306.365413    9306.356934  2495.137207  9306.365413    0.010000  9306.356934        0.0    0.008480      -99.990833       1.0          9306.344580                 0.0         False     False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=300.[0m
[08/31 14:14:34]  --------------------------------------------------------------------------------
[08/31 14:14:34]  Iteration: 55 (0 solution, 54 counterexamples)
[08/31 14:14:38]  Generator returned sat in 2.285525 secs.
[08/31 14:14:38]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][5]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:14:57]  Improved gap from 0.0 to 0
[08/31 14:14:58]  Improved number of small numbers from 59 to 102 out of a max of 114
[08/31 14:14:58]  Verifer returned sat in 19.395082 secs.
[08/31 14:14:58]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    5895.933350    5594.918457  1998.281982  5895.933350    0.002686  5594.918457        0.0  301.014893      301.014893       4.0          5594.918457                -1.0            -1      True
1    5895.933350    5694.918213  1998.281982  5895.933350    0.001667  5694.918213        0.0  201.015137      201.014893       4.0          5895.933350                 0.0         False      True
2    5895.933350    5794.917725  1998.281982  5895.933350    0.000833  5794.917725        0.0  101.015625      101.014893       5.0          5895.933350                 0.0         False      True
3    5994.921143    5794.918457  1998.281982  5994.921143  200.003418  5794.918457        0.0  200.002686      100.002686       5.0          5895.933350                 0.0         False      True
4    5994.921143    5895.933350  1998.281982  5994.921143  200.001709  5895.933350        0.0   98.987793        0.002686       6.0          5994.921143                 0.0         False      True
5    5994.921143    5994.920095  2098.278809  5994.921143    0.010000  5994.920095        0.0    0.001047       -0.000488       3.0          5994.921143                 1.0         False     False
6    5994.930095    5994.921762  2198.269531  5994.930095    0.010000  5994.921762        0.0    0.008333       -0.000813       1.0          5994.921143                 0.0         False     False
7    5994.931762    5994.930929  2298.268555  5994.931762    0.010000  5994.930929        0.0    0.000833       -0.000123       1.0          5994.921143                 0.0         False     False
8    5994.940929    5994.932617  2298.268799  5994.940929    0.010000  5994.932617        0.0    0.008312      -99.990712       1.0          5994.921143                 0.0         False     False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=616479/2048.[0m
[08/31 14:14:58]  --------------------------------------------------------------------------------
[08/31 14:14:58]  Iteration: 56 (0 solution, 55 counterexamples)
[08/31 14:15:11]  Generator returned sat in 10.996507 secs.
[08/31 14:15:11]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:15:12]  Improved gap from 0.000625 to 98.4375
[08/31 14:15:13]  Improved number of small numbers from 68 to 114 out of a max of 114
[08/31 14:15:13]  Verifer returned sat in 1.434361 secs.
[08/31 14:15:13]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    5695.791992    5695.591797  2197.727783  5695.791992  100.200195  5695.591797    0.099854    0.100342        0.100342       9.0          5695.591797                -1.0            -1       -1
1    5795.791748    5695.691650  2197.727783  5795.791748  100.100098  5695.691650    0.099854  100.000244        0.100098       3.0          5795.691895                 1.0         False     True
2    5795.791748    5795.591797  2197.948698  5795.791748   99.900146  5795.591797    0.099854    0.100098      -99.678988       2.0          5795.691895                 1.0         False    False
3    5995.149902    5895.371094  2198.269531  5995.149902  199.458252  5895.371094    0.099854   99.678955        0.000000       1.0          5795.691895                 1.0         False    False
4    6095.250244    6095.050049  2198.269531  6095.250244  199.779297  6095.050049    0.099854    0.100342        0.100342       1.0          5795.691895                 0.0         False    False
5    6494.508301    6195.050049  2198.269531  6494.508301  399.358398  6195.050049  299.258301    0.199951        0.199951       1.0          5795.691895                 0.0         False    False
6    6693.987549    6195.250000  2198.269531  6693.987549  199.679199  6195.250000  398.737549  100.000000        0.199951       2.0          6295.250000                 0.0         False     True
7    6693.987549    6295.150146  2199.731934  6693.987549   99.839600  6295.150146  398.737549    0.099854      -98.337646       2.0          6295.250000                 1.0         False     True
8    6893.987793    6393.587646  2199.731934  6893.987793  200.100098  6393.587646  400.200195  100.199951        0.199951       1.0          6295.250000                 1.0         False    False
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=3, loss_amount=1638811/4096, 
, buffer=819/4096.[0m
[08/31 14:15:13]  --------------------------------------------------------------------------------
[08/31 14:15:13]  Iteration: 57 (0 solution, 56 counterexamples)
[08/31 14:15:16]  Generator returned sat in 1.371816 secs.
[08/31 14:15:16]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:15:17]  Improved gap from 0.0 to 98.4375
[08/31 14:15:17]  Improved number of small numbers from 64 to 114 out of a max of 114
[08/31 14:15:17]  Verifer returned sat in 0.902948 secs.
[08/31 14:15:17]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    6095.544922    6095.542480  2196.715820  6095.544922   99.993652  6095.542480    0.000000    0.002441        0.002441       7.0          6095.542480                -1.0            -1       -1
1    6195.536133    6193.995117  2196.715820  6195.536133   99.993652  6193.995117    0.000000    1.541016       -0.006348       1.0          6095.542480                 1.0         False    False
2    6293.988770    6195.542480  2198.269287  6293.988770   99.993652  6195.542480    0.000000   98.446289       -0.000244       1.0          6095.542480                 0.0         False    False
3    6393.991455    6294.766357  2198.269287  6393.991455  198.448975  6294.766357    0.000000   99.225098        0.002441       1.0          6095.542480                 0.0         False    False
4    6493.990234    6393.992676  2198.269287  6493.990234  199.223877  6393.992676    0.000000   99.997559        0.001221       1.0          6095.542480                 0.0         False    False
5    6593.990234    6593.988770  2198.269287  6593.990234  199.997559  6593.988770    0.000000    0.001465        0.001221       1.0          6095.542480                 0.0         False    False
6    6992.435059    6593.991455  2198.269287  6992.435059  398.446289  6593.991455  298.443604  100.000000        0.002441       1.0          6095.542480                 0.0         False    False
7    6992.435059    6693.990234  2199.830566  6992.435059    0.010000  6693.990234  298.443604    0.001221      -98.436279       2.0          6693.991455                 0.0         False     True
8    7292.431396    6792.427734  2199.830566  7292.431396  299.997559  6792.427734  400.001221  100.002441        0.002441       1.0          6693.991455                 1.0         False    False
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=1638405/4096, 
, buffer=5/2048.[0m
[08/31 14:15:18]  --------------------------------------------------------------------------------
[08/31 14:15:18]  Iteration: 58 (0 solution, 57 counterexamples)
[08/31 14:15:24]  Generator returned sat in 3.931038 secs.
[08/31 14:15:24]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:15:34]  Improved gap from 0.0 to 18.75
[08/31 14:15:35]  Improved number of small numbers from 60 to 70 out of a max of 114
[08/31 14:15:35]  Verifer returned sat in 11.132200 secs.
[08/31 14:15:35]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t  cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    5448.290039    5447.890059  2844.268242  5448.290039    200.50  5447.890059        0.1    0.299980        0.199980       8.0          5447.890059                -1.0            -1       -1
1    5648.390059    5447.990059  2844.268242  5648.390059    200.40  5447.990059      100.2  100.200000        0.200000       3.0          5548.190059                 1.0         False     True
2    5748.490059    5548.190059  2844.268242  5748.490059    200.30  5548.190059      100.3  100.000000        0.200000       2.0          5648.190059                 1.0         False     True
3    5799.290059    5698.890059  2844.268311  5799.290059    150.80  5698.890059      100.3    0.100000      -48.999932       1.0          5698.990059                 1.0         False     True
4    5874.590059    5755.640059  2917.868164  5874.590059     75.40  5755.640059      100.3   18.650000       -0.100078       1.0          5774.290059                 0.0         False     True
5    5893.640059    5774.390137  2998.918242  5893.640059     37.70  5774.390137      100.3   18.949922        0.000000       1.0          5793.340059                 0.0         False     True
6    5893.640059    5793.340059  3080.168242  5893.640059     18.85  5793.340059      100.3    0.000000      -18.750000       2.0          5793.340059                 0.0         False     True
7    5950.290059    5812.090059  3142.168213  5950.290059     56.65  5812.090059      100.3   37.900000       -0.100029       1.0          5793.340059                 1.0         False    False
8    5968.940059    5850.090088  3142.168457  5968.940059     56.55  5850.090088      100.3   18.549971      -81.449785       1.0          5868.640059                 0.0         False    False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=1/5.[0m
[08/31 14:15:35]  --------------------------------------------------------------------------------
[08/31 14:15:35]  Iteration: 59 (0 solution, 58 counterexamples)
[08/31 14:15:39]  Generator returned sat in 1.897446 secs.
[08/31 14:15:39]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:15:40]  Improved gap from 8.3 to 100
[08/31 14:15:40]  Improved number of small numbers from 60 to 66 out of a max of 114
[08/31 14:15:40]  Verifer returned sat in 1.095522 secs.
[08/31 14:15:40]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t    losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    6348.477539    5093.346309  3098.911992  6348.477539    0.001465  5093.346309  1155.132500   99.998730       -0.001270       8.0          5093.346309                -1.0            -1       -1
1    6548.471309    5193.346309  3098.911992  6548.471309  299.992500  5193.346309  1155.132500  199.992500       99.992500       1.0          5093.346309                 1.0         False     True
2    6648.470059    5393.346309  3098.911992  6648.470059  299.991250  5393.346309  1155.132500   99.991250       99.991250       1.0          5493.337559                 0.0         False     True
3    6648.470059    5393.346309  3098.911992  6648.470059   60.883611  5393.346309  1155.132500   99.991250       -0.008750       1.0          5493.337559                 0.0         False     True
4    6789.804225    5593.346309  3098.911992  6789.804225  241.325417  5593.346309  1155.132500   41.325417       41.325417       1.0          5493.337559                 0.0         False     True
5    7310.466934    5593.346436  3098.911992  7310.466934  561.988125  5593.346436  1517.126875  199.993623       99.993750       2.0          5493.337559                 0.0         False     True
6    7310.466934    5793.338809  3098.911992  7310.466934    0.010000  5793.338809  1517.126875    0.001250       -0.006250       2.0          5793.340059                 1.0          True     True
7    7510.466934    5885.346309  3098.911992  7510.466934  200.001250  5885.346309  1517.126875  107.993750       99.993750       1.0          5793.340059                 1.0         False    False
8    7648.473809    5993.346191  3098.911992  7648.473809  246.000625  5993.346191  1555.133750   99.993867       99.993750       1.0          5793.340059                 0.0         False    False
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=320001/800, 
, buffer=15999/160.[0m
[08/31 14:15:41]  --------------------------------------------------------------------------------
[08/31 14:15:41]  Iteration: 60 (0 solution, 59 counterexamples)
[08/31 14:15:45]  Generator returned sat in 1.806528 secs.
[08/31 14:15:45]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:15:46]  Improved gap from 0.01 to 100
[08/31 14:15:47]  Improved number of small numbers from 59 to 65 out of a max of 114
[08/31 14:15:47]  Verifer returned sat in 2.500966 secs.
[08/31 14:15:47]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t    losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    6440.125488    6440.124156  3098.911992  6440.125488   375.022949  6440.124156     0.000000    0.001332        0.001332       5.0          6440.124156                -1.0            -1       -1
1    6815.147281    6440.126656  3098.911992  6815.147281   375.023125  6440.126656   100.000000  275.020625      175.023125       1.0          6440.124156                 1.0         False    False
2    6915.148531    6540.124268  3098.911992  6915.148531   375.021875  6540.124268   100.001250  275.023013      175.023125       2.0          6815.147281                 0.0         False     True
3    6915.148531    6690.122906  3098.911992  6915.148531   250.001250  6690.122906   100.001250  125.024375       75.023125       3.0          6815.147281                 1.0         False     True
4    7040.124156    6815.148531  3098.911992  7040.124156   250.000000  6815.148531   100.001250  124.974375       99.998750       1.0          6940.122906                 1.0         False    False
5    7227.660718    6940.124156  3098.911992  7227.660718   312.510938  6940.124156   112.513437  175.023125      175.023125       1.0          6940.122906                 0.0         False    False
6    7227.660718    6940.124156  3098.911992  7227.660718     0.010000  6940.124156   112.513437  175.023125       75.023125       1.0          7115.147281                 0.0         False     True
7    7427.659468    7115.148531  3098.911992  7427.659468   375.021875  7115.148531   112.513437  199.997500      175.021875       1.0          7115.147281                 0.0         False     True
8    8427.705718    7240.124023  3098.911992  8427.705718  1200.043750  7240.124023  1012.558437  175.023257      175.023125       2.0          7115.147281                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=2920183/3200, 
, buffer=280037/1600.[0m
[08/31 14:15:48]  --------------------------------------------------------------------------------
[08/31 14:15:48]  Iteration: 61 (0 solution, 60 counterexamples)
[08/31 14:16:05]  Generator returned sat in 15.586109 secs.
[08/31 14:16:05]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:16:06]  Improved gap from 0.0 to 100
[08/31 14:16:06]  Improved number of small numbers from 59 to 114 out of a max of 114
[08/31 14:16:06]  Verifer returned sat in 0.496464 secs.
[08/31 14:16:06]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t  losts_0,t      queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    6715.098389    6615.098633  2823.937744  6715.098389     0.024902  6615.098633   0.024902    99.974854       -0.024902       5.0          6615.098633                -1.0            -1       -1
1    6815.123535    6715.098633  2823.937744  6815.123535   200.000000  6715.098633   0.024902   100.000000        0.000244       1.0          6615.098633                 1.0         False     True
2    6915.148438    6915.098389  2823.937744  6915.148438   200.024902  6915.098389   0.024902     0.025146        0.025146       1.0          6615.098633                 0.0         False     True
3    7115.123291    6915.148682  2823.937744  7115.123291   200.000000  6915.148682   0.024902   199.949707      100.000000       1.0          7115.098389                 0.0         False     True
4    7315.173584    7115.098389  2823.937744  7315.173584   400.000000  7115.098389   0.024902   200.050293      200.050293       2.0          7115.098389                 0.0         False     True
5    7915.123291    7115.098389  2823.937744  7915.123291   800.000000  7115.098389   0.024902   800.000000      700.000000       2.0          7115.098389                 0.0         False     True
6    8715.123291    7215.098389  2823.937744  8715.123291  1600.000000  7215.098389   0.024902  1500.000000     1400.000000       3.0          7115.098389                 0.0         False     True
7    8715.123291    7315.173340  2823.937744  8715.123291   800.000000  7315.173340   0.024902  1399.925049     1300.000000       3.0          8715.098389                 1.0          True    False
8    8715.123291    7515.098389  2823.937744  8715.123291   400.000000  7515.098389   0.024902  1200.000000     1200.000000       4.0          8715.098389                 1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=0, loss_amount=0, 
, buffer=1400.[0m
[08/31 14:16:07]  --------------------------------------------------------------------------------
[08/31 14:16:07]  Iteration: 62 (0 solution, 61 counterexamples)
[08/31 14:16:11]  Generator returned sat in 2.601719 secs.
[08/31 14:16:11]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][5]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:16:21]  Improved gap from 0.0 to 9.375
[08/31 14:16:21]  Improved number of small numbers from 74 to 83 out of a max of 114
[08/31 14:16:21]  Verifer returned sat in 10.116206 secs.
[08/31 14:16:21]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    7839.773438    7739.798389  2593.587646  7839.773438    0.050049  7739.798389   0.024902   99.950146       99.950049       2.0          7739.798389                -1.0            -1     False
1    7839.823291    7739.798584  2593.587744  7839.823291  100.000000  7739.798584   0.024902   99.999805        0.000000       2.0          7739.798389                 0.0         False     False
2    7839.823291    7839.798389  2593.587744  7839.823291   99.950195  7839.798389   0.024902    0.000000     -100.000000       2.0          7839.798389                 0.0         False     False
3    8141.423291    8039.798389  2593.587744  8141.423291  301.600000  8039.798389   0.024902  101.600000      101.600000       1.0          7839.798389                 0.0         False     False
4    8190.623291    8115.148193  2593.587744  8190.623291  150.800000  8115.148193   0.024902   75.450195       50.800000       2.0          8190.598389                 0.0         False     False
5    8190.623291    8141.448486  2642.787744  8190.623291   75.400000  8141.448486   0.024902   49.149902        0.000000       2.0          8190.598389                 0.0         False     False
6    8190.623291    8190.598389  2733.412744  8190.623291   37.700000  8190.598389   0.024902    0.000000       -9.375000       3.0          8190.598389                 0.0         False     False
7    8209.473291    8199.973389  2823.937744  8209.473291   18.850000  8199.973389   0.024902    9.475000        0.000000       1.0          8209.448389                 0.0         False     False
8    8209.473291    8209.448389  2823.937744  8209.473291    9.425000  8209.448389   0.024902    0.000000     -100.000000       2.0          8209.448389                 0.0         False     False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=208179/2048.[0m
[08/31 14:16:22]  --------------------------------------------------------------------------------
[08/31 14:16:22]  Iteration: 63 (0 solution, 62 counterexamples)
[08/31 14:16:30]  Generator returned sat in 5.774244 secs.
[08/31 14:16:30]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:16:51]  Improved gap from 0.0 to 0
[08/31 14:16:52]  Improved number of small numbers from 59 to 84 out of a max of 114
[08/31 14:16:52]  Verifer returned sat in 22.367423 secs.
[08/31 14:16:52]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    8989.318115    8556.303389  2544.090332  8989.318115    0.001221  8556.303389   0.024902  432.989824      399.999912       6.0          8556.303389                -1.0            -1       -1
1    9088.293291    8689.293213  2544.090332  9088.293291  531.965000  8689.293213   0.024902  398.975176      398.975088       6.0          8556.303389                 0.0         False     True
2    9088.294434    8689.293457  2544.090332  9088.294434  398.976318  8689.293457   0.024902  398.976074      298.976230       7.0          9088.269531                 0.0         False     True
3    9088.294434    8822.293389  2544.090332  9088.294434  265.987500  8822.293389   0.024902  265.976143      198.976230       8.0          9088.269531                 0.0         False     True
4    9088.307041    8989.293213  2544.090332  9088.307041  265.988750  8989.293213   0.024902   98.988926       98.988838       9.0          9088.269531                 0.0         False     True
5    9088.307041    9088.270996  2545.101494  9088.307041    0.010000  9088.270996   0.024902    0.011143        0.000000       2.0          9088.282139                 1.0         False    False
6    9088.307041    9088.282139  2645.100244  9088.307041    0.010000  9088.282139   0.024902    0.000000       -0.001250       3.0          9088.282139                 0.0         False    False
7    9088.317041    9088.283389  2745.091494  9088.317041    0.010000  9088.283389   0.024902    0.008750        0.000000       1.0          9088.282139                 0.0         False    False
8    9088.318291    9088.292236  2845.090088  9088.318291    0.010000  9088.292236   0.024902    0.001152       -0.000156       1.0          9088.282139                 0.0         False    False
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=400.[0m
[08/31 14:16:53]  --------------------------------------------------------------------------------
[08/31 14:16:53]  Iteration: 64 (0 solution, 63 counterexamples)
[08/31 14:17:01]  Generator returned sat in 5.806225 secs.
[08/31 14:17:01]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:17:02]  Improved number of small numbers from 67 to 75 out of a max of 113
[08/31 14:17:02]  Verifer returned sat in 0.889504 secs.
[08/31 14:17:02]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    8388.291621    7788.290371  3345.093262  8388.291621  700.000000  7788.290371    0.00125  600.000000       600.00000       6.0          7788.290371                -1.0            -1       -1
1    8488.290371    7888.290371  3345.093262  8488.290371  699.998750  7888.290371    0.00125  599.998750       599.99875       3.0          8488.289121                 0.0         False     True
2    8588.289121    7988.290283  3345.093262  8588.289121  699.997500  7988.290283    0.00125  599.997588       599.99750       3.0          8588.287871                 0.0         False     True
3    8588.289121    8088.290283  3345.093262  8588.289121   87.500156  8088.290283    0.00125  499.997588       499.99750       4.0          8588.287871                 0.0         False     True
4    8588.289121    8188.286621  3345.093262  8588.289121  175.000313  8188.286621    0.00125  400.001250       399.99750       5.0          8588.287871                 0.0         False     True
5    8588.289121    8288.290371  3345.093262  8588.289121  350.000625  8288.290371    0.00125  299.997500       299.99750       6.0          8588.287871                 0.0         False     True
6    8988.292871    8388.289062  3345.093262  8988.292871  700.001250  8388.289062    0.00250  600.001309       600.00000       7.0          8588.287871                 0.0         False     True
7    8988.292871    8388.290371  3345.093262  8988.292871    0.010000  8388.290371    0.00250  600.000000       500.00000       8.0          8988.290371                 0.0         False     True
8    8988.292871    8588.289062  3345.093262  8988.292871  200.003750  8588.289062    0.00250  400.001309       400.00000       3.0          8988.290371                 1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=1/800, 
, buffer=600.[0m
[08/31 14:17:02]  --------------------------------------------------------------------------------
[08/31 14:17:02]  Iteration: 65 (0 solution, 64 counterexamples)
[08/31 14:17:07]  Generator returned sat in 2.280519 secs.
[08/31 14:17:07]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:17:08]  Improved number of small numbers from 83 to 83 out of a max of 113
[08/31 14:17:08]  Verifer returned sat in 0.990679 secs.
[08/31 14:17:08]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    8588.268496    7788.286621  3345.093262  8588.268496  899.980625  7788.286621   0.001250  799.980625      699.980625       7.0          7788.286621                -1.0            -1       -1
1    8688.267871    7988.285996  3345.093262  8688.267871  899.980000  7988.285996   0.001250  699.980625      699.980000       3.0          8688.266621                 0.0         False     True
2    8688.268496    7988.286621  3345.093262  8688.268496  699.981250  7988.286621   0.001250  699.980625      599.980625       3.0          8688.267246                 0.0         False     True
3    8688.268496    8088.286621  3345.093262  8688.268496   99.997656  8088.286621   0.001250  599.980625      499.980625       4.0          8688.267246                 0.0         False     True
4    8688.268496    8188.286621  3345.093262  8688.268496  199.995313  8188.286621   0.001250  499.980625      399.980625       5.0          8688.267246                 0.0         False     True
5    8688.268496    8388.286621  3345.093262  8688.268496  399.990625  8388.286621   0.001250  299.980625      299.980625       6.0          8688.267246                 0.0         False     True
6    9188.269121    8488.286621  3345.093262  9188.269121  799.981250  8488.286621   0.001875  699.980625      699.980625       7.0          8688.267246                 0.0         False     True
7    9188.269121    8588.267246  3345.093262  9188.269121    0.010000  8588.267246   0.001875  600.000000      599.980625       8.0          9188.267246                 0.0         False     True
8    9188.269121    8688.286621  3345.093262  9188.269121  199.995313  8688.286621   0.001875  499.980625      499.980625       3.0          9188.267246                 1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=1/1600, 
, buffer=1119969/1600.[0m
[08/31 14:17:08]  --------------------------------------------------------------------------------
[08/31 14:17:08]  Iteration: 66 (0 solution, 65 counterexamples)
[08/31 14:17:18]  Generator returned sat in 7.317944 secs.
[08/31 14:17:18]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:17:20]  Improved number of small numbers from 41 to 43 out of a max of 113
[08/31 14:17:20]  Verifer returned sat in 2.265639 secs.
[08/31 14:17:20]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t     cwnd_0,t  service_0,t    losts_0,t      queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    8688.267871    7688.566377  3345.093262   8688.267871     0.100000  7688.566377   299.801494   699.900000      699.900000       8.0          7688.566377                -1.0            -1       -1
1    8688.267871    7713.566377  3345.093262   8688.267871     0.199951  7713.566377   299.801494   674.900000      599.900000       8.0          7688.566377                 0.0         False     True
2    8688.267871    7888.566377  3345.093262   8688.267871     0.100098  7888.566377   299.801494   499.900000      499.900000       6.0          8388.466377                 0.0         False     True
3    9554.183256    7888.566377  3345.093262   9554.183256  1365.815385  7888.566377   299.801494  1365.815385     1265.815385       6.0          8388.466377                 0.0         False     True
4    9554.183256    7988.566377  3345.093262   9554.183256   782.907692  7988.566377   299.801494  1265.815385     1165.815385       7.0          9254.381762                 0.0         False     True
5    9554.183256    8180.566377  3345.093262   9554.183256   528.953846  8180.566377   299.801494  1073.815385     1065.815385       8.0          9254.381762                 0.0         False     True
6    9554.183256    8188.566377  3345.093262   9554.183256   410.476923  8188.566377   299.801494  1065.815385      965.815385       9.0          9254.381762                 0.0         False     True
7    9554.183256    8388.566377  3345.093262   9554.183256  1065.715385  8388.566377   299.801494   865.815385      865.815385       5.0          9254.381762                 1.0         False    False
8   10886.940948    8388.566406  3345.093262  10886.940948  2198.573077  8388.566406  1132.459186  1365.915355     1265.915385       6.0          9254.381762                 0.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=216491/260, 
, buffer=164569/130.[0m
[08/31 14:17:21]  --------------------------------------------------------------------------------
[08/31 14:17:21]  Iteration: 67 (0 solution, 66 counterexamples)
[08/31 14:17:25]  Generator returned sat in 2.740139 secs.
[08/31 14:17:26]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][6]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:17:26]  Improved number of small numbers from 67 to 113 out of a max of 113
[08/31 14:17:26]  Verifer returned sat in 0.867678 secs.
[08/31 14:17:26]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t     cwnd_0,t  service_0,t    losts_0,t      queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    7688.458740    7088.433838  3345.093018   7688.458740     0.024902  7088.433838     0.000000   600.024902      500.037354       3.0          7088.433838                -1.0            -1      True
1    7688.483887    7188.471191  3345.093018   7688.483887   600.050049  7188.471191     0.000000   500.012695      400.062500       3.0          7088.433838                 0.0         False      True
2    7688.483887    7388.421387  3345.093018   7688.483887   500.012451  7388.421387     0.000000   300.062500      300.062500       4.0          7688.483887                 0.0         False      True
3    7688.483887    7388.421387  3345.093018   7688.483887   300.037354  7388.421387     0.000000   300.062500      200.062500       4.0          7688.483887                 0.0         False      True
4    7688.483887    7488.433838  3345.093018   7688.483887   300.012451  7488.433838     0.000000   200.050049      100.062500       5.0          7688.483887                 0.0         False      True
5    7788.421387    7688.408936  3345.093018   7788.421387   299.987549  7688.408936     0.000000   100.012451      100.000000       6.0          7788.421387                 0.0         False      True
6    7988.396484    7688.433838  3345.093018   7988.396484   299.987549  7688.433838     0.000000   299.962646      199.975098       7.0          7788.421387                 0.0         False      True
7    8888.433838    7788.421387  3345.093018   8888.433838  1200.000000  7788.421387     0.000000  1100.012451     1000.012451       3.0          7788.421387                 1.0         False     False
8   10788.396484    7988.421387  3345.093018  10788.396484  2999.975098  7988.421387  1799.962402  1000.012695     1000.012695       2.0          7788.421387                 0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=3686323/2048, 
, buffer=1024013/1024.[0m
[08/31 14:17:27]  --------------------------------------------------------------------------------
[08/31 14:17:27]  Iteration: 68 (0 solution, 67 counterexamples)
[08/31 14:17:38]  Generator returned sat in 9.189538 secs.
[08/31 14:17:38]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][5]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:17:39]  Improved number of small numbers from 77 to 90 out of a max of 113
[08/31 14:17:39]  Verifer returned sat in 0.901545 secs.
[08/31 14:17:39]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    7288.283936    6988.333740  3345.093018  7288.283936  600.100000  6988.333740       0.00  299.950195      299.950049       4.0          6988.333740                -1.0            -1     False
1    7588.383789    7088.333740  3345.093018  7588.383789  600.050049  7088.333740       0.00  500.050049      500.049902       4.0          7588.383789                 0.0         False     False
2    7688.483887    7188.333740  3345.093018  7688.483887  600.150146  7188.333740       0.05  500.100146      500.100000       3.0          7588.383789                 0.0         False     False
3    7688.483887    7287.433887  3345.093018  7688.483887   75.006250  7287.433887       0.05  401.000000      400.100000       4.0          7688.433887                 0.0         False      True
4    7688.483887    7288.333887  3345.093018  7688.483887  150.012500  7288.333887       0.05  400.100000      300.100000       4.0          7688.433887                 0.0         False      True
5    7688.483887    7488.333887  3345.093018  7688.483887  300.025000  7488.333887       0.05  200.100000      200.100000       5.0          7688.433887                 0.0         False      True
6    8088.433887    7488.383887  3345.093018  8088.433887  600.050000  7488.383887       0.05  600.000000      500.050000       6.0          7688.433887                 0.0         False      True
7    8088.433887    7688.333887  3345.093018  8088.433887  400.500000  7688.333887       0.05  400.050000      400.050000       6.0          8088.383887                 1.0         False     False
8    8088.633887    7688.483887  3345.093018  8088.633887  400.250000  7688.483887       0.05  400.100000      300.250000       3.0          8088.583887                 1.0         False     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=0, loss_amount=0, 
, buffer=5001/10.[0m
[08/31 14:17:40]  --------------------------------------------------------------------------------
[08/31 14:17:40]  Iteration: 69 (0 solution, 68 counterexamples)
[08/31 14:17:50]  Generator returned sat in 7.784348 secs.
[08/31 14:17:50]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:17:52]  Improved gap from 0.00125 to 100
[08/31 14:17:53]  Improved number of small numbers from 71 to 114 out of a max of 114
[08/31 14:17:53]  Verifer returned sat in 2.446777 secs.
[08/31 14:17:53]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    7688.333740    7588.333984  3344.693115  7688.333740  100.099854  7588.333984        0.0   99.999756       99.899902       4.0          7588.333984                -1.0            -1     False
1    7688.433838    7588.433838  3344.693115  7688.433838  100.099854  7588.433838        0.0  100.000000        0.000000       5.0          7588.333984                 0.0         False     False
2    8188.733643    7688.533691  3344.693115  8188.733643  600.299805  7688.533691        0.0  500.199951      400.299805       1.0          7588.333984                 0.0         False     False
3    8188.733643    7788.434082  3344.693115  8188.733643  400.199951  7788.434082        0.0  400.299561      300.299805       2.0          8188.733643                 0.0         False     False
4    8188.733643    7888.434082  3344.693115  8188.733643  400.199951  7888.434082        0.0  300.299561      200.299805       3.0          8188.733643                 0.0         False     False
5    8288.634033    8088.433838  3344.693115  8288.634033  400.199951  8088.433838        0.0  200.200195      200.200195       4.0          8188.733643                 0.0         False     False
6    8488.633789    8188.433838  3344.693115  8488.633789  400.199951  8188.433838        0.0  300.199951      300.199951       5.0          8188.733643                 0.0         False     False
7    8588.633789    8288.433838  3344.693115  8588.633789  400.199951  8288.433838        0.0  300.199951      300.199951       3.0          8188.733643                 0.0         False     False
8    8688.633789    8288.533936  3344.693115  8688.633789  400.199951  8288.533936        0.0  400.099854      300.199951       4.0          8188.733643                 0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=0, loss_amount=0, 
, buffer=820019/2048.[0m
[08/31 14:17:53]  --------------------------------------------------------------------------------
[08/31 14:17:53]  Iteration: 70 (0 solution, 69 counterexamples)
[08/31 14:17:59]  Generator returned sat in 3.240714 secs.
[08/31 14:17:59]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:18:00]  Improved number of small numbers from 59 to 68 out of a max of 113
[08/31 14:18:00]  Verifer returned sat in 1.061400 secs.
[08/31 14:18:00]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    7253.404082    7009.894287  3879.720371  7253.404082   243.507568  7009.894287     0.0025  243.507295        199.9950       2.0          7009.894287                -1.0            -1       -1
1    7253.404082    7153.406582  3879.720371  7253.404082   243.505000  7153.406582     0.0025   99.995000         99.9950       2.0          7253.401582                 0.0         False     True
2    7396.911582    7253.404297  3879.720371  7396.911582   243.502500  7253.404297     0.0025  143.504785        143.5025       1.0          7396.909082                 0.0         False     True
3    7396.911582    7253.406582  3879.720371  7396.911582   143.502500  7253.406582     0.0025  143.502500         43.5025       2.0          7396.909082                 0.0         False     True
4    7540.414082    7453.406582  3879.720371  7540.414082   287.005000  7453.406582     0.0025   87.005000         87.0050       1.0          7396.909082                 0.0         False     True
5    8027.419082    7540.414082  3879.720371  8027.419082   574.010000  7540.414082     0.0025  487.002500        474.0100       1.0          7396.909082                 0.0         False     True
6    8688.436582    7553.406738  3879.720371  8688.436582  1148.020000  7553.406738   561.0175  574.012344        474.0125       2.0          7396.909082                 0.0         False     True
7    8688.436582    7740.411582  3879.720371  8688.436582     0.010000  7740.411582   561.0175  387.007500        374.0125       3.0          8127.419082                 0.0         False     True
8    8688.436582    7853.406494  3879.720371  8688.436582   287.005000  7853.406494   561.0175  274.012588        274.0125       4.0          8127.419082                 1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=112203/200, 
, buffer=37921/80.[0m
[08/31 14:18:00]  --------------------------------------------------------------------------------
[08/31 14:18:00]  Iteration: 71 (0 solution, 70 counterexamples)
[08/31 14:18:11]  Generator returned sat in 8.495439 secs.
[08/31 14:18:11]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:18:13]  Improved number of small numbers from 43 to 69 out of a max of 113
[08/31 14:18:13]  Verifer returned sat in 1.322707 secs.
[08/31 14:18:13]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    7740.412842    7009.894287  3879.720371  7740.412842   587.008545  7009.894287    0.001221  730.517334      687.005039       5.0          7009.894287                -1.0            -1       -1
1    7740.412842    7153.406494  3879.720371  7740.412842   587.007324  7153.406494    0.001221  587.005127      587.005039       5.0          7740.411621                 0.0         False     True
2    7740.414062    7253.406494  3879.720371  7740.414062   587.006348  7253.406494    0.001221  487.006348      487.006260       6.0          7740.412842                 0.0         False     True
3    7740.414062    7253.406582  3879.720371  7740.414062   243.503110  7253.406582    0.001221  487.006260      387.006260       7.0          7740.412842                 0.0         False     True
4    7740.414062    7453.406582  3879.720371  7740.414062   487.006221  7453.406582    0.001221  287.006260      287.006260       8.0          7740.412842                 0.0         False     True
5    8427.420244    7453.406582  3879.720371  8427.420244   974.012441  7453.406582    0.001221  974.012441      874.012441       8.0          7740.412842                 0.0         False     True
6    9401.432686    7553.406738  3879.720371  9401.432686  1948.024883  7553.406738  874.012441  974.013506      874.013662       8.0          7740.412842                 0.0         False     True
7    9401.432686    7740.411582  3879.720371  9401.432686     0.010000  7740.411582  874.012441  787.008662      774.013662       9.0          8527.420244                 0.0         False     True
8    9401.432686    7853.406494  3879.720371  9401.432686   574.030000  7853.406494  874.012441  674.013750      674.013662       4.0          8527.420244                 1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=89498749/102400, 
, buffer=89498999/102400.[0m
[08/31 14:18:13]  --------------------------------------------------------------------------------
[08/31 14:18:13]  Iteration: 72 (0 solution, 71 counterexamples)
[08/31 14:18:20]  Generator returned sat in 4.849800 secs.
[08/31 14:18:20]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:18:21]  Improved gap from 0.0008333333333333334 to 100
[08/31 14:18:22]  Improved number of small numbers from 59 to 69 out of a max of 114
[08/31 14:18:22]  Verifer returned sat in 1.328660 secs.
[08/31 14:18:22]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    9401.132568    8701.032686  3879.720371  9401.132568  700.199951  8701.032686        0.1  699.999883      599.999883       6.0          8701.032686                -1.0            -1       -1
1    9401.232686    8901.032686  3879.720371  9401.232686  700.100000  8901.032686        0.1  500.100000      500.100000       6.0          9401.132686                 0.0         False     True
2    9401.332686    9001.032471  3879.720371  9401.332686  500.200000  9001.032471        0.1  400.200215      400.200000       5.0          9401.232686                 0.0         False     True
3    9401.332686    9101.032471  3879.720371  9401.332686   74.987500  9101.032471        0.1  300.200215      300.200000       6.0          9401.232686                 0.0         False     True
4    9401.332686    9200.982686  3879.720371  9401.332686  149.975000  9200.982686        0.1  200.250000      200.200000       7.0          9401.232686                 0.0         False     True
5    9501.032686    9201.332686  3879.720371  9501.032686  299.950000  9201.332686        0.1  299.600000      199.900000       8.0          9401.232686                 0.0         False     True
6    9801.332686    9401.032471  3879.720371  9801.332686  599.900000  9401.032471        0.1  400.200215      400.200000       9.0          9401.232686                 0.0         False     True
7    9801.332686    9501.032686  3879.720371  9801.332686  300.000000  9501.032686        0.1  300.200000      300.200000       2.0          9801.232686                 1.0         False    False
8    9801.332686    9501.032715  3879.720371  9801.332686  300.050000  9501.032715        0.1  300.199971      200.200000       3.0          9801.232686                 0.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=0, loss_amount=0, 
, buffer=600.[0m
[08/31 14:18:22]  --------------------------------------------------------------------------------
[08/31 14:18:22]  Iteration: 73 (0 solution, 72 counterexamples)
[08/31 14:18:37]  Generator returned sat in 12.837399 secs.
[08/31 14:18:37]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:18:38]  Improved gap from 66.65625 to 100
[08/31 14:18:39]  Improved number of small numbers from 73 to 93 out of a max of 114
[08/31 14:18:39]  Verifer returned sat in 1.320711 secs.
[08/31 14:18:39]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t    cwnd_0,t   service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0    9401.132568    9401.131104  3779.719482   9401.132568    0.003662   9401.131104    0.00000    0.001465        0.000000       2.0          9401.131104                -1.0            -1      True
1    9401.133789    9401.132568  3779.719482   9401.133789    0.002686   9401.132568    0.00000    0.001221      -99.998779       3.0          9401.133789                 0.0         False      True
2    9601.132568    9501.132568  3779.719482   9601.132568  200.000000   9501.132568    0.00000  100.000000        0.000000       1.0          9401.133789                 1.0         False     False
3    9734.439235    9701.132324  3779.719482   9734.439235  233.306667   9701.132324    0.00125   33.305661       33.305417       1.0          9401.133789                 0.0         False     False
4    9734.439235    9734.436735  3779.719482   9734.439235    0.010000   9734.436735    0.00125    0.001250      -66.694583       2.0          9734.437985                 0.0         False      True
5    9901.110068    9901.107568  3779.719482   9901.110068  166.672083   9901.107568    0.00125    0.001250       -0.023750       1.0          9734.437985                 0.0         False      True
6   10434.440485   10001.131348  3779.719482  10434.440485  533.331667  10001.131348  400.00250   33.306637       33.305417       1.0          9734.437985                 0.0         False      True
7   10434.440485   10001.132568  3779.719482  10434.440485    0.010000  10001.132568  400.00250   33.305417      -66.694583       2.0         10034.437985                 0.0         False      True
8   10534.502985   10101.132568  3779.719482  10534.502985  133.367917  10101.132568  400.00250   33.367917      -66.632083       1.0         10034.437985                 0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=320001/800, 
, buffer=79933/2400.[0m
[08/31 14:18:39]  --------------------------------------------------------------------------------
[08/31 14:18:39]  Iteration: 74 (0 solution, 73 counterexamples)
[08/31 14:18:48]  Generator returned sat in 6.379735 secs.
[08/31 14:18:48]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:18:49]  Improved gap from 50.013125 to 100
[08/31 14:18:51]  Improved number of small numbers from 60 to 64 out of a max of 114
[08/31 14:18:51]  Verifer returned sat in 2.263646 secs.
[08/31 14:18:51]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t    cwnd_0,t   service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    9934.422852    9834.419235  3246.432816   9934.422852    0.001465   9834.419235    0.00125  100.002367        0.002367       2.0          9834.419235                -1.0            -1       -1
1   10034.421735    9934.420485  3246.432816  10034.421735  200.001250   9934.420485    0.00125  100.000000        0.001250       2.0          9834.419235                 0.0         False     True
2   10134.421735   10134.419235  3246.432816  10134.421735  200.000000  10134.419235    0.00125    0.001250        0.001250       1.0         10134.420485                 0.0         False     True
3   10184.420485   10134.419235  3246.432816  10184.420485   50.000000  10134.419235    0.00125   50.000000      -50.000000       1.0         10184.419235                 0.0         False     True
4   10334.420485   10309.402985  3246.432816  10334.420485  200.000000  10309.402985    0.00125   25.016250        0.000000       1.0         10184.419235                 0.0         False     True
5   10696.895485   10434.412985  3246.432816  10696.895485  387.491250  10434.412985  262.47375    0.008750        0.002500       1.0         10184.419235                 0.0         False     True
6   10696.896735   10434.419235  3246.432816  10696.896735    0.010000  10434.419235  262.47375    0.003750      -99.996250       2.0         10434.422985                 0.0         False     True
7   10846.902985   10584.427985  3246.432816  10846.902985  150.010000  10584.427985  262.47375    0.001250      -49.990000       1.0         10434.422985                 0.0         False     True
8   11134.424235   10634.419434  3246.432816  11134.424235  287.522500  10634.419434  400.00250  100.002301        0.002500       1.0         10434.422985                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=320001/800, 
, buffer=1/400.[0m
[08/31 14:18:51]  --------------------------------------------------------------------------------
[08/31 14:18:51]  Iteration: 75 (0 solution, 74 counterexamples)
[08/31 14:19:01]  Generator returned sat in 7.879250 secs.
[08/31 14:19:01]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:19:24]  Improved gap from 0.0 to 0
[08/31 14:19:25]  Improved number of small numbers from 59 to 72 out of a max of 114
[08/31 14:19:25]  Verifer returned sat in 23.121045 secs.
[08/31 14:19:25]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t    cwnd_0,t   service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   10394.512939   10394.512301  2753.005615  10394.512939  200.000488  10394.512301   0.000000   0.000639      -99.999121       1.0         10394.512301                -1.0            -1      True
1   10594.512301   10494.512451  2753.005615  10594.512301  200.000000  10494.512451   0.000000  99.999849        0.000240       1.0         10594.512301                 0.0         False      True
2   10594.512301   10594.512301  2853.003418  10594.512301    0.002812  10594.512301   0.000000   0.000000       -0.001957       2.0         10594.512301                 0.0         False      True
3   10594.515113   10594.514488  2953.002563  10594.515113    0.002812  10594.514488   0.000000   0.000625        0.000000       1.0         10594.512301                 1.0         False     False
4   10694.516988   10694.515113  2953.002563  10694.516988  100.002500  10694.515113   0.000625   0.001250        0.001250       1.0         10594.512301                 0.0         False     False
5   10744.516988   10744.515738  3003.001221  10744.516988   50.001250  10744.515738   0.000625   0.000625       -0.000092       1.0         10744.516363                 0.0         False      True
6   10744.526363   10744.516988  3102.991699  10744.526363    0.010000  10744.516988   0.000625   0.008750       -0.000239       1.0         10744.525738                 0.0         False      True
7   10744.527613   10744.526363  3202.990479  10744.527613    0.010000  10744.526363   0.000625   0.000625       -0.000209       1.0         10744.525738                 0.0         False      True
8   10744.536988   10744.535156  3302.981201  10744.536988    0.010000  10744.535156   0.000625   0.001207       -0.000112       1.0         10744.525738                 0.0         False      True
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=True, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=1, loss_amount=0, 
, buffer=1/800.[0m
[08/31 14:19:25]  --------------------------------------------------------------------------------
[08/31 14:19:25]  Iteration: 76 (0 solution, 75 counterexamples)
[08/31 14:19:35]  Generator returned sat in 7.347616 secs.
[08/31 14:19:35]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:19:36]  Improved number of small numbers from 99 to 113 out of a max of 113
[08/31 14:19:36]  Verifer returned sat in 0.484724 secs.
[08/31 14:19:36]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t    cwnd_0,t   service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   10144.435303   10044.535156  3202.982666  10144.435303  100.299805  10044.535156    0.00000   99.900146       99.900146       1.0         10044.535156                -1.0            -1      True
1   10144.735107   10144.535156  3202.982666  10144.735107  100.199951  10144.535156    0.00000    0.199951        0.199951       1.0         10144.735107                 0.0         False      True
2   10144.735107   10144.535156  3202.982666  10144.735107    0.099854  10144.535156    0.00000    0.199951      -99.800049       1.0         10144.735107                 0.0         False      True
3   10269.535156   10269.435303  3202.982666  10269.535156  125.000000  10269.435303    0.00000    0.099854      -75.000000       1.0         10144.735107                 0.0         False      True
4   10519.435303   10344.535156  3202.982666  10519.435303  250.000000  10344.535156    0.00000  174.900146       74.900146       1.0         10144.735107                 0.0         False      True
5   10844.535156   10511.201660  3202.982666  10844.535156  500.000000  10511.201660    0.00000  333.333496      300.000000       2.0         10144.735107                 0.0         False      True
6   10944.534912   10641.724121  3202.982666  10944.534912  433.333252  10641.724121    0.00000  302.810791      299.999756       2.0         10944.534912                 1.0          True     False
7   11044.535156   10744.535156  3202.982666  11044.535156  402.811035  10744.535156    0.00000  300.000000      300.000000       3.0         11044.535156                 1.0         False     False
8   11145.940674   10744.535156  3202.982666  11145.940674  401.405518  10744.535156    1.30542  400.100098      300.100098       3.0         11144.635254                 1.0         False     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=5347/4096, 
, buffer=614605/2048.[0m
[08/31 14:19:36]  --------------------------------------------------------------------------------
[08/31 14:19:36]  Iteration: 77 (0 solution, 76 counterexamples)
[08/31 14:19:41]  Generator returned sat in 2.714456 secs.
[08/31 14:19:41]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:19:42]  Improved gap from 0.000625 to 100
[08/31 14:19:43]  Improved number of small numbers from 84 to 93 out of a max of 114
[08/31 14:19:43]  Verifer returned sat in 1.002432 secs.
[08/31 14:19:43]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t    cwnd_0,t   service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0   10044.734375   10044.733643  3602.782471  10044.734375  100.001875  10044.733643    0.000000    0.000732       -0.000732       3.0         10044.733643                -1.0            -1       -1
1   10144.734863   10044.735107  3602.782471  10144.734863  100.001221  10044.735107    0.000000   99.999756       -0.000244       1.0         10144.734863                 1.0         False    False
2   10144.736328   10144.735107  3602.782471  10144.736328  100.001221  10144.735107    0.000000    0.001221      -99.998779       1.0         10144.734863                 0.0         False    False
3   10344.736982   10344.735107  3602.782471  10344.736982  200.001875  10344.735107    0.000625    0.001250        0.001250       1.0         10144.734863                 0.0         False    False
4   10344.745732   10344.739482  3602.782471  10344.745732    0.010000  10344.739482    0.000625    0.005625      -99.990000       1.0         10344.745107                 0.0         False     True
5   10644.744482   10544.735107  3602.782471  10644.744482  300.004375  10544.735107  100.008125    0.001250        0.001250       1.0         10344.745107                 0.0         False     True
6   10644.753232   10544.735107  3602.782471  10644.753232    0.010000  10544.735107  100.008125    0.010000      -99.990000       1.0         10544.745107                 0.0         False     True
7   10844.743232   10744.734482  3602.782471  10844.743232  200.000000  10744.734482  100.008125    0.000625        0.000000       1.0         10544.745107                 0.0         False     True
8   11244.737607   10744.735596  3602.782471  11244.737607  399.995000  10744.735596  400.001250  100.000762        0.001250       1.0         10544.745107                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=640001/1600, 
, buffer=1/800.[0m
[08/31 14:19:43]  --------------------------------------------------------------------------------
[08/31 14:19:43]  Iteration: 78 (0 solution, 77 counterexamples)
[08/31 14:19:47]  Generator returned sat in 1.447807 secs.
[08/31 14:19:47]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:19:49]  Improved number of small numbers from 67 to 71 out of a max of 113
[08/31 14:19:49]  Verifer returned sat in 2.064530 secs.
[08/31 14:19:49]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t    cwnd_0,t   service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    9542.077881    9541.978024  3602.782471   9542.077881  200.008333   9541.978024       0.05    0.049857       -0.008477       8.0          9541.978024                -1.0            -1       -1
1    9742.036357    9542.178024  3602.782471   9742.036357  200.008333   9542.178024       0.05  199.808333       99.950000       1.0          9541.978024                 1.0         False     True
2    9742.186357    9742.036357  3602.782471   9742.186357  199.958333   9742.036357       0.05    0.100000        0.100000       1.0          9742.136357                 0.0         False     True
3    9742.186357    9742.036357  3602.782471   9742.186357    0.050000   9742.036357       0.05    0.100000      -99.900000       1.0          9742.136357                 0.0         False     True
4    9942.169691    9842.036357  3602.782471   9942.169691  200.083333   9842.036357       0.05  100.083333        0.083333       1.0          9742.136357                 0.0         False     True
5   10241.986357    9943.136357  3602.782471  10241.986357  399.900000   9943.136357       0.05  298.800000      199.900000       1.0          9742.136357                 0.0         False     True
6   10344.236357   10141.686357  3602.782471  10344.236357  401.050000  10141.686357       0.05  202.500000      202.150000       2.0          9742.136357                 0.0         False     True
7   10542.086357   10241.986357  3602.782471  10542.086357  400.350000  10241.986357       0.05  300.050000      300.000000       2.0         10542.036357                 1.0          True    False
8   10642.186357   10242.036377  3602.782471  10642.186357  400.150000  10242.036377       0.10  400.049980      300.050000       3.0         10642.086357                 1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=1, loss_amount=1/20, 
, buffer=6001/20.[0m
[08/31 14:19:50]  --------------------------------------------------------------------------------
[08/31 14:19:50]  Iteration: 79 (0 solution, 78 counterexamples)
[08/31 14:20:01]  Generator returned sat in 8.255027 secs.
[08/31 14:20:01]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:20:02]  Improved gap from 0.0025 to 100
[08/31 14:20:03]  Improved number of small numbers from 57 to 63 out of a max of 114
[08/31 14:20:03]  Verifer returned sat in 1.922681 secs.
[08/31 14:20:03]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t    cwnd_0,t   service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    9542.073730    9542.023252  3602.782471   9542.073730    0.000732   9542.023252    0.049805    0.000674       -0.000576       7.0          9542.023252                -1.0            -1       -1
1    9542.074932    9542.024502  3602.782471   9542.074932    0.001875   9542.024502    0.049805    0.000625      -99.999375       1.0          9542.023252                 1.0         False    False
2    9842.088057    9642.024658  3602.782471   9842.088057  300.013750   9642.024658    0.049805  200.013594      100.013750       1.0          9542.023252                 0.0         False    False
3    9842.088057    9742.035127  3602.782471   9842.088057  200.013125   9742.035127    0.049805  100.003125        0.013750       2.0          9842.038252                 0.0         False    False
4    9942.097432    9942.024502  3602.782471   9942.097432  200.012500   9942.024502    0.049805    0.023125        0.023125       1.0          9942.047627                 1.0         False    False
5   10242.080557   10042.024502  3602.782471  10242.080557  300.006250  10042.024502  100.041680  100.014375      100.014375       1.0          9942.047627                 0.0         False    False
6   10242.080557   10042.024502  3602.782471  10242.080557    0.010000  10042.024502  100.041680  100.014375        0.014375       1.0         10142.038877                 0.0         False     True
7   10442.065557   10242.024502  3602.782471  10442.065557  299.999375  10242.024502  100.041680   99.999375       99.999375       1.0         10142.038877                 0.0         False     True
8   10942.065557   10342.024414  3602.782471  10942.065557  599.999375  10342.024414  500.026680  100.014463      100.014375       1.0         10142.038877                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=2, loss_amount=799963/1600, 
, buffer=160023/1600.[0m
[08/31 14:20:03]  --------------------------------------------------------------------------------
[08/31 14:20:03]  Iteration: 80 (0 solution, 79 counterexamples)
[08/31 14:20:15]  Generator returned sat in 9.286478 secs.
[08/31 14:20:15]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:20:15]  Improved gap from 0.1 to 100
[08/31 14:20:16]  Improved number of small numbers from 68 to 114 out of a max of 114
[08/31 14:20:16]  Verifer returned sat in 0.423902 secs.
[08/31 14:20:16]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t     cwnd_0,t   service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   10216.799072   10116.849609  3602.782471  10216.799072     0.099854  10116.849609   0.049561   99.899902       99.899902       1.0         10116.849609                -1.0            -1      True
1   10216.799316   10116.849609  3602.782471  10216.799316    99.900146  10116.849609   0.049561   99.900146       -0.099854       1.0         10116.849609                 0.0         False      True
2   10416.799072   10216.849609  3602.782471  10416.799072   299.899902  10216.849609   0.049561  199.899902       99.899902       1.0         10116.849609                 0.0         False      True
3   10416.899170   10316.849609  3602.782471  10416.899170   200.000000  10316.849609   0.049561  100.000000        0.000000       2.0         10416.849609                 0.0         False      True
4   10616.899170   10416.949707  3602.782471  10616.899170   300.000000  10416.949707   0.049561  199.899902      100.000000       1.0         10416.849609                 0.0         False      True
5   10866.999268   10616.849609  3602.782471  10866.999268   450.000000  10616.849609   0.049561  250.100098      250.100098       2.0         10416.849609                 0.0         False      True
6   11291.899170   10616.849609  3602.782471  11291.899170   675.000000  10616.849609   0.049561  675.000000      575.000000       2.0         10416.849609                 0.0         False      True
7   11629.399170   10816.849609  3602.782471  11629.399170  1012.500000  10816.849609   0.049561  812.500000      812.500000       3.0         10416.849609                 0.0         False      True
8   11629.399170   10867.049316  3602.782471  11629.399170   399.899902  10867.049316   0.049561  762.300293      712.500000       3.0         11629.349609                 1.0          True     False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=0, loss_amount=0, 
, buffer=3328409/4096.[0m
[08/31 14:20:16]  --------------------------------------------------------------------------------
[08/31 14:20:16]  Iteration: 81 (0 solution, 80 counterexamples)
[08/31 14:20:21]  Generator returned sat in 1.784859 secs.
[08/31 14:20:21]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:20:23]  Improved gap from 50.023125 to 100
[08/31 14:20:24]  Improved number of small numbers from 99 to 99 out of a max of 114
[08/31 14:20:24]  Verifer returned sat in 2.822345 secs.
[08/31 14:20:24]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t   cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0    10491.64917    10291.64917  3602.782471  10491.64917    0.05000  10291.64917       0.05  199.95000          99.950       3.0          10291.64917                -1.0            -1       -1
1    10591.52417    10491.64917  3602.782471  10591.52417  299.82500  10491.64917       0.05   99.82500          99.825       1.0          10291.64917                 1.0         False     True
2    10691.54917    10591.52417  3602.782471  10691.54917  199.85000  10591.52417       0.05   99.97500          99.850       1.0          10691.49917                 0.0         False     True
3    10691.64917    10691.54917  3602.782471  10691.64917  100.07500  10691.54917       0.05    0.05000          -0.050       1.0          10691.59917                 0.0         False     True
4    11091.69917    10691.64917  3602.782471  11091.69917  400.10000  10691.64917       0.05  400.00000         300.000       1.0          10691.59917                 0.0         False     True
5    11591.89917    10891.64917  3602.782471  11591.89917  900.20000  10891.64917       0.05  700.20000         700.200       2.0          10691.59917                 0.0         False     True
6    11591.89917    10991.64917  3602.782471  11591.89917  600.16250  10991.64917       0.05  600.20000         600.200       3.0          11591.84917                 1.0          True    False
7    11591.89917    11041.71792  3602.782471  11591.89917  450.13125  11041.71792       0.05  550.13125         500.200       4.0          11591.84917                 1.0         False    False
8    11591.89917    11091.64917  3602.782471  11591.89917  400.10000  11091.64917       0.05  500.20000         400.200       5.0          11591.84917                 1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=0, loss_amount=0, 
, buffer=2801/4.[0m
[08/31 14:20:24]  --------------------------------------------------------------------------------
[08/31 14:20:24]  Iteration: 82 (0 solution, 81 counterexamples)
[08/31 14:20:30]  Generator returned sat in 2.990726 secs.
[08/31 14:20:30]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:20:31]  Improved gap from 0.1 to 100
[08/31 14:20:32]  Improved number of small numbers from 60 to 64 out of a max of 114
[08/31 14:20:32]  Verifer returned sat in 1.857204 secs.
[08/31 14:20:32]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t    cwnd_0,t   service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0   10739.819092   10639.918926  3254.512715  10739.819092    0.100000  10639.918926    0.000000   99.900166       -0.099834       3.0         10639.918926                -1.0            -1       -1
1   10840.218926   10739.918926  3254.512715  10840.218926  200.300000  10739.918926    0.100000  100.200000        0.200000       1.0         10639.918926                 1.0         False    False
2   10940.018926   10840.318926  3254.512715  10940.018926  200.000000  10840.318926    0.100000   99.600000        0.000000       1.0         10939.918926                 0.0         False     True
3   11040.318926   11039.918926  3254.512715  11040.318926  199.900000  11039.918926    0.200000    0.200000        0.200000       1.0         11040.118926                 0.0         False     True
4   11140.068926   11113.765592  3254.512715  11140.068926   99.950000  11113.765592    0.200000   26.103333       -0.050000       1.0         11139.868926                 0.0         False     True
5   11400.838926   11196.482259  3254.512715  11400.838926  286.873333  11196.482259  160.720000   43.636667        0.200000       1.0         11139.868926                 0.0         False     True
6   11500.638926   11339.818926  3254.512715  11500.638926  143.436667  11339.818926  160.720000    0.100000        0.000000       1.0         11339.918926                 0.0         False     True
7   11793.925592   11439.918926  3254.512715  11793.925592  293.386667  11439.918926  353.806667    0.200000        0.200000       1.0         11339.918926                 0.0         False     True
8   11940.418926   11440.218750  3254.512715  11940.418926  146.693333  11440.218750  400.300000   99.900176        0.200000       1.0         11540.118926                 0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=False, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=3, loss_amount=4001/10, 
, buffer=1/5.[0m
[08/31 14:20:32]  --------------------------------------------------------------------------------
[08/31 14:20:32]  Iteration: 83 (0 solution, 82 counterexamples)
[08/31 14:20:36]  Generator returned sat in 1.568172 secs.
[08/31 14:20:37]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:20:40]  Improved number of small numbers from 58 to 113 out of a max of 113
[08/31 14:20:40]  Verifer returned sat in 2.984735 secs.
[08/31 14:20:40]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t    cwnd_0,t   service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease v.mode_f
0   10989.958740   10989.883789  3254.512695  10989.958740    0.025146  10989.883789   0.025146    0.049805        0.049805       1.0         10989.883789                -1.0            -1       -1
1   10989.958740   10989.883789  3254.512695  10989.958740    0.025146  10989.883789   0.025146    0.049805      -99.950195       1.0         10989.883789                 0.0         False     True
2   11189.883789   11089.883789  3254.512695  11189.883789  199.974854  11089.883789   0.025146   99.974854       -0.025146       1.0         10989.883789                 0.0         False     True
3   11289.858887   11189.883789  3254.512695  11289.858887  199.949951  11189.883789   0.025146   99.949951       -0.050049       1.0         11289.833740                 0.0         False     True
4   11489.858887   11348.883789  3254.512695  11489.858887  299.949951  11348.883789   0.025146  140.949951       99.949951       1.0         11289.833740                 0.0         False     True
5   11828.358887   11410.683838  3254.512695  11828.358887  479.449951  11410.683838   0.025146  417.649902      338.449951       2.0         11289.833740                 0.0         False     True
6   11828.358887   11589.858887  3254.512695  11828.358887  400.125000  11589.858887   0.025146  238.474854      238.449951       2.0         11828.333740                 1.0          True    False
7   11989.934082   11589.884033  3254.512695  11989.934082  400.050049  11589.884033   0.025146  400.024902      300.025146       3.0         11989.908936                 1.0         False    False
8   11989.934082   11789.883789  3254.512695  11989.934082  320.525146  11789.883789   0.025146  200.025146      200.025146       4.0         11989.908936                 1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=True, ramp_down_cwnd=False, 
, ramp_up_bq=False, ramp_down_bq=False, ramp_up_queue=False, ramp_down_queue=False, loss_count=0, loss_amount=0, 
, buffer=1386393/4096.[0m
[08/31 14:20:40]  --------------------------------------------------------------------------------
[08/31 14:20:40]  Iteration: 84 (0 solution, 83 counterexamples)
[08/31 14:20:47]  Generator returned sat in 4.637241 secs.
[08/31 14:20:48]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/31 14:20:55]  Improved gap from 0.0 to 23.4375
[08/31 14:20:55]  Improved number of small numbers from 82 to 114 out of a max of 114
[08/31 14:20:55]  Verifer returned sat in 7.148072 secs.
[08/31 14:20:55]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t    cwnd_0,t   service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay_t  last_decrease_f_0,t  exceed_queue_f_0,t this_decrease  v.mode_f
0   11395.333740   11395.133789  2849.262451  11395.333740    0.099854  11395.133789   0.000000   0.199951        0.199951       1.0         11395.133789                -1.0            -1     False
1   11395.333740   11395.133789  2925.824951  11395.333740    0.100098  11395.133789   0.000000   0.199951      -23.237549       1.0         11395.133789                 0.0         False     False
2   11518.871338   11518.571289  2925.824951  11518.871338  123.737549  11518.571289   0.100098   0.199951        0.199951       1.0         11395.133789                 0.0         False     False
3   11542.208984   11518.871094  3002.087646  11542.208984   23.537598  11518.871094   0.100098  23.237793       -0.199707       1.0         11542.108887                 0.0         False      True
4   11542.508789   11542.308594  3078.650146  11542.508789   23.537598  11542.308594   0.100098   0.100098      -23.337402       1.0         11542.108887                 0.0         False      True
5   11565.946289   11565.746094  3155.212646  11565.946289   23.537598  11565.746094   0.100098   0.100098      -23.337402       1.0         11542.108887                 0.0         False      True
6   11589.383789   11589.183594  3231.775146  11589.383789   23.537598  11589.183594   0.100098   0.100098      -23.337402       1.0         11542.108887                 0.0         False      True
7   11612.821289   11612.621094  3308.237793  11612.821289   23.537598  11612.621094   0.100098   0.100098      -23.437256       1.0         11542.108887                 0.0         False      True
8   11636.258789   11636.158691  3308.237793  11636.258789   23.537598  11636.158691   0.100098   0.000000      -99.999756       1.0         11542.108887                 0.0         False      True
fefficient=False, bounded_queue=True, bounded_loss_count=True, bounded_loss_amount=True, ramp_up_cwnd=False, ramp_down_cwnd=False, 
, ramp_up_bq=True, ramp_down_bq=True, ramp_up_queue=True, ramp_down_queue=True, loss_count=0, loss_amount=0, 
, buffer=819/4096.[0m
[08/31 14:20:55]  --------------------------------------------------------------------------------
[08/31 14:20:55]  Iteration: 85 (0 solution, 84 counterexamples)
[08/31 14:20:58]  Generator returned unsat in 0.164371 secs.
[08/31 14:20:58]  [96mNo more solutions found[0m
[08/31 14:20:58]  Final solutions:
[08/31 14:20:58]  Took 723.381973 secs.
