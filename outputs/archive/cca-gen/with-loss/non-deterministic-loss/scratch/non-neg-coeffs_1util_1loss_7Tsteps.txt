[07/13 21:16:06]  --------------------------------------------------------------------------------
[07/13 21:16:06]  Iteration: 1
[07/13 21:16:06]  Generator returned sat in 0.004401 secs.
[07/13 21:16:06]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:16:06]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:06]  Verifer returned sat in 0.109636 secs.
[07/13 21:16:06]  Counter example:
   arrival_0,t  cwnd_0,t  service_0,t  wasted_t  losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0          0.0       0.1       -100.1     100.1        0.0                0.0    100.1           100.1
1          0.0     100.1       -100.1     100.1        0.0                0.0    100.1             0.1
2        299.9     400.0         -0.1     100.1        0.0                0.0    300.0           200.0
3        299.9       0.1         99.9     100.1        0.0                0.0    200.0           100.0
4        702.1     402.2        209.9     100.1      302.2              302.2    190.0           100.0
5       2128.5    1426.4        299.9     100.1     1528.6             1528.6    300.0           200.0
6       5583.3    3454.8        399.9     100.1     4883.4             4883.4    300.0           200.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:06]  --------------------------------------------------------------------------------
[07/13 21:16:06]  Iteration: 2
[07/13 21:16:06]  Generator returned sat in 0.012568 secs.
[07/13 21:16:06]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:16:06]  Improved number of small numbers from 67 to 71 out of a max of 79
[07/13 21:16:06]  Verifer returned sat in 0.174880 secs.
[07/13 21:16:06]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    99.899658    0.099854  -100.100098  100.099854   0.000000           0.000000  199.999756      199.999756
1   199.899902  300.000000  -100.100098  100.099854   0.000000           0.000000  300.000000      200.000000
2   199.902344  300.002441     3.917402  100.099854   0.000000           0.000000  195.984941      100.002441
3   199.902344   48.000000   199.899902  100.099854   0.000000           0.000000    0.002441        0.002441
4   399.901152  200.000000   199.899902  100.099854   0.001250           0.001250  200.000000      100.000000
5   399.901152    0.010000   399.899902  100.099854   0.001250           0.001250    0.000000        0.000000
6   599.902402  200.001250   399.899902  100.099854   0.002441           0.002441  200.000059      100.000059
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:07]  --------------------------------------------------------------------------------
[07/13 21:16:07]  Iteration: 3
[07/13 21:16:07]  Generator returned sat in 0.009021 secs.
[07/13 21:16:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:07]  Improved gap from 1/800 to 100
[07/13 21:16:07]  Improved number of small numbers from 66 to 76 out of a max of 80
[07/13 21:16:07]  Verifer returned sat in 0.223906 secs.
[07/13 21:16:07]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    -0.100098    0.099609  -100.100342  100.099854   0.000000           0.000000  100.000244      100.000244
1    -0.100098   99.999756  -100.100098  100.099854   0.000000           0.000000  100.000000        0.000244
2   249.901611  300.002441     2.912402  100.099854  49.999268          49.999268  196.989941      100.002686
3   249.901611   48.500000   199.899658  100.099854  49.999268          49.999268    0.002686        0.002686
4   449.900391  200.000000   199.899902  100.099854  50.000732          50.000732  199.999756      100.000000
5   449.900391    0.010000   399.897402  100.099854  50.000732          50.000732    0.002256        0.000000
6   649.901611  200.002500   399.899902  100.099854  50.001709          50.001709  200.000000      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:07]  --------------------------------------------------------------------------------
[07/13 21:16:07]  Iteration: 4
[07/13 21:16:07]  Generator returned sat in 0.008953 secs.
[07/13 21:16:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:07]  Improved gap from 1245169/12800 to 100
[07/13 21:16:07]  Improved number of small numbers from 51 to 80 out of a max of 80
[07/13 21:16:07]  Verifer returned sat in 0.157094 secs.
[07/13 21:16:07]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   135.119873    0.099365    35.069824  100.099609    0.000000           0.000000  100.050049      100.049805
1   135.119873    0.049805   135.070068  100.099609    0.000000           0.000000    0.049805        0.049805
2   135.119873    0.049805   135.070068  100.099609    0.000000           0.000000    0.049805      -99.950195
3   720.119873  585.000000   241.070068  100.099609  285.049561         285.049561  194.000244      100.000244
4  1014.069824  294.000000   335.070068  100.099609  478.999756         478.999756  200.000000      100.000000
5  1014.069824  148.500000   435.070068  100.099609  478.999756         478.999756  100.000000        0.000000
6  1214.119629  300.000000   535.070068  100.099609  479.049561         479.049561  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:08]  --------------------------------------------------------------------------------
[07/13 21:16:08]  Iteration: 5
[07/13 21:16:08]  Generator returned sat in 0.022859 secs.
[07/13 21:16:08]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:08]  Improved gap from 407/8192 to 100
[07/13 21:16:08]  Improved number of small numbers from 32 to 80 out of a max of 80
[07/13 21:16:08]  Verifer returned sat in 0.214780 secs.
[07/13 21:16:08]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   396.234375    0.099121   391.734375 -261.014893   0.000000           0.000000    4.500000        0.050049
1   396.234375    0.024902   396.209473 -261.014893   0.000000           0.000000    0.024902      -99.949951
2   691.783936  295.574463   496.184326 -261.014893   0.000000           0.000000  195.599609       95.599609
3   691.783936   35.333333   691.734375 -261.014893   0.000000           0.000000    0.049561       -4.400391
4   896.259033  204.500000   696.184570 -261.014893   0.024658           0.024658  200.049805      100.050049
5   896.259033    2.000000   896.184326 -261.014893   0.024658           0.024658    0.050049        0.050049
6  1100.734131  204.500000   896.184326 -261.014893   0.049805           0.049805  204.500000      104.500000
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:08]  --------------------------------------------------------------------------------
[07/13 21:16:08]  Iteration: 6
[07/13 21:16:08]  Generator returned sat in 0.006313 secs.
[07/13 21:16:08]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:08]  Improved number of small numbers from 67 to 79 out of a max of 79
[07/13 21:16:08]  Verifer returned sat in 0.138045 secs.
[07/13 21:16:08]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   396.234131    0.099121   391.734375 -261.014893   0.000000           0.000000    4.499756        0.050049
1   396.234131    0.024902   396.209473 -261.014893   0.000000           0.000000    0.024658      -99.949951
2   692.458984  296.249512   496.184082 -261.014893   0.000000           0.000000  196.274902       96.274902
3   692.458984   34.595703   692.446777 -261.014893   0.000000           0.000000    0.012207       -3.725098
4   896.202881  203.749756   696.184326 -261.014893   0.006348           0.006348  200.012207      100.012451
5   896.202881    1.500000   896.184082 -261.014893   0.006348           0.006348    0.012451        0.012451
6  1099.946533  203.750000   896.184326 -261.014893   0.012451           0.012451  203.749756      103.750000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:08]  --------------------------------------------------------------------------------
[07/13 21:16:08]  Iteration: 7
[07/13 21:16:08]  Generator returned sat in 0.010949 secs.
[07/13 21:16:08]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:09]  Improved number of small numbers from 63 to 79 out of a max of 79
[07/13 21:16:09]  Verifer returned sat in 0.115591 secs.
[07/13 21:16:09]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   396.233887    0.099121   296.184082 -261.014893   0.000000           0.000000  100.049805        0.049805
1   396.233887    0.024658   396.209229 -261.014893   0.000000           0.000000    0.024658      -99.950195
2   696.190186  299.980957   496.184082 -261.014893   0.000000           0.000000  200.006104      100.006104
3   696.190186   34.595459   696.184082 -261.014893   0.000000           0.000000    0.006104        0.006104
4   897.687012  201.500000   696.184326 -261.014893   0.002930           0.002930  201.499756      101.500000
5   897.687012    1.500000   896.184082 -261.014893   0.002930           0.002930    1.500000        1.500000
6  1097.696533  201.500000   896.184326 -261.014893   0.012451           0.012451  201.499756      101.500000
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:09]  --------------------------------------------------------------------------------
[07/13 21:16:09]  Iteration: 8
[07/13 21:16:09]  Generator returned sat in 0.008372 secs.
[07/13 21:16:09]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:09]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:09]  Verifer returned sat in 0.101161 secs.
[07/13 21:16:09]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   396.233887    0.099121   296.187012 -261.014893   0.000000           0.000000  100.046875        0.049805
1   396.233887    0.024658   396.209229 -261.014893   0.000000           0.000000    0.024658      -99.950195
2   696.190186  299.980957   496.184082 -261.014893   0.000000           0.000000  200.006104      100.006104
3   696.190186    0.000732   696.184082 -261.014893   0.000000           0.000000    0.006104        0.006104
4   897.687012  201.500000   696.184326 -261.014893   0.002930           0.002930  201.499756      101.500000
5   897.687012    1.500000   896.184082 -261.014893   0.002930           0.002930    1.500000        1.500000
6  1100.687744  204.500000   896.184326 -261.014893   0.003662           0.003662  204.499756      104.500000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:09]  --------------------------------------------------------------------------------
[07/13 21:16:09]  Iteration: 9
[07/13 21:16:09]  Generator returned sat in 0.008912 secs.
[07/13 21:16:09]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:09]  Improved number of small numbers from 77 to 77 out of a max of 79
[07/13 21:16:09]  Verifer returned sat in 0.113771 secs.
[07/13 21:16:09]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   396.233643    0.098877   296.187012 -261.015137   0.000000           0.000000  100.046631        0.049561
1   396.233643    0.024414   396.209229 -261.015137   0.000000           0.000000    0.024414      -99.950439
2   696.189941  299.980713   496.184082 -261.015137   0.000000           0.000000  200.005859      100.005859
3   696.189941    0.000732   696.184082 -261.015137   0.000000           0.000000    0.005859        0.005859
4   897.686768  201.500000   696.184326 -261.015137   0.002686           0.002686  201.499756      101.500000
5   897.686768  102.250000   825.517415 -261.015137   0.002686           0.002686   72.166667        1.500000
6  1196.187500  370.666667   896.184326 -261.015137   0.003418           0.003418  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:10]  --------------------------------------------------------------------------------
[07/13 21:16:10]  Iteration: 10
[07/13 21:16:10]  Generator returned sat in 0.034959 secs.
[07/13 21:16:10]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:10]  Improved gap from 201/8192 to 100
[07/13 21:16:10]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:16:10]  Verifer returned sat in 0.122472 secs.
[07/13 21:16:10]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   396.233398    0.098633   296.233398 -161.064697    0.000000           0.000000  100.000000      100.000000
1   396.233398    0.049072   396.184326 -161.064697    0.000000           0.000000    0.049072        0.000000
2   696.233398  300.049072   496.233398 -161.064697    0.000000           0.000000  200.000000      200.000000
3   697.831543  201.549072   496.233398 -161.064697    0.049072           0.049072  201.549072      101.549072
4   697.831543  201.500000   596.233398 -161.064697    0.049072           0.049072  101.549072        1.549072
5  1401.679688  703.848145   795.483398 -161.064697  405.446289         405.446289  200.750000      200.000000
6  1501.728760  300.750000   796.233398 -161.064697  405.495361         405.495361  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:10]  --------------------------------------------------------------------------------
[07/13 21:16:10]  Iteration: 11
[07/13 21:16:10]  Generator returned sat in 0.016685 secs.
[07/13 21:16:10]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:10]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:10]  Verifer returned sat in 0.109921 secs.
[07/13 21:16:10]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   300.757812    0.098633   100.757812 -161.064941    0.000000           0.000000  200.000000      100.000000
1   300.757812    0.048828   300.708740 -161.064941    0.000000           0.000000    0.049072        0.000000
2   600.757812  300.049072   303.757812 -161.064941    0.000000           0.000000  297.000000      200.000000
3   697.831299  394.024414   497.757812 -161.064941    0.049072           0.049072  200.024414      197.024414
4   697.831299  200.000000   501.882812 -161.064941    0.049072           0.049072  195.899414       97.024414
5  1401.679443  703.848145   700.757812 -161.064941  500.921631         500.921631  200.000000      200.000000
6  1401.703857  200.000000   700.757812 -161.064941  500.946045         500.946045  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:10]  --------------------------------------------------------------------------------
[07/13 21:16:10]  Iteration: 12
[07/13 21:16:11]  Generator returned sat in 0.011846 secs.
[07/13 21:16:11]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:11]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:11]  Verifer returned sat in 0.135008 secs.
[07/13 21:16:11]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   300.770020    0.098389   100.757812 -161.065186    0.000000           0.000000  200.012207      100.012207
1   300.770020    0.048828   300.757812 -161.065186    0.000000           0.000000    0.012207        0.012207
2   600.757568  299.999756   300.757812 -161.065186    0.000000           0.000000  299.999756      199.999756
3   697.831299  397.024414   497.757812 -161.065186    0.049072           0.049072  200.024414      197.024414
4   697.831299  200.000000   501.882568 -161.065186    0.049072           0.049072  195.899658       97.024414
5  1101.580811  403.749512   699.757812 -161.065186  300.822998         300.822998  101.000000      100.000000
6  1201.593018  201.000000   700.757812 -161.065186  300.835205         300.835205  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:11]  --------------------------------------------------------------------------------
[07/13 21:16:11]  Iteration: 13
[07/13 21:16:11]  Generator returned sat in 0.079101 secs.
[07/13 21:16:11]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:11]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:11]  Verifer returned sat in 0.113040 secs.
[07/13 21:16:11]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t   wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   300.770020    0.098389    99.306396 -161.06543    0.000000           0.000000  201.463623      102.988037
1   300.770020    0.048828   297.781982 -161.06543    0.000000           0.000000    2.988037        2.988037
2   597.831055  300.000000   397.781982 -161.06543    0.049072           0.049072  200.000000      200.000000
3   697.831055  300.000000   397.781982 -161.06543    0.049072           0.049072  300.000000      200.000000
4   697.831055  299.975586   594.281982 -161.06543    0.049072           0.049072  103.500000      100.000000
5   995.831055  298.000000   597.781982 -161.06543  198.049072         198.049072  200.000000      100.000000
6  1395.806641  400.000000   700.757812 -161.06543  398.024658         398.024658  297.024170      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:11]  --------------------------------------------------------------------------------
[07/13 21:16:11]  Iteration: 14
[07/13 21:16:12]  Generator returned sat in 0.020903 secs.
[07/13 21:16:12]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:12]  Improved gap from 25/2048 to 100
[07/13 21:16:12]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:16:12]  Verifer returned sat in 0.120252 secs.
[07/13 21:16:12]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   297.781982    0.098389   197.781982 -161.065674     0.000000           0.000000  100.000000      100.000000
1   297.781982    0.048828   197.781982 -161.065674     0.000000           0.000000  100.000000        0.000000
2   297.806396  100.024414   297.781982 -161.065674     0.000000           0.000000    0.024414      -99.975586
3   597.794189  300.000000   397.781982 -161.065674     0.012207           0.012207  200.000000      100.000000
4   999.794189  402.000000   597.781982 -161.065674   202.012207         202.012207  200.000000      200.000000
5  1603.794189  604.000000   597.781982 -161.065674   806.012207         806.012207  200.000000      100.000000
6  2359.794189  756.000000   697.781982 -161.065674  1362.012207        1362.012207  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:12]  --------------------------------------------------------------------------------
[07/13 21:16:12]  Iteration: 15
[07/13 21:16:12]  Generator returned sat in 0.016787 secs.
[07/13 21:16:12]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:12]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:12]  Verifer returned sat in 0.093954 secs.
[07/13 21:16:12]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   297.781738    0.098389   196.781738 -161.065674     0.000000           0.000000  101.000000      100.000000
1   297.781738    0.048584   197.781738 -161.065674     0.000000           0.000000  100.000000        0.000000
2   297.806152  100.024414   297.781738 -161.065674     0.000000           0.000000    0.024414      -99.975586
3   597.793945  300.000000   397.781738 -161.065674     0.012207           0.012207  200.000000      100.000000
4   999.793945  402.000000   597.781738 -161.065674   202.012207         202.012207  200.000000      200.000000
5  1603.293945  603.500000   597.781738 -161.065674   805.512207         805.512207  200.000000      100.000000
6  2358.293945  755.000000   697.781982 -161.065674  1360.512207        1360.512207  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:12]  --------------------------------------------------------------------------------
[07/13 21:16:12]  Iteration: 16
[07/13 21:16:13]  Generator returned sat in 0.031237 secs.
[07/13 21:16:13]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:13]  Improved gap from 97 to 100
[07/13 21:16:13]  Improved number of small numbers from 73 to 80 out of a max of 80
[07/13 21:16:13]  Verifer returned sat in 0.135113 secs.
[07/13 21:16:13]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   297.732910    0.098145   100.877930 -161.065674    0.000000           0.000000  196.854980      100.000000
1   297.732910    0.048096   200.732910 -161.065674    0.000000           0.000000   97.000000        0.000000
2   299.865967   99.133057   297.732910 -161.065674    0.000000           0.000000    2.133057      -97.866943
3   599.793457  300.000000   397.781250 -161.065674    2.060547           2.060547  199.951660      100.000000
4   899.745117  299.951660   597.732910 -161.065674  202.012207         202.012207  100.000000      100.000000
5  1249.720947  349.975830   597.781494 -161.065674  451.987793         451.987793  199.951660      100.000244
6  1576.233154  326.512207   697.781738 -161.065674  678.500000         678.500000  199.951416      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:13]  --------------------------------------------------------------------------------
[07/13 21:16:13]  Iteration: 17
[07/13 21:16:13]  Generator returned sat in 0.028096 secs.
[07/13 21:16:13]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:13]  Improved gap from 25/1024 to 100
[07/13 21:16:13]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:16:13]  Verifer returned sat in 0.126377 secs.
[07/13 21:16:13]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   297.732910     0.098145   197.732910 -161.065674     0.000000           0.000000  100.000000      100.000000
1   297.732910     0.024414   297.708496 -161.065674     0.000000           0.000000    0.024414        0.000000
2   297.781738     0.073242   297.732910 -161.065674     0.000000           0.000000    0.048828      -99.951172
3   597.757324   300.000000   397.732910 -161.065674     0.024414           0.024414  200.000000      100.000000
4  1299.257324   701.500000   497.732910 -161.065674   501.524414         501.524414  300.000000      200.000000
5  2803.769531  1504.512207   697.732910 -161.065674  2006.036621        2006.036621  100.000000      100.000000
6  6014.293945  3210.524414   697.732910 -161.065674  5116.561035        5116.561035  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:13]  --------------------------------------------------------------------------------
[07/13 21:16:13]  Iteration: 18
[07/13 21:16:14]  Generator returned sat in 0.021817 secs.
[07/13 21:16:14]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:16:14]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:14]  Verifer returned sat in 0.100422 secs.
[07/13 21:16:14]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   297.732666     0.097900    97.732666 -161.065674     0.000000           0.000000  200.000000      100.000000
1   297.732666     0.024414   297.708252 -161.065674     0.000000           0.000000    0.024414        0.000000
2   297.781494     0.073242   297.732666 -161.065674     0.000000           0.000000    0.048828      -99.951172
3   697.757080   400.000000   497.732666 -161.065674     0.024414           0.024414  200.000000      200.000000
4  1499.257080   801.500000   597.732666 -161.065674   701.524414         701.524414  200.000000      200.000000
5  2853.019287  1353.762207   597.732666 -161.065674  2055.286621        2055.286621  200.000000      100.000000
6  5035.162598  2182.143311   697.732666 -161.065674  4137.429932        4137.429932  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:14]  --------------------------------------------------------------------------------
[07/13 21:16:14]  Iteration: 19
[07/13 21:16:14]  Generator returned sat in 0.143371 secs.
[07/13 21:16:14]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:14]  Improved number of small numbers from 75 to 79 out of a max of 79
[07/13 21:16:14]  Verifer returned sat in 0.108753 secs.
[07/13 21:16:14]  Counter example:
    arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    297.738770     0.097656    97.732666 -161.065674      0.00000            0.00000  200.006104      100.006104
1    297.738770     0.023926   297.732666 -161.065674      0.00000            0.00000    0.006104        0.006104
2    297.781250     0.048584   297.732666 -161.065674      0.00000            0.00000    0.048584      -99.951416
3    697.756836   400.000000   497.732666 -161.065674      0.02417            0.02417  200.000000      200.000000
4   2097.756836  1400.000000   497.732666 -161.065674   1300.02417         1300.02417  300.000000      200.000000
5   5197.756836  3100.000000   597.732666 -161.065674   4400.02417         4400.02417  200.000000      100.000000
6  11847.756836  6650.000000   697.732666 -161.065674  10950.02417        10950.02417  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:14]  --------------------------------------------------------------------------------
[07/13 21:16:14]  Iteration: 20
[07/13 21:16:15]  Generator returned sat in 0.026225 secs.
[07/13 21:16:15]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:15]  Improved number of small numbers from 77 to 77 out of a max of 79
[07/13 21:16:15]  Verifer returned sat in 0.132650 secs.
[07/13 21:16:15]  Counter example:
    arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    297.738770     0.097656    98.399333 -161.065674      0.00000            0.00000  199.339437      100.006104
1    297.738770     0.023926   297.732666 -161.065674      0.00000            0.00000    0.006104        0.006104
2    297.781250     0.048584   297.732666 -161.065674      0.00000            0.00000    0.048584      -99.951416
3    697.756836   400.000000   497.732666 -161.065674      0.02417            0.02417  200.000000      200.000000
4   2097.756836  1400.000000   497.732666 -161.065674   1300.02417         1300.02417  300.000000      200.000000
5   5198.756836  3101.000000   597.732666 -161.065674   4400.02417         4400.02417  201.000000      101.000000
6  11851.756836  6653.000000   697.732666 -161.065674  10954.02417        10954.02417  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:15]  --------------------------------------------------------------------------------
[07/13 21:16:15]  Iteration: 21
[07/13 21:16:15]  Generator returned sat in 0.017953 secs.
[07/13 21:16:15]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:15]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:15]  Verifer returned sat in 0.108210 secs.
[07/13 21:16:15]  Counter example:
    arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0    497.744873     0.097656   297.744873 -161.065674     0.000000           0.000000    200.0           200.0
1    497.744873     0.023926   397.744873 -161.065674     0.000000           0.000000    100.0           100.0
2    497.744873     0.011963   397.744873 -161.065674     0.000000           0.000000    100.0             0.0
3    697.756836   300.000000   497.744873 -161.065674     0.011963           0.011963    200.0           100.0
4   1698.756836  1001.000000   647.744873 -161.065674   801.011963         801.011963    250.0           200.0
5   4201.756836  2503.000000   797.744873 -161.065674  3304.011963        3304.011963    100.0           100.0
6  10008.756836  5807.000000   797.744873 -161.065674  8911.011963        8911.011963    300.0           200.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:16]  --------------------------------------------------------------------------------
[07/13 21:16:16]  Iteration: 22
[07/13 21:16:16]  Generator returned sat in 0.022912 secs.
[07/13 21:16:16]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:16]  Improved number of small numbers from 65 to 79 out of a max of 79
[07/13 21:16:16]  Verifer returned sat in 0.144198 secs.
[07/13 21:16:16]  Counter example:
    arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    497.744385     0.097412   297.744629 -161.065674     0.000000           0.000000  199.999756      199.999756
1    497.744385     0.023926   397.744629 -161.065674     0.000000           0.000000   99.999756       99.999756
2    497.744385     0.011719   397.744629 -161.065674     0.000000           0.000000   99.999756       -0.000244
3    697.750732   300.000000   497.744629 -161.065674     0.006104           0.006104  200.000000      100.000000
4   1699.750732  1002.000000   645.747559 -161.065674   802.006104         802.006104  251.997070      200.000000
5   4201.756592  2502.005859   797.744629 -161.065674  3304.011719        3304.011719  100.000244      100.000244
6  10007.768311  5806.011719   797.744873 -161.065674  8910.023926        8910.023926  299.999512      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:16]  --------------------------------------------------------------------------------
[07/13 21:16:16]  Iteration: 23
[07/13 21:16:16]  Generator returned sat in 0.022151 secs.
[07/13 21:16:16]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:16]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:16]  Verifer returned sat in 0.095311 secs.
[07/13 21:16:17]  Counter example:
    arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    497.744629     0.097412   297.494629 -161.065674     0.000000           0.000000  200.250000      200.000000
1    497.744629     0.023926   397.744629 -161.065674     0.000000           0.000000  100.000000      100.000000
2    497.744629     0.011719   397.744629 -161.065674     0.000000           0.000000  100.000000        0.000000
3    697.750732   300.000000   497.744629 -161.065674     0.006104           0.006104  200.000000      100.000000
4   1699.750732  1002.000000   645.997559 -161.065674   802.006104         802.006104  251.747070      200.000000
5   4201.756592  2502.005859   797.744629 -161.065674  3304.011719        3304.011719  100.000244      100.000244
6  10007.268311  5805.511719   797.744873 -161.065674  8910.023926        8910.023926  299.499512      199.499756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:17]  --------------------------------------------------------------------------------
[07/13 21:16:17]  Iteration: 24
[07/13 21:16:17]  Generator returned sat in 0.029487 secs.
[07/13 21:16:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:17]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:17]  Verifer returned sat in 0.108012 secs.
[07/13 21:16:17]  Counter example:
    arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    497.744629     0.097168   296.744629 -161.065918     0.000000           0.000000  201.000000      200.000000
1    497.744629     0.023926   397.744385 -161.065918     0.000000           0.000000  100.000244      100.000000
2    497.744629     0.011719   397.744629 -161.065918     0.000000           0.000000  100.000000        0.000000
3    697.750488   300.000000   497.744629 -161.065918     0.005859           0.005859  200.000000      100.000000
4   1699.750488  1002.000000   645.997314 -161.065918   802.006104         802.006104  251.747070      199.999756
5   4200.256348  2500.505859   797.744629 -161.065918  3302.511719        3302.511719  100.000000      100.000000
6  10001.268066  5801.011719   797.744873 -161.065918  8910.023682        8910.023682  293.499512      193.499756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:17]  --------------------------------------------------------------------------------
[07/13 21:16:17]  Iteration: 25
[07/13 21:16:18]  Generator returned sat in 0.025550 secs.
[07/13 21:16:18]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:18]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:18]  Verifer returned sat in 0.129572 secs.
[07/13 21:16:18]  Counter example:
    arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    497.744385     0.096924   296.994629 -161.066162     0.000000           0.000000  200.749756      199.999756
1    497.744385     0.023682   397.744629 -161.066162     0.000000           0.000000   99.999756       99.999756
2    497.744385     0.011719   397.744629 -161.066162     0.000000           0.000000   99.999756       -0.000244
3    697.750244   300.000000   497.744629 -161.066162     0.005615           0.005615  200.000000      100.000000
4   1699.750244  1002.000000   645.747559 -161.066162   802.006104         802.006104  251.996582      199.999512
5   4200.256104  2500.505859   797.494629 -161.066162  3302.511475        3302.511475  100.250000      100.000000
6  10001.267822  5801.011719   797.744873 -161.066162  8910.023438        8910.023438  293.499512      193.499756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:18]  --------------------------------------------------------------------------------
[07/13 21:16:18]  Iteration: 26
[07/13 21:16:18]  Generator returned sat in 0.041955 secs.
[07/13 21:16:18]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:18]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:18]  Verifer returned sat in 0.103959 secs.
[07/13 21:16:18]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   497.744629     0.096924   296.994629 -161.066406     0.000000           0.000000  200.750000           200.0
1   497.744629     0.023682   297.744629 -161.066406     0.000000           0.000000  200.000000           100.0
2   497.744629     0.011719   497.738770 -161.066406     0.000000           0.000000    0.005859             0.0
3   697.747559   200.005859   497.744629 -161.066406     0.002930           0.002930  200.000000           100.0
4  1098.759277   401.011719   597.744629 -161.066406   201.014648         201.014648  300.000000           200.0
5  1901.782715   803.023438   697.744629 -161.066406   904.038086         904.038086  300.000000           200.0
6  3508.829590  1607.046875   797.744629 -161.066406  2411.084961        2411.084961  300.000000           200.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:18]  --------------------------------------------------------------------------------
[07/13 21:16:18]  Iteration: 27
[07/13 21:16:19]  Generator returned sat in 0.033932 secs.
[07/13 21:16:19]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:19]  Improved number of small numbers from 46 to 72 out of a max of 79
[07/13 21:16:19]  Verifer returned sat in 0.375534 secs.
[07/13 21:16:19]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   496.744629     0.096680   296.744873 -161.066895     0.000000           0.000000  199.999756      199.999756
1   496.744629     0.023438   296.744873 -161.066895     0.000000           0.000000  199.999756       99.999756
2   496.744629     0.011475   496.738953 -161.066650     0.000000           0.000000    0.005676        0.000000
3   696.747559   200.005737   496.744873 -161.066650     0.002869           0.002869  199.999817      100.000061
4  1098.759033   402.011475   596.744873 -161.066650   202.014404         202.014404  299.999756      200.000000
5  1904.781982   806.022949   696.744873 -161.066650   908.037354         908.037354  299.999756      200.000000
6  3518.827881  1614.045898   797.744385 -161.066650  2422.083252        2422.083252  299.000244      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:19]  --------------------------------------------------------------------------------
[07/13 21:16:19]  Iteration: 28
[07/13 21:16:20]  Generator returned sat in 0.035969 secs.
[07/13 21:16:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:20]  Improved gap from 47/8192 to 100
[07/13 21:16:20]  Improved number of small numbers from 66 to 73 out of a max of 80
[07/13 21:16:20]  Verifer returned sat in 0.267424 secs.
[07/13 21:16:20]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t   wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   496.744629     0.096436   296.744629 -161.06665     0.000000           0.000000  200.000000           200.0
1   496.744629     0.023193   396.744629 -161.06665     0.000000           0.000000  100.000000           100.0
2   496.744629     0.011475   396.744629 -161.06665     0.000000           0.000000  100.000000             0.0
3   696.750366   300.000000   496.744873 -161.06665     0.005737           0.005737  199.999756           100.0
4  1398.750488   702.000122   596.744629 -161.06665   502.005859         502.005859  300.000000           200.0
5  2904.750732  1506.000244   696.744629 -161.06665  1908.006104        1908.006104  300.000000           200.0
6  6068.751221  3164.000488   797.744385 -161.06665  5072.006592        5072.006592  199.000244           100.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:20]  --------------------------------------------------------------------------------
[07/13 21:16:20]  Iteration: 29
[07/13 21:16:20]  Generator returned sat in 0.031489 secs.
[07/13 21:16:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:20]  Improved gap from 393/8192 to 100
[07/13 21:16:21]  Improved number of small numbers from 32 to 80 out of a max of 80
[07/13 21:16:21]  Verifer returned sat in 0.191634 secs.
[07/13 21:16:21]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1199.755371     0.096191   999.707764 -964.029785     0.000000           0.000000  200.047607      100.047852
1  1199.755371     0.023926  1199.707520 -964.029785     0.000000           0.000000    0.047852        0.047852
2  1199.755371     0.023926  1199.707520 -964.029785     0.000000           0.000000    0.047852      -99.952148
3  1349.707520   150.000000  1299.707520 -964.029785     0.000000           0.000000   50.000000      -50.000000
4  1599.731689   300.000000  1482.707520 -964.029785     0.024170           0.024170  117.000000      100.000000
5  2625.731689  1026.000000  1599.707520 -964.029785   926.023926         926.023926  100.000244      100.000244
6  5279.231689  2653.500000  1599.707764 -964.029785  3379.524170        3379.524170  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:21]  --------------------------------------------------------------------------------
[07/13 21:16:21]  Iteration: 30
[07/13 21:16:21]  Generator returned sat in 0.036669 secs.
[07/13 21:16:21]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:16:21]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:21]  Verifer returned sat in 0.101409 secs.
[07/13 21:16:21]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1199.755371     0.096191   999.707764 -964.029785     0.000000           0.000000  200.047607      100.047852
1  1199.755371     0.023926  1199.707520 -964.029785     0.000000           0.000000    0.047852        0.047852
2  1199.755371     0.023926  1199.707520 -964.029785     0.000000           0.000000    0.047852      -99.952148
3  1499.707520   300.000000  1299.707520 -964.029785     0.000000           0.000000  200.000000      100.000000
4  1599.731689   300.000000  1482.707520 -964.029785     0.024170           0.024170  117.000000      100.000000
5  2625.731689  1026.000000  1599.707520 -964.029785   926.023926         926.023926  100.000244      100.000244
6  5279.231689  2653.500000  1599.707764 -964.029785  3379.524170        3379.524170  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:21]  --------------------------------------------------------------------------------
[07/13 21:16:21]  Iteration: 31
[07/13 21:16:22]  Generator returned sat in 0.045831 secs.
[07/13 21:16:22]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:16:22]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:22]  Verifer returned sat in 0.107240 secs.
[07/13 21:16:22]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1200.719482     0.095947   999.707764 -964.029785     0.000000           0.000000  201.011719      101.011963
1  1200.719482     0.023926  1199.707520 -964.029785     0.000000           0.000000    1.011963        1.011963
2  1200.719482     0.011963  1200.707520 -964.029785     0.000000           0.000000    0.011963      -98.988037
3  1499.707520   299.000000  1299.707520 -964.029785     0.000000           0.000000  200.000000      100.000000
4  1599.731445   300.000000  1482.707520 -964.029785     0.023926           0.023926  117.000000      100.000000
5  2625.731445  1026.000000  1599.707520 -964.029785   926.023926         926.023926  100.000000      100.000000
6  5277.731445  2652.000000  1599.707520 -964.029785  3378.023926        3378.023926  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:22]  --------------------------------------------------------------------------------
[07/13 21:16:22]  Iteration: 32
[07/13 21:16:22]  Generator returned sat in 0.036834 secs.
[07/13 21:16:22]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:22]  Improved gap from 99 to 100
[07/13 21:16:23]  Improved number of small numbers from 71 to 74 out of a max of 80
[07/13 21:16:23]  Verifer returned sat in 0.230393 secs.
[07/13 21:16:23]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1200.719238     0.095703   999.707275 -964.029785     0.000000           0.000000  201.011963      101.011963
1  1200.719238     0.023682  1199.707031 -964.029785     0.000000           0.000000    1.012207        1.011963
2  1200.719238     0.011963  1199.707275 -964.029785     0.000000           0.000000    1.011963      -98.988037
3  1499.207275   299.500000  1299.707520 -964.029785     0.000000           0.000000  199.499756       99.500000
4  1599.731201   300.000000  1482.707275 -964.029785     0.023682           0.023682  117.000244      100.000244
5  2625.731567  1026.000366  1560.707275 -964.029785   926.023438         926.023438  139.000854      100.000854
6  5220.732300  2595.000732  1599.707275 -964.029785  3321.025146        3321.025146  299.999878      199.999878
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:23]  --------------------------------------------------------------------------------
[07/13 21:16:23]  Iteration: 33
[07/13 21:16:23]  Generator returned sat in 0.037199 secs.
[07/13 21:16:23]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:23]  Improved gap from 391/16384 to 100
[07/13 21:16:23]  Improved number of small numbers from 58 to 80 out of a max of 80
[07/13 21:16:23]  Verifer returned sat in 0.162456 secs.
[07/13 21:16:23]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1276.706787     0.095459  1076.707031 -941.030029     0.000000           0.000000  199.999756      199.999756
1  1276.706787     0.047852  1165.707031 -941.030029     0.000000           0.000000  110.999756       99.999756
2  1376.707031   211.000000  1199.707031 -941.030029     0.000000           0.000000  177.000000      100.000000
3  1653.659180   277.000000  1276.707031 -941.030029   176.952148         176.952148  200.000000      100.000000
4  2509.159180   855.500000  1376.707031 -941.030029   832.452393         832.452393  299.999756      199.999756
5  4538.159180  2029.000000  1476.707031 -941.030029  2761.452393        2761.452393  299.999756      199.999756
6  9013.159180  4475.000000  1576.707031 -941.030029  7136.452393        7136.452393  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:24]  --------------------------------------------------------------------------------
[07/13 21:16:24]  Iteration: 34
[07/13 21:16:24]  Generator returned sat in 0.041437 secs.
[07/13 21:16:24]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:24]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:24]  Verifer returned sat in 0.108887 secs.
[07/13 21:16:24]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1276.706787     0.095459   976.707031 -941.030029     0.000000           0.000000  299.999756      199.999756
1  1276.706787     0.047852  1090.957031 -941.030029     0.000000           0.000000  185.749756       99.999756
2  1376.707031   285.750000  1199.707031 -941.030029     0.000000           0.000000  177.000000      100.000000
3  1584.409180   277.000000  1276.707031 -941.030029   107.702148         107.702148  200.000000      100.000000
4  2439.909180   855.500000  1476.707031 -941.030029   832.452393         832.452393  130.749756      130.749756
5  4538.159180  2098.250000  1476.707031 -941.030029  2761.452393        2761.452393  299.999756      199.999756
6  9013.159180  4475.000000  1576.707031 -941.030029  7136.452393        7136.452393  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:24]  --------------------------------------------------------------------------------
[07/13 21:16:24]  Iteration: 35
[07/13 21:16:25]  Generator returned sat in 0.033634 secs.
[07/13 21:16:25]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:25]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:25]  Verifer returned sat in 0.124639 secs.
[07/13 21:16:25]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1276.706543     0.095459   977.207031 -941.030029     0.000000           0.000000  299.499512      199.999512
1  1276.706543     0.047607  1090.957031 -941.030029     0.000000           0.000000  185.749512       99.999512
2  1376.706787   285.749756  1199.707031 -941.030029     0.000000           0.000000  176.999756       99.999756
3  1584.409180   277.000000  1276.707031 -941.030029   107.702148         107.702148  200.000000      100.000000
4  2439.909180   855.500000  1476.707031 -941.030029   832.452148         832.452148  130.750000      130.750000
5  4538.659180  2098.750000  1476.707031 -941.030029  2761.952393        2761.952393  299.999756      199.999756
6  9015.159180  4476.500000  1576.707031 -941.030029  7138.452148        7138.452148  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:25]  --------------------------------------------------------------------------------
[07/13 21:16:25]  Iteration: 36
[07/13 21:16:25]  Generator returned sat in 0.034970 secs.
[07/13 21:16:25]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:26]  Improved number of small numbers from 68 to 75 out of a max of 79
[07/13 21:16:26]  Verifer returned sat in 0.219239 secs.
[07/13 21:16:26]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1276.706543     0.095215  1076.706787 -941.030029     0.000000           0.000000  199.999756      199.999756
1  1276.706543     0.047363  1090.956787 -941.030029     0.000000           0.000000  185.749756       99.999756
2  1452.338867   361.382080  1248.175537 -941.030029     0.000000           0.000000  204.163330      175.632080
3  1680.846436   228.531250  1276.706787 -941.030029   204.139648         204.139648  200.000000      100.000000
4  2439.908936   759.062500  1476.706787 -941.030029   832.451904         832.451904  130.750244      130.750244
5  4538.658936  2098.750000  1476.707031 -941.030029  2761.952148        2761.952148  299.999756      200.000000
6  9080.956177  4542.297241  1576.707031 -941.030029  7204.249512        7204.249512  299.999634      199.999878
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:26]  --------------------------------------------------------------------------------
[07/13 21:16:26]  Iteration: 37
[07/13 21:16:26]  Generator returned sat in 0.055400 secs.
[07/13 21:16:26]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:26]  Improved gap from 195/16384 to 100
[07/13 21:16:26]  Improved number of small numbers from 40 to 80 out of a max of 80
[07/13 21:16:26]  Verifer returned sat in 0.238081 secs.
[07/13 21:16:26]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  3970.928955    0.094971  3970.881348 -3835.20459    0.000000           0.000000    0.047607        0.047607
1  3970.928955    0.023682  3970.881348 -3835.20459    0.000000           0.000000    0.047607      -99.952393
2  4070.928711  100.047363  4070.881348 -3835.20459    0.000000           0.000000    0.047363      -99.952637
3  4370.905029  300.000000  4170.881348 -3835.20459    0.023682           0.023682  200.000000      100.000000
4  4522.928955  352.000000  4270.881348 -3835.20459    0.047607           0.047607  252.000000      152.000000
5  5000.928955  478.000000  4470.881348 -3835.20459  330.047607         330.047607  200.000000      200.000000
6  5641.928955  641.000000  4470.881348 -3835.20459  971.047363         971.047363  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:27]  --------------------------------------------------------------------------------
[07/13 21:16:27]  Iteration: 38
[07/13 21:16:27]  Generator returned sat in 0.049705 secs.
[07/13 21:16:27]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:27]  Improved number of small numbers from 53 to 79 out of a max of 79
[07/13 21:16:27]  Verifer returned sat in 0.135331 secs.
[07/13 21:16:27]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4057.928955    0.094971  3970.881348 -3835.204834     0.000000           0.000000   87.047607       87.047607
1  4057.928955    0.047607  4057.881348 -3835.204834     0.000000           0.000000    0.047607      -12.952393
2  4370.881104  312.999756  4170.881348 -3835.204834     0.000000           0.000000  199.999756      199.999756
3  4370.928955  200.000000  4170.881348 -3835.204834     0.047607           0.047607  200.000000      100.000000
4  4772.928955  402.000000  4270.881348 -3835.204834   202.047607         202.047607  300.000000      200.000000
5  5389.928955  617.000000  4470.881348 -3835.204834   719.047607         719.047607  200.000000      200.000000
6  6308.928955  919.000000  4470.881348 -3835.204834  1538.047607        1538.047607  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:27]  --------------------------------------------------------------------------------
[07/13 21:16:27]  Iteration: 39
[07/13 21:16:28]  Generator returned sat in 0.037586 secs.
[07/13 21:16:28]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:28]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:28]  Verifer returned sat in 0.105541 secs.
[07/13 21:16:28]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4057.928955    0.094971  3968.881348 -3835.204834    0.000000           0.000000   89.047607       87.047607
1  4057.928955    0.047607  4057.881348 -3835.204834    0.000000           0.000000    0.047607      -12.952393
2  4370.881104  312.999756  4170.881348 -3835.204834    0.000000           0.000000  199.999756      199.999756
3  4370.928955  200.000000  4268.881348 -3835.204834    0.047607           0.047607  102.000000      100.000000
4  4672.928955  302.000000  4313.381348 -3835.204834  102.047607         102.047607  257.500000      200.000000
5  4930.428955  257.500000  4470.881348 -3835.204834  359.547607         359.547607  100.000000      100.000000
6  5232.428955  302.000000  4470.881348 -3835.204834  461.547607         461.547607  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:28]  --------------------------------------------------------------------------------
[07/13 21:16:28]  Iteration: 40
[07/13 21:16:28]  Generator returned sat in 0.045834 secs.
[07/13 21:16:29]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:29]  Improved gap from 389/8192 to 100
[07/13 21:16:29]  Improved number of small numbers from 55 to 80 out of a max of 80
[07/13 21:16:29]  Verifer returned sat in 0.169046 secs.
[07/13 21:16:29]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4113.381104     0.094727  4013.381104 -3835.205078     0.000000           0.000000  100.000000      100.000000
1  4113.381104     0.023926  4013.381348 -3835.205078     0.000000           0.000000   99.999756        0.000000
2  4213.381104   199.999756  4113.381348 -3835.205078     0.000000           0.000000   99.999756        0.000000
3  4213.381104     0.023926  4213.381104 -3835.205078     0.000000           0.000000    0.000000     -100.000000
4  4613.905029   400.523926  4313.381104 -3835.205078   100.523682         100.523682  200.000244      100.000244
5  5516.690674   902.785645  4513.381104 -3835.205078   803.309570         803.309570  200.000000      200.000000
6  7272.868896  1756.178223  4513.381104 -3835.205078  2459.487793        2459.487793  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:29]  --------------------------------------------------------------------------------
[07/13 21:16:29]  Iteration: 41
[07/13 21:16:29]  Generator returned sat in 0.041952 secs.
[07/13 21:16:29]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:29]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:29]  Verifer returned sat in 0.099174 secs.
[07/13 21:16:29]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4139.905029     0.094727  4113.893066 -3835.205078     0.000000           0.000000   26.011963       26.011963
1  4139.905029     0.023926  4139.893066 -3835.205078     0.000000           0.000000    0.011963      -73.988037
2  4413.905029   274.011963  4214.393066 -3835.205078     0.000000           0.000000  199.511963      100.011963
3  4413.905029   199.500000  4413.893066 -3835.205078     0.000000           0.000000    0.011963        0.011963
4  4613.905029   200.000000  4513.893066 -3835.205078     0.011963           0.011963  100.000000      100.000000
5  5289.905029   676.000000  4613.893066 -3835.205078   576.011963         576.011963  100.000000      100.000000
6  6705.405029  1415.500000  4613.893066 -3835.205078  1791.511963        1791.511963  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:30]  --------------------------------------------------------------------------------
[07/13 21:16:30]  Iteration: 42
[07/13 21:16:30]  Generator returned sat in 0.049108 secs.
[07/13 21:16:30]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:30]  Improved gap from 0 to 100
[07/13 21:16:30]  Improved number of small numbers from 58 to 80 out of a max of 80
[07/13 21:16:30]  Verifer returned sat in 0.196002 secs.
[07/13 21:16:30]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4513.987305     0.094482  4313.987305 -3835.205322     0.000000           0.000000  200.000000      200.000000
1  4513.987305     0.047363  4406.987305 -3835.205322     0.000000           0.000000  107.000000      100.000000
2  4513.987305   106.999756  4413.987549 -3835.205322     0.000000           0.000000   99.999756        0.000000
3  4714.034668   300.000000  4513.987305 -3835.205322     0.047119           0.047119  200.000244      100.000244
4  5366.034668   652.000000  4613.987305 -3835.205322   552.047119         552.047119  200.000244      100.000244
5  6553.034668  1187.000000  4713.987549 -3835.205322  1539.047363        1539.047363  299.999756      200.000000
6  8635.534668  2082.500000  4813.987549 -3835.205322  3521.547363        3521.547363  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:30]  --------------------------------------------------------------------------------
[07/13 21:16:30]  Iteration: 43
[07/13 21:16:31]  Generator returned sat in 0.057014 secs.
[07/13 21:16:31]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:31]  Improved gap from 0 to 48.4375
[07/13 21:16:31]  Improved number of small numbers from 76 to 80 out of a max of 80
[07/13 21:16:31]  Verifer returned sat in 0.139768 secs.
[07/13 21:16:31]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4513.987061    0.094482  4213.987305 -3835.205322        0.0                0.0  299.999756        200.0000
1  4513.987061    0.047119  4413.987061 -3835.205322        0.0                0.0  100.000000        100.0000
2  4513.987061    0.047119  4413.987305 -3835.205322        0.0                0.0   99.999756          0.0000
3  4762.424561  348.437256  4613.987061 -3835.205322        0.0                0.0  148.437500        148.4375
4  4762.424561    0.500000  4713.987061 -3835.205322        0.0                0.0   48.437500         48.4375
5  4762.424561    0.500000  4713.987061 -3783.642822        0.0                0.0   48.437500          0.0000
6  4762.424561    0.500000  4762.424561 -3783.642822        0.0                0.0    0.000000       -100.0000
high_util=False, low_loss=True, ramp_up=False, ramp_down=False, measured_loss_rate=0.
[07/13 21:16:31]  --------------------------------------------------------------------------------
[07/13 21:16:31]  Iteration: 44
[07/13 21:16:32]  Generator returned sat in 0.055418 secs.
[07/13 21:16:32]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:32]  Improved gap from 20673/16384 to 48.4375
[07/13 21:16:32]  Improved number of small numbers from 74 to 74 out of a max of 80
[07/13 21:16:32]  Verifer returned sat in 0.174477 secs.
[07/13 21:16:32]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4640.722656    0.094482  4340.722656 -3835.205322        0.0                0.0  300.000000      200.000000
1  4640.722656    0.047119  4540.722656 -3835.205322        0.0                0.0  100.000000      100.000000
2  4939.207275  298.484619  4640.722656 -3835.205322      100.0              100.0  198.484619      198.484619
3  4939.207275  196.905762  4640.722656 -3835.205322      100.0              100.0  198.484619       98.484619
4  4939.207275   98.952881  4839.183716 -3835.205322      100.0              100.0    0.023560       -1.515381
5  4989.160156   49.976440  4840.722656 -3783.642822      100.0              100.0   48.437500        0.000000
6  4989.160156   25.488220  4889.160156 -3783.642822      100.0              100.0    0.000000     -100.000000
high_util=False, low_loss=True, ramp_up=False, ramp_down=True, measured_loss_rate=0.
[07/13 21:16:32]  --------------------------------------------------------------------------------
[07/13 21:16:32]  Iteration: 45
[07/13 21:16:33]  Generator returned sat in 0.099332 secs.
[07/13 21:16:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:33]  Verifer returned unsat in 0.013431 secs.
[07/13 21:16:33]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:33]  --------------------------------------------------------------------------------
[07/13 21:16:33]  Iteration: 46
[07/13 21:16:33]  Generator returned sat in 0.061632 secs.
[07/13 21:16:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:33]  Verifer returned unsat in 0.011944 secs.
[07/13 21:16:33]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:33]  --------------------------------------------------------------------------------
[07/13 21:16:33]  Iteration: 47
[07/13 21:16:34]  Generator returned sat in 0.050721 secs.
[07/13 21:16:34]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:34]  Improved gap from 3/256 to 100
[07/13 21:16:34]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:16:34]  Verifer returned sat in 0.185758 secs.
[07/13 21:16:34]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4737.195312    0.094482  4537.195312 -3835.205566   0.000000           0.000000  200.000000           100.0
1  4737.195312    0.046875  4637.195312 -3835.205566   0.000000           0.000000  100.000000             0.0
2  5037.195312  400.000000  4837.195312 -3835.205566   0.000000           0.000000  200.000000           200.0
3  5037.195312  199.023438  4837.195312 -3835.205566   0.000000           0.000000  200.000000           100.0
4  5037.195312  199.523438  5037.171875 -3835.205566   0.000000           0.000000    0.023438             0.0
5  5237.207031  200.023438  5135.160156 -3835.205566   0.011719           0.011719  102.035156           100.0
6  5437.218750  302.035156  5137.195312 -3835.205566   0.023438           0.023438  300.000000           200.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:34]  --------------------------------------------------------------------------------
[07/13 21:16:34]  Iteration: 48
[07/13 21:16:35]  Generator returned sat in 0.116733 secs.
[07/13 21:16:35]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:35]  Improved number of small numbers from 65 to 79 out of a max of 79
[07/13 21:16:35]  Verifer returned sat in 0.123467 secs.
[07/13 21:16:35]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4737.218506    0.094238  4537.195312 -3835.206055    0.000000           0.000000  200.023193      100.023193
1  4737.218506    0.046387  4737.195312 -3835.206055    0.000000           0.000000    0.023193        0.023193
2  5037.195312  300.000000  4837.195312 -3835.206055    0.000000           0.000000  200.000000      200.000000
3  5037.195312  199.500000  4937.195312 -3835.206055    0.000000           0.000000  100.000000      100.000000
4  5137.195312  200.000000  5037.195312 -3835.206055    0.000000           0.000000  100.000000      100.000000
5  5237.718750  200.500000  5037.195312 -3835.206055    0.023438           0.023438  200.500000      100.500000
6  5840.218750  602.500000  5137.195312 -3835.206055  503.023438         503.023438  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:35]  --------------------------------------------------------------------------------
[07/13 21:16:35]  Iteration: 49
[07/13 21:16:36]  Generator returned sat in 0.059253 secs.
[07/13 21:16:36]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:36]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:36]  Verifer returned sat in 0.104356 secs.
[07/13 21:16:36]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4737.218506    0.094238  4537.195312 -3835.206055    0.000000           0.000000  200.023193      100.023193
1  4737.218506    0.046387  4737.195312 -3835.206055    0.000000           0.000000    0.023193        0.023193
2  5037.195312  300.000000  4837.195312 -3835.206055    0.000000           0.000000  200.000000      200.000000
3  5037.195312  199.500000  4937.195312 -3835.206055    0.000000           0.000000  100.000000      100.000000
4  5137.195312  200.000000  5037.195312 -3835.206055    0.000000           0.000000  100.000000      100.000000
5  5237.718750  200.500000  5037.195312 -3835.206055    0.023438           0.023438  200.500000      100.500000
6  5639.718750  402.000000  5137.195312 -3835.206055  302.523438         302.523438  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:36]  --------------------------------------------------------------------------------
[07/13 21:16:36]  Iteration: 50
[07/13 21:16:36]  Generator returned sat in 0.088413 secs.
[07/13 21:16:36]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:36]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:16:37]  Verifer returned sat in 0.105855 secs.
[07/13 21:16:37]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4737.218262    0.093994  4537.195312 -3835.206299    0.000000           0.000000  200.022949      100.022949
1  4737.218262    0.046387  4736.694824 -3835.206299    0.000000           0.000000    0.523438        0.022949
2  4937.718750  200.523682  4837.195312 -3835.206299    0.500244           0.500244  100.023193      100.023193
3  4937.718750   49.750000  4937.195312 -3835.206299    0.500244           0.500244    0.023193        0.023193
4  5037.695557  100.000000  5036.695312 -3835.206299    0.500244           0.500244    0.500000        0.000000
5  5237.718750  200.500000  5037.195312 -3835.206299    0.523438           0.523438  200.000000      100.000000
6  5639.718750  402.000000  5137.195312 -3835.206299  302.523193         302.523193  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:37]  --------------------------------------------------------------------------------
[07/13 21:16:37]  Iteration: 51
[07/13 21:16:37]  Generator returned sat in 0.108423 secs.
[07/13 21:16:37]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:37]  Improved gap from 385/8192 to 100
[07/13 21:16:37]  Improved number of small numbers from 68 to 80 out of a max of 80
[07/13 21:16:37]  Verifer returned sat in 0.131382 secs.
[07/13 21:16:37]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4537.936279    0.093750  4237.936523 -3835.206543    0.000000           0.000000  299.999756      200.000000
1  4537.936279    0.046875  4337.936523 -3835.206543    0.000000           0.000000  199.999756      100.000000
2  4737.936279  399.999756  4537.936279 -3835.206543    0.000000           0.000000  200.000000      200.000000
3  4737.936279   74.625000  4588.186523 -3835.206543    0.000000           0.000000  149.749756      100.000000
4  4737.936523  149.750000  4637.936279 -3835.206543    0.000000           0.000000  100.000244        0.000244
5  4937.983398  300.000000  4737.936279 -3835.206543    0.047119           0.047119  200.000000      100.000000
6  5789.983398  852.000000  4837.936279 -3835.206543  752.046875         752.046875  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:38]  --------------------------------------------------------------------------------
[07/13 21:16:38]  Iteration: 52
[07/13 21:16:38]  Generator returned sat in 0.095598 secs.
[07/13 21:16:38]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:38]  Improved number of small numbers from 77 to 79 out of a max of 79
[07/13 21:16:38]  Verifer returned sat in 0.106325 secs.
[07/13 21:16:38]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4438.436523    0.093506  4237.936279 -3835.206543    0.000000           0.000000  200.500244      200.000000
1  4438.436523    0.046631  4238.436768 -3835.206543    0.000000           0.000000  199.999756      100.000000
2  4638.436279  399.999512  4363.424805 -3835.206543    0.000000           0.000000  275.011475      199.999756
3  4638.436279  199.000000  4538.436279 -3835.206543    0.000000           0.000000  100.000000       99.999756
4  4737.936279  199.500000  4638.436523 -3835.206543    0.000000           0.000000   99.499756       99.499756
5  4838.459961  200.000000  4638.436523 -3835.206543    0.023438           0.023438  200.000000      100.000000
6  5690.483398  852.023438  4738.436523 -3835.206543  752.046631         752.046631  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:38]  --------------------------------------------------------------------------------
[07/13 21:16:38]  Iteration: 53
[07/13 21:16:39]  Generator returned sat in 0.108262 secs.
[07/13 21:16:39]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:39]  Improved number of small numbers from 70 to 79 out of a max of 79
[07/13 21:16:39]  Verifer returned sat in 0.108350 secs.
[07/13 21:16:39]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4438.436279    0.093262  4237.936035 -3835.206787    0.000000           0.000000  200.500244      199.999756
1  4438.436279    0.046387  4238.436523 -3835.206787    0.000000           0.000000  199.999756       99.999756
2  4638.436035  399.999512  4363.424805 -3835.206787    0.000000           0.000000  275.011230      199.999512
3  4638.436035  198.999756  4538.436035 -3835.206787    0.000000           0.000000  100.000000       99.999512
4  4689.186035  150.750000  4638.436523 -3835.206787    0.000000           0.000000   50.749512       50.749512
5  4838.959717  200.500000  4638.436523 -3835.206787    0.023193           0.023193  200.500000      100.500000
6  5390.983154  552.023438  4738.436523 -3835.206787  452.546631         452.546631  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:39]  --------------------------------------------------------------------------------
[07/13 21:16:39]  Iteration: 54
[07/13 21:16:40]  Generator returned sat in 0.093117 secs.
[07/13 21:16:40]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:40]  Improved number of small numbers from 61 to 77 out of a max of 79
[07/13 21:16:40]  Verifer returned sat in 0.229987 secs.
[07/13 21:16:40]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4438.459961    0.093018  4338.436279 -3835.206787    0.000000           0.000000  100.023682      100.023682
1  4438.459961    0.023193  4438.436279 -3835.206787    0.000000           0.000000    0.023682        0.023682
2  4738.436279  300.000000  4538.436279 -3835.206787    0.000000           0.000000  200.000000      200.000000
3  4738.436279    0.023315  4636.843018 -3835.206787    0.000000           0.000000  101.593262      100.000000
4  4786.593018  149.750000  4638.436279 -3835.206787    0.000000           0.000000  148.156738       48.156738
5  5038.459717  400.000000  4738.436279 -3835.206787    0.023438           0.023438  300.000000      200.000000
6  5440.459717  402.000000  4838.436523 -3835.206787  402.023193         402.023193  200.000000      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:40]  --------------------------------------------------------------------------------
[07/13 21:16:40]  Iteration: 55
[07/13 21:16:41]  Generator returned sat in 0.064559 secs.
[07/13 21:16:41]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:41]  Improved number of small numbers from 65 to 79 out of a max of 79
[07/13 21:16:41]  Verifer returned sat in 0.122601 secs.
[07/13 21:16:41]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4513.686279    0.092773  4290.029053 -3835.207031    0.000000           0.000000  223.657227      175.250000
1  4513.686279    0.023193  4338.436279 -3835.207031    0.000000           0.000000  175.250000       75.250000
2  4663.186035  324.749756  4538.436279 -3835.207031    0.000000           0.000000  124.749756      124.749756
3  4663.186035    0.023193  4538.436279 -3835.207031    0.000000           0.000000  124.749756       24.749756
4  4663.186279  124.750000  4638.436279 -3835.207031    0.000000           0.000000   24.750000      -75.250000
5  5063.163086  400.000000  4738.436279 -3835.207031   24.726807          24.726807  300.000000      200.000000
6  5865.163086  802.000000  4838.436279 -3835.207031  826.726562         826.726562  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:41]  --------------------------------------------------------------------------------
[07/13 21:16:41]  Iteration: 56
[07/13 21:16:42]  Generator returned sat in 0.170041 secs.
[07/13 21:16:42]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:42]  Improved number of small numbers from 55 to 79 out of a max of 79
[07/13 21:16:42]  Verifer returned sat in 0.176239 secs.
[07/13 21:16:42]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4513.686279    0.092529  4290.028809 -3835.207031    0.000000           0.000000  223.657471      175.250244
1  4513.686279    0.022949  4338.436035 -3835.207031    0.000000           0.000000  175.250244       75.250244
2  4738.108643  399.672607  4438.436279 -3835.207031    0.000000           0.000000  299.672363      199.672607
3  4738.108643    0.022949  4588.415527 -3835.207031    0.000000           0.000000  149.693115       99.672607
4  4738.108887  149.693359  4738.103027 -3835.207031    0.000000           0.000000    0.005859       -0.327148
5  4938.439209  200.333496  4738.436279 -3835.207031    0.002686           0.002686  200.000244      100.000488
6  5740.772705  802.333496  4838.436035 -3835.207031  702.336182         702.336182  200.000488      100.000488
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:42]  --------------------------------------------------------------------------------
[07/13 21:16:42]  Iteration: 57
[07/13 21:16:43]  Generator returned sat in 0.071916 secs.
[07/13 21:16:43]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:43]  Improved gap from 0 to 100
[07/13 21:16:44]  Improved number of small numbers from 30 to 67 out of a max of 80
[07/13 21:16:44]  Verifer returned sat in 0.529763 secs.
[07/13 21:16:44]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4187.792480    0.092285  3987.792501 -3584.563477     0.000000           0.000000  199.999980      100.000000
1  4187.792480    0.056152  4087.792480 -3584.563477     0.000000           0.000000  100.000000        0.000000
2  4387.505615  299.713135  4287.792480 -3584.563477     0.000000           0.000000   99.713135       99.713135
3  4387.505615    0.023193  4387.459167 -3584.563477     0.000000           0.000000    0.046448       -0.286865
4  4587.815633  200.333333  4387.792480 -3584.563477     0.023132           0.023132  200.000020      100.000020
5  5289.982300  702.166667  4487.792480 -3584.563477   502.189941         502.189941  299.999878      199.999878
6  6043.065633  753.083333  4587.792480 -3584.563477  1155.273193        1155.273193  299.999959      199.999959
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:44]  --------------------------------------------------------------------------------
[07/13 21:16:44]  Iteration: 58
[07/13 21:16:44]  Generator returned sat in 0.129124 secs.
[07/13 21:16:44]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:45]  Improved number of small numbers from 58 to 64 out of a max of 79
[07/13 21:16:45]  Verifer returned sat in 0.356473 secs.
[07/13 21:16:45]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4187.792236     0.092041  3987.815633 -3584.563721     0.000000           0.000000  199.976603       99.999756
1  4187.792236     0.056152  4087.792480 -3584.563721     0.000000           0.000000   99.999756       -0.000244
2  4387.505615   299.713135  4287.792480 -3584.563721     0.000000           0.000000   99.713135       99.713135
3  4387.505615     0.005783  4387.459167 -3584.563721     0.000000           0.000000    0.046448       -0.286865
4  4587.815633   200.333333  4487.792480 -3584.563721     0.023132           0.023132  100.000020      100.000020
5  5690.315633  1102.500000  4487.792480 -3584.563721   902.523193         902.523193  299.999959      199.999959
6  7746.065633  2055.750000  4587.792480 -3584.563721  2858.273193        2858.273193  299.999959      199.999959
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:45]  --------------------------------------------------------------------------------
[07/13 21:16:45]  Iteration: 59
[07/13 21:16:46]  Generator returned sat in 0.086739 secs.
[07/13 21:16:46]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:46]  Improved number of small numbers from 58 to 79 out of a max of 79
[07/13 21:16:46]  Verifer returned sat in 0.117160 secs.
[07/13 21:16:46]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4187.792236     0.091797  3987.792480 -3584.563965     0.000000           0.000000  199.999756       99.999756
1  4187.792236     0.055908  4087.792480 -3584.563965     0.000000           0.000000   99.999756       -0.000244
2  4412.554199   324.761719  4287.792236 -3584.563965     0.000000           0.000000  124.761963      124.761719
3  4412.554199   124.750000  4287.792480 -3584.563965     0.000000           0.000000  124.761719       24.761719
4  4687.815674   400.000000  4487.792480 -3584.563965     0.023193           0.023193  200.000000      200.000000
5  5689.815674  1002.000000  4587.792236 -3584.563965   902.023193         902.023193  200.000244      200.000000
6  6792.815674  1103.000000  4587.792480 -3584.563965  1905.023193        1905.023193  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:46]  --------------------------------------------------------------------------------
[07/13 21:16:46]  Iteration: 60
[07/13 21:16:47]  Generator returned sat in 0.179311 secs.
[07/13 21:16:47]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:47]  Improved gap from 1634075/16384 to 100
[07/13 21:16:47]  Improved number of small numbers from 43 to 80 out of a max of 80
[07/13 21:16:47]  Verifer returned sat in 0.223683 secs.
[07/13 21:16:47]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4688.329834    0.091553  4588.593750 -3584.564209     0.000000           0.000000   99.736084       99.736084
1  4688.329834    0.055664  4589.593750 -3584.564209     0.000000           0.000000   98.736084       -0.263916
2  4788.593506  198.999756  4788.579834 -3584.564209     0.000000           0.000000    0.013672       -0.000244
3  4788.593750    0.013916  4788.593750 -3584.564209     0.000000           0.000000    0.000000     -100.000000
4  5189.121582  400.527832  4988.593750 -3584.564209     0.528076           0.528076  199.999756      199.999756
5  5989.121582  800.000000  5088.593750 -3584.564209   700.528076         700.528076  199.999756      199.999756
6  6591.149414  602.027832  5088.593750 -3584.564209  1202.555908        1202.555908  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:16:47]  --------------------------------------------------------------------------------
[07/13 21:16:47]  Iteration: 61
[07/13 21:16:48]  Generator returned sat in 0.078532 secs.
[07/13 21:16:48]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:16:48]  Improved number of small numbers from 72 to 75 out of a max of 79
[07/13 21:17:11]  Verifer returned sat in 22.999668 secs.
[07/13 21:17:11]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4688.329590     0.091553  4588.593750 -3584.564453     0.000000           0.000000   99.735840       99.735840
1  4688.329590     0.055420  4589.593506 -3584.564453     0.000000           0.000000   98.736084       -0.264160
2  4788.593262   198.999756  4788.579834 -3584.564453     0.000000           0.000000    0.013428       -0.000488
3  4788.593750     0.013916  4788.593750 -3584.564453     0.000000           0.000000    0.000000     -100.000000
4  5189.121582   400.527832  4988.593506 -3584.564453     0.527832           0.527832  200.000244      200.000000
5  6589.913330  1400.791748  5088.593750 -3584.564453  1301.319580        1301.319580  200.000000      200.000000
6  9293.128784  2703.215454  5088.593750 -3584.564453  3904.535156        3904.535156  299.999878      199.999878
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:11]  --------------------------------------------------------------------------------
[07/13 21:17:11]  Iteration: 62
[07/13 21:17:12]  Generator returned sat in 0.148484 secs.
[07/13 21:17:12]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:12]  Improved number of small numbers from 77 to 77 out of a max of 79
[07/13 21:17:12]  Verifer returned sat in 0.141104 secs.
[07/13 21:17:12]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4688.329590     0.091553  4588.583313 -3584.564453     0.000000           0.000000   99.746277       99.735840
1  4688.329590     0.055420  4589.593506 -3584.564453     0.000000           0.000000   98.736084       -0.264160
2  4788.593262   198.999756  4788.579834 -3584.564453     0.000000           0.000000    0.013428       -0.000488
3  4788.593750     0.013916  4788.593750 -3584.564453     0.000000           0.000000    0.000000     -100.000000
4  5189.121582   400.527832  4988.593506 -3584.564453     0.527832           0.527832  200.000244      200.000000
5  6389.649414  1200.527832  5088.593750 -3584.564453  1101.055664        1101.055664  200.000000      200.000000
6  8192.205078  1802.555664  5088.593750 -3584.564453  2903.611328        2903.611328  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:12]  --------------------------------------------------------------------------------
[07/13 21:17:12]  Iteration: 63
[07/13 21:17:13]  Generator returned sat in 0.086452 secs.
[07/13 21:17:13]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:13]  Improved gap from 187/16384 to 100
[07/13 21:17:13]  Improved number of small numbers from 76 to 80 out of a max of 80
[07/13 21:17:13]  Verifer returned sat in 0.145492 secs.
[07/13 21:17:13]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4588.593018     0.091309  4588.547119 -3485.110107     0.000000           0.000000    0.045898        0.000244
1  4588.593018     0.022705  4588.593018 -3485.110107     0.000000           0.000000    0.000000      -99.999756
2  4788.592773   199.999756  4688.593018 -3485.110107     0.000000           0.000000   99.999756        0.000000
3  4788.592773    99.977295  4788.592773 -3485.110107     0.000000           0.000000    0.000000     -100.000000
4  5189.184082   400.591309  4888.593018 -3485.110107     0.591309           0.591309  299.999756      200.000000
5  6191.775391  1002.591309  5024.593018 -3485.110107   903.182617         903.182617  263.999756      200.000000
6  7868.366699  1676.591309  5088.592773 -3485.110107  2579.773682        2579.773682  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:13]  --------------------------------------------------------------------------------
[07/13 21:17:13]  Iteration: 64
[07/13 21:17:14]  Generator returned sat in 0.128283 secs.
[07/13 21:17:14]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:14]  Improved number of small numbers from 72 to 75 out of a max of 79
[07/13 21:17:14]  Verifer returned sat in 0.158039 secs.
[07/13 21:17:14]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  4588.593018     0.091309  4588.547119 -3485.110352     0.000000           0.000000    0.045898        0.000244
1  4588.593018     0.022461  4588.593018 -3485.110352     0.000000           0.000000    0.000000      -99.999756
2  4788.592773   199.999756  4688.592773 -3485.110352     0.000000           0.000000  100.000000        0.000000
3  4788.592773    99.977295  4788.592773 -3485.110352     0.000000           0.000000    0.000000     -100.000000
4  5189.184082   400.591309  4888.593018 -3485.110352     0.591309           0.591309  299.999756      200.000000
5  5991.479736   802.295654  5088.592773 -3485.110352   702.886963         702.886963  200.000000      200.000000
6  7194.627563  1203.147827  5088.592773 -3485.110352  1906.034668        1906.034668  200.000122      100.000122
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:14]  --------------------------------------------------------------------------------
[07/13 21:17:14]  Iteration: 65
[07/13 21:17:15]  Generator returned sat in 0.361320 secs.
[07/13 21:17:15]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:15]  Improved gap from 4027/8192 to 100
[07/13 21:17:16]  Improved number of small numbers from 39 to 76 out of a max of 80
[07/13 21:17:16]  Verifer returned sat in 0.639120 secs.
[07/13 21:17:16]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1536.889648     0.091064  1536.843872 -3485.110596     0.000000           0.000000    0.045776        0.045654
1  1536.889648     0.022949  1536.889648 -3485.110596     0.000000           0.000000    0.000000      -99.954346
2  1718.843994   181.954346  1718.843994 -3485.110596     0.000000           0.000000    0.000000      -18.000000
3  1936.866699   218.022705  1836.843994 -3485.110596     0.022705           0.022705  100.000000      100.000000
4  2756.889648   820.022949  1936.843872 -3485.110596   720.045410         720.045410  100.000366      100.000244
5  4378.821045  1621.931396  1936.843994 -3485.110596  2241.977051        2241.977051  200.000000      100.000000
6  6438.752441  2059.931396  2036.843994 -3485.110596  4101.908447        4101.908447  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:16]  --------------------------------------------------------------------------------
[07/13 21:17:16]  Iteration: 66
[07/13 21:17:17]  Generator returned sat in 0.127650 secs.
[07/13 21:17:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:17]  Improved gap from 373/8192 to 100
[07/13 21:17:17]  Improved number of small numbers from 37 to 80 out of a max of 80
[07/13 21:17:17]  Verifer returned sat in 0.195228 secs.
[07/13 21:17:17]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1436.527832    0.090820  1136.528076 -3485.110596    0.000000           0.000000  299.999756      199.999756
1  1436.527832    0.045410  1236.528076 -3485.110596    0.000000           0.000000  199.999756       99.999756
2  1636.528076  400.000000  1436.528076 -3485.110596    0.000000           0.000000  200.000000      200.000000
3  1636.528076   98.908691  1436.528076 -3485.110596    0.000000           0.000000  200.000000      100.000000
4  1636.528076  199.954346  1569.543457 -3485.110596    0.000000           0.000000   66.984619        0.000000
5  1903.512939  266.984863  1636.528076 -3485.110596   66.984619          66.984619  200.000244      100.000244
6  2705.990234  802.477295  1736.528076 -3485.110596  669.462158         669.462158  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:17]  --------------------------------------------------------------------------------
[07/13 21:17:17]  Iteration: 67
[07/13 21:17:18]  Generator returned sat in 0.097728 secs.
[07/13 21:17:18]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:18]  Improved number of small numbers from 68 to 71 out of a max of 79
[07/13 21:17:18]  Verifer returned sat in 0.191980 secs.
[07/13 21:17:18]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1436.527588    0.090820  1136.528076 -3485.110596    0.000000           0.000000  299.999512      199.999512
1  1436.527588    0.045166  1236.528076 -3485.110596    0.000000           0.000000  199.999512       99.999512
2  1636.528076  400.000000  1436.528076 -3485.110596    0.000000           0.000000  200.000000      200.000000
3  1636.528076   49.454346  1436.528076 -3485.110596    0.000000           0.000000  200.000000      100.000000
4  1636.528076  199.954346  1569.543457 -3485.110596    0.000000           0.000000   66.984619        0.000000
5  2003.490112  366.962036  1636.528076 -3485.110596   66.984619          66.984619  299.977417      199.977417
6  2955.933167  952.443054  1736.528076 -3485.110596  919.405273         919.405273  299.999817      199.999817
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:18]  --------------------------------------------------------------------------------
[07/13 21:17:18]  Iteration: 68
[07/13 21:17:19]  Generator returned sat in 0.134068 secs.
[07/13 21:17:19]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:19]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:17:19]  Verifer returned sat in 0.119537 secs.
[07/13 21:17:19]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1436.527588    0.090820  1136.528076 -3485.110596    0.000000           0.000000  299.999512      199.999512
1  1436.527588    0.045166  1236.528076 -3485.110596    0.000000           0.000000  199.999512       99.999512
2  1636.528076  400.000000  1436.528076 -3485.110596    0.000000           0.000000  200.000000      200.000000
3  1636.528076   49.454346  1436.528076 -3485.110596    0.000000           0.000000  200.000000      100.000000
4  1636.528076  199.954346  1636.528076 -3485.110596    0.000000           0.000000    0.000000        0.000000
5  2036.982422  400.454346  1636.528076 -3485.110596  100.454346         100.454346  300.000000      200.000000
6  2438.982422  402.000000  1736.528076 -3485.110596  502.454346         502.454346  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:19]  --------------------------------------------------------------------------------
[07/13 21:17:19]  Iteration: 69
[07/13 21:17:20]  Generator returned sat in 0.130802 secs.
[07/13 21:17:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:20]  Improved gap from 4561/8192 to 100
[07/13 21:17:20]  Improved number of small numbers from 58 to 70 out of a max of 80
[07/13 21:17:20]  Verifer returned sat in 0.305760 secs.
[07/13 21:17:20]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1436.527832    0.090576  1236.528076 -3485.111084    0.000000           0.000000  199.999756      199.999756
1  1436.527832    0.022705  1239.130249 -3485.111084    0.000000           0.000000  197.397583       99.999756
2  1537.084839  297.954590  1436.528076 -3485.111084    0.000000           0.000000  100.556763      100.556763
3  1537.084839    0.022705  1436.528076 -3485.111084    0.000000           0.000000  100.556763        0.556763
4  1537.084839  100.534058  1536.528076 -3485.111084    0.000000           0.000000    0.556763      -99.443237
5  1837.062256  300.000000  1668.831055 -3485.111084    0.534180           0.534180  167.697021      100.000000
6  2303.668213  466.605957  1736.528076 -3485.111084  267.140137         267.140137  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:21]  --------------------------------------------------------------------------------
[07/13 21:17:21]  Iteration: 70
[07/13 21:17:22]  Generator returned sat in 0.400063 secs.
[07/13 21:17:22]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:22]  Improved gap from 0 to 100
[07/13 21:17:22]  Improved number of small numbers from 51 to 80 out of a max of 80
[07/13 21:17:22]  Verifer returned sat in 0.217853 secs.
[07/13 21:17:22]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1437.084961    0.090820  1337.084961 -3485.111328    0.000000           0.000000  100.000000      100.000000
1  1437.084961    0.022705  1437.039551 -3485.111328    0.000000           0.000000    0.045410        0.000000
2  1437.084961    0.022705  1437.084961 -3485.111328    0.000000           0.000000    0.000000     -100.000000
3  1537.107666  100.022705  1537.084961 -3485.111328    0.000000           0.000000    0.022705      -99.977295
4  1737.607666  200.522705  1637.084961 -3485.111328    0.000000           0.000000  100.522705        0.522705
5  1938.152832  301.045410  1737.084961 -3485.111328    0.022461           0.022461  201.045410      101.045410
6  2690.675537  752.522705  1837.084961 -3485.111328  553.590576         553.590576  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:22]  --------------------------------------------------------------------------------
[07/13 21:17:22]  Iteration: 71
[07/13 21:17:23]  Generator returned sat in 0.544206 secs.
[07/13 21:17:23]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:24]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:17:24]  Verifer returned sat in 0.114932 secs.
[07/13 21:17:24]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0  1437.084961     0.09082  1237.084961 -3385.111328        0.0                0.0    200.0           200.0
1  1437.084961   199.95459  1337.084961 -3385.111328        0.0                0.0    100.0           100.0
2  1437.084961     0.04541  1437.084961 -3385.111328        0.0                0.0      0.0             0.0
3  1637.084961   200.00000  1437.084961 -3385.111328        0.0                0.0    200.0           100.0
4  2037.084961   400.00000  1637.084961 -3385.111328      300.0              300.0    100.0           100.0
5  2988.084961   951.00000  1726.084961 -3385.111328     1051.0             1051.0    211.0           200.0
6  5035.584961  2047.50000  1837.084961 -3385.111328     3098.5             3098.5    100.0           100.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:24]  --------------------------------------------------------------------------------
[07/13 21:17:24]  Iteration: 72
[07/13 21:17:25]  Generator returned sat in 0.270466 secs.
[07/13 21:17:25]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:17:25]  Improved number of small numbers from 75 to 79 out of a max of 79
[07/13 21:17:25]  Verifer returned sat in 0.113980 secs.
[07/13 21:17:25]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1437.084961     0.090332  1237.084961 -3385.111816     0.000000           0.000000  200.000000      200.000000
1  1437.084961   199.954834  1337.084961 -3385.111816     0.000000           0.000000  100.000000      100.000000
2  1437.084961     0.045166  1437.084717 -3385.111816     0.000000           0.000000    0.000244        0.000000
3  1637.084717   200.000000  1437.084961 -3385.111816     0.000000           0.000000  199.999756       99.999756
4  2239.084717   602.000000  1537.084961 -3385.111816   401.999756         401.999756  300.000000      200.000000
5  3544.084717  1305.000000  1663.084717 -3385.111816  1606.999756        1606.999756  274.000244      200.000000
6  6268.084717  2724.000000  1837.084717 -3385.111816  4330.999756        4330.999756  100.000244      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:25]  --------------------------------------------------------------------------------
[07/13 21:17:25]  Iteration: 73
[07/13 21:17:26]  Generator returned sat in 0.221137 secs.
[07/13 21:17:26]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:17:26]  Improved number of small numbers from 70 to 73 out of a max of 79
[07/13 21:17:26]  Verifer returned sat in 0.217116 secs.
[07/13 21:17:26]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1437.084961     0.090088  1169.751628 -3385.112061     0.000000           0.000000  267.333333      200.000000
1  1437.084961   199.954834  1337.084961 -3385.112061     0.000000           0.000000  100.000000      100.000000
2  1437.084961     0.045166  1437.084717 -3385.112061     0.000000           0.000000    0.000244        0.000000
3  1569.751383   132.666667  1437.084961 -3385.112061     0.000000           0.000000  132.666423       32.666423
4  2239.084717   669.333333  1537.084961 -3385.112061   401.999756         401.999756  300.000000      200.000000
5  3544.084717  1305.000000  1737.084961 -3385.112061  1706.999756        1706.999756  100.000000      100.000000
6  5952.585083  2408.500366  1737.084961 -3385.112061  4015.500000        4015.500000  200.000122      100.000122
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:26]  --------------------------------------------------------------------------------
[07/13 21:17:26]  Iteration: 74
[07/13 21:17:27]  Generator returned sat in 0.250780 secs.
[07/13 21:17:27]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:17:27]  Improved gap from 0 to 100
[07/13 21:17:28]  Improved number of small numbers from 30 to 52 out of a max of 80
[07/13 21:17:28]  Verifer returned sat in 0.577494 secs.
[07/13 21:17:28]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1337.097656     0.089844  1337.052439 -3385.112061     0.000000           0.000000    0.045217        0.000244
1  1337.097656     0.022461  1337.097483 -3385.112061     0.000000           0.000000    0.000173      -99.999756
2  1537.120005   200.022522  1537.097412 -3385.112061     0.000000           0.000000    0.022593        0.022593
3  1537.120005     0.022522  1537.097483 -3385.112061     0.000000           0.000000    0.022522      -99.977407
4  1938.732615   401.612610  1637.097483 -3385.112061     1.635254           1.635254  299.999878      199.999949
5  2992.151530  1053.418915  1737.097412 -3385.112061   955.054199         955.054199  299.999918      199.999918
6  4873.279902  1881.128372  1837.097656 -3385.112061  2736.182617        2736.182617  299.999628      199.999872
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:28]  --------------------------------------------------------------------------------
[07/13 21:17:28]  Iteration: 75
[07/13 21:17:29]  Generator returned sat in 0.570204 secs.
[07/13 21:17:29]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:29]  Improved gap from 0 to 100
[07/13 21:17:30]  Improved number of small numbers from 51 to 80 out of a max of 80
[07/13 21:17:30]  Verifer returned sat in 0.192566 secs.
[07/13 21:17:30]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1337.097412     0.089600  1037.097656 -3385.112061     0.000000           0.000000  299.999756      199.999756
1  1337.097412     0.044678  1237.097656 -3385.112061     0.000000           0.000000   99.999756       99.999756
2  1337.097412     0.044922  1237.097656 -3385.112061     0.000000           0.000000   99.999756       -0.000244
3  1437.097656   200.000000  1337.097656 -3385.112061     0.000000           0.000000  100.000000        0.000000
4  1637.142578   300.000000  1460.097656 -3385.112061     0.044922           0.044922  177.000000      100.000000
5  2422.642578   785.500000  1634.097656 -3385.112061   585.544922         585.544922  203.000000      200.000000
6  4197.392578  1774.750000  1637.097656 -3385.112061  2260.294922        2260.294922  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:30]  --------------------------------------------------------------------------------
[07/13 21:17:30]  Iteration: 76
[07/13 21:17:31]  Generator returned sat in 0.155697 secs.
[07/13 21:17:31]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:31]  Improved number of small numbers from 77 to 77 out of a max of 79
[07/13 21:17:31]  Verifer returned sat in 0.122540 secs.
[07/13 21:17:31]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1337.097412     0.089600  1037.097656 -3385.112061     0.000000           0.000000  299.999756      199.999756
1  1337.097412     0.044678  1237.097656 -3385.112061     0.000000           0.000000   99.999756       99.999756
2  1337.097412     0.044922  1237.097656 -3385.112061     0.000000           0.000000   99.999756       -0.000244
3  1436.727286   199.629630  1337.653212 -3385.112061     0.000000           0.000000   99.074074       -0.370370
4  1637.142578   299.444444  1460.097656 -3385.112061     0.044922           0.044922  177.000000      100.000000
5  2422.309245   785.166667  1634.097656 -3385.112061   585.544922         585.544922  202.666667      199.666667
6  4197.059245  1774.750000  1637.097656 -3385.112061  2260.294922        2260.294922  299.666667      199.666667
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:31]  --------------------------------------------------------------------------------
[07/13 21:17:31]  Iteration: 77
[07/13 21:17:32]  Generator returned sat in 0.125010 secs.
[07/13 21:17:32]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:32]  Improved number of small numbers from 37 to 68 out of a max of 79
[07/13 21:17:32]  Verifer returned sat in 0.414212 secs.
[07/13 21:17:32]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1237.085205    0.089355   937.085449 -3385.112305   0.000000           0.000000  299.999756      199.999756
1  1237.085205    0.022461  1137.085449 -3385.112305   0.000000           0.000000   99.999756       99.999756
2  1237.085205   99.977783  1203.796723 -3385.112061   0.000000           0.000000   33.288482        0.000000
3  1337.130056  133.333333  1337.085205 -3385.112061   0.000000           0.000000    0.044851        0.044851
4  1537.107666  200.000000  1337.085449 -3385.112061   0.022461           0.022461  199.999756      100.000000
5  1638.630127  301.500000  1443.196723 -3385.112061   0.044678           0.044678  195.388726      101.500244
6  1803.841523  360.600000  1537.085449 -3385.112061   0.044800           0.044800  266.711274      166.711518
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:32]  --------------------------------------------------------------------------------
[07/13 21:17:32]  Iteration: 78
[07/13 21:17:33]  Generator returned sat in 0.145117 secs.
[07/13 21:17:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:33]  Improved gap from 183/4096 to 100
[07/13 21:17:34]  Improved number of small numbers from 27 to 80 out of a max of 80
[07/13 21:17:34]  Verifer returned sat in 0.250243 secs.
[07/13 21:17:34]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    39.267578    0.089111   -60.799561 -3385.112061     0.000000           0.000000  100.067139      100.067139
1    39.267578    0.022217    39.200439 -3385.112061     0.000000           0.000000    0.067139        0.067139
2    39.267578    0.022461    39.222900 -3385.112061     0.000000           0.000000    0.044678      -99.932861
3   339.222900  299.977539   239.200439 -3385.112061     0.022461           0.022461  100.000000      100.000000
4   941.211670  601.988770   239.200439 -3385.112061   502.010986         502.010986  200.000244      100.000244
5  1544.206055  602.994385   417.200684 -3385.112061   905.005615         905.005615  221.999756      200.000000
6  2414.669922  870.463867   439.200684 -3385.112061  1675.469482        1675.469482  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:34]  --------------------------------------------------------------------------------
[07/13 21:17:34]  Iteration: 79
[07/13 21:17:35]  Generator returned sat in 0.723583 secs.
[07/13 21:17:35]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:35]  Improved number of small numbers from 42 to 79 out of a max of 79
[07/13 21:17:35]  Verifer returned sat in 0.193171 secs.
[07/13 21:17:35]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    39.267334    0.089111  -156.743652 -3385.112061    0.000000           0.000000  196.010986      100.010986
1    39.267334    0.022217   -60.743652 -3385.112061    0.000000           0.000000  100.010986        0.010986
2    39.267334  100.005615    39.256348 -3385.112061    0.000000           0.000000    0.010986      -99.989014
3   339.261963  300.000000   239.256348 -3385.112061    0.005615           0.005615  100.000000      100.000000
4   539.261963  200.000000   339.256348 -3385.112061  100.005615         100.005615  100.000000      100.000000
5   741.261963  202.000000   437.923340 -3385.112061  200.005615         200.005615  103.333008      102.000000
6   942.595459  201.333496   439.256592 -3385.112061  303.338867         303.338867  200.000000      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:36]  --------------------------------------------------------------------------------
[07/13 21:17:36]  Iteration: 80
[07/13 21:17:37]  Generator returned sat in 0.308244 secs.
[07/13 21:17:37]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:37]  Improved gap from 0 to 23.4375
[07/13 21:17:37]  Improved number of small numbers from 47 to 80 out of a max of 80
[07/13 21:17:37]  Verifer returned sat in 0.246981 secs.
[07/13 21:17:37]  Counter example:
   arrival_0,t   cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t    queue_t  bottle_queue_t
0   -97.986816   0.088867  -121.469238 -3514.799805        0.0                0.0  23.482422       23.482178
1   -97.986816   0.044434   -98.031738 -3461.674561        0.0                0.0   0.044922      -23.392578
2   -74.549561  23.482178   -74.593994 -3385.112305        0.0                0.0   0.044434      -23.393066
3    -8.719238  65.874756   -32.156738 -3327.549561        0.0                0.0  23.437500        0.000000
4    12.499512  44.656250    -8.719238 -3250.987061        0.0                0.0  21.218750       -2.218750
5    35.937012  44.656250    14.718506 -3174.424805        0.0                0.0  21.218506       -2.218994
6    59.374756  44.656250    38.156006 -3174.424805        0.0                0.0  21.218750      -78.781250
high_util=False, low_loss=True, ramp_up=False, ramp_down=False, measured_loss_rate=0.
[07/13 21:17:37]  --------------------------------------------------------------------------------
[07/13 21:17:37]  Iteration: 81
[07/13 21:17:38]  Generator returned sat in 0.273101 secs.
[07/13 21:17:38]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:38]  Improved gap from 91/4096 to 100
[07/13 21:17:38]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:17:38]  Verifer returned sat in 0.170901 secs.
[07/13 21:17:38]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0   -74.593994     0.088867  -274.593994 -3174.424805     0.000000           0.000000    200.0           200.0
1   -74.593994     0.044434  -174.593994 -3174.424805     0.000000           0.000000    100.0           100.0
2   125.406006   300.000000   -74.593994 -3174.424805     0.000000           0.000000    200.0           200.0
3   125.450439   200.000000   -74.593994 -3174.424805     0.044434           0.044434    200.0           100.0
4   827.450439   702.000000   102.406006 -3174.424805   502.044434         502.044434    223.0           200.0
5  2436.450439  1609.000000   225.406006 -3174.424805  2011.044434        2011.044434    200.0           200.0
6  5451.950439  3015.500000   225.406006 -3174.424805  4926.544434        4926.544434    300.0           200.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:39]  --------------------------------------------------------------------------------
[07/13 21:17:39]  Iteration: 82
[07/13 21:17:40]  Generator returned sat in 0.655105 secs.
[07/13 21:17:40]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:17:40]  Improved number of small numbers from 38 to 79 out of a max of 79
[07/13 21:17:40]  Verifer returned sat in 0.193242 secs.
[07/13 21:17:40]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -180.094238     0.088379  -480.093994 -3068.925049     0.000000           0.000000  299.999756      199.999756
1  -180.094238     0.044189  -380.093994 -3068.925049     0.000000           0.000000  199.999756       99.999756
2    19.905762   399.999756  -180.093994 -3068.925049     0.000000           0.000000  199.999756      199.999756
3    19.950195   200.000000  -177.093994 -3068.925049     0.044189           0.044189  197.000000      100.000000
4   827.450195   807.500000    19.906006 -3068.925049   607.544434         607.544434  199.999756      199.999756
5  2436.450195  1609.000000    19.906006 -3068.925049  2116.544434        2116.544434  299.999756      199.999756
6  4446.950195  2010.500000   119.906006 -3068.925049  4127.044189        4127.044189  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:40]  --------------------------------------------------------------------------------
[07/13 21:17:40]  Iteration: 83
[07/13 21:17:41]  Generator returned sat in 0.209157 secs.
[07/13 21:17:41]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:42]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:17:42]  Verifer returned sat in 0.106572 secs.
[07/13 21:17:42]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -180.094238     0.088379  -480.093994 -3068.925049     0.000000           0.000000  299.999756      199.999756
1  -180.094238     0.044189  -380.093994 -3068.925049     0.000000           0.000000  199.999756       99.999756
2    19.905762   399.999756  -180.593994 -3068.925049     0.000000           0.000000  200.499756      199.999756
3    20.450195   200.500000  -177.093994 -3068.925049     0.544189           0.544189  197.000000      100.000000
4   827.950195   807.500000    19.906006 -3068.925049   608.044189         608.044189  200.000000      200.000000
5  2436.450195  1608.500000    19.906006 -3068.925049  2116.544434        2116.544434  299.999756      199.999756
6  4446.950195  2010.500000   119.906006 -3068.925049  4127.044189        4127.044189  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:42]  --------------------------------------------------------------------------------
[07/13 21:17:42]  Iteration: 84
[07/13 21:17:43]  Generator returned sat in 0.238397 secs.
[07/13 21:17:43]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:43]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:17:43]  Verifer returned sat in 0.095670 secs.
[07/13 21:17:43]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -180.094482     0.088135  -480.093994 -3068.925049     0.000000           0.000000  299.999512      199.999756
1  -180.094482     0.043945  -380.094238 -3068.925049     0.000000           0.000000  199.999756       99.999756
2    19.905518   399.999756  -180.594238 -3068.925049     0.000000           0.000000  200.499756      199.999756
3    21.449951   201.500000  -177.093994 -3068.925049     0.544189           0.544189  197.999756      101.000000
4   829.449951   808.000000    19.905762 -3068.925049   609.544189         609.544189  200.000000      200.000000
5  2437.949951  1608.500000    19.905762 -3068.925049  2118.044189        2118.044189  300.000000      200.000000
6  4447.949951  2010.000000   119.906006 -3068.925049  4128.044189        4128.044189  199.999756      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:43]  --------------------------------------------------------------------------------
[07/13 21:17:43]  Iteration: 85
[07/13 21:17:44]  Generator returned sat in 0.544702 secs.
[07/13 21:17:44]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:45]  Improved number of small numbers from 50 to 58 out of a max of 79
[07/13 21:17:45]  Verifer returned sat in 0.371276 secs.
[07/13 21:17:45]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   179.479492    0.087891   179.479290 -3068.925293   0.000000           0.000000    0.000202      -99.999798
1   579.479290  400.000000   379.479248 -3068.925293   0.000000           0.000000  200.000042      200.000000
2   579.479290    0.000977   379.479290 -3068.925293   0.000000           0.000000  200.000000      100.000000
3   579.479290    0.010625   579.477415 -3068.925293   0.000000           0.000000    0.001875        0.000000
4   779.493353  200.015000   679.479248 -3068.925293   0.000937           0.000937  100.013167      100.013125
5   779.493353    0.010000   779.479290 -3068.925293   0.000937           0.000937    0.013125        0.013125
6   979.496165  200.015000   779.479492 -3068.925293   0.001875           0.001875  200.014798      100.015000
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:45]  --------------------------------------------------------------------------------
[07/13 21:17:45]  Iteration: 86
[07/13 21:17:46]  Generator returned sat in 0.251299 secs.
[07/13 21:17:46]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:17:46]  Improved gap from 0 to 100
[07/13 21:17:46]  Improved number of small numbers from 44 to 80 out of a max of 80
[07/13 21:17:46]  Verifer returned sat in 0.211197 secs.
[07/13 21:17:46]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   447.024414     0.087646   347.024658 -3068.675781        0.0                0.0   99.999756       99.999756
1   447.024658   100.000000   447.024658 -3068.675781        0.0                0.0    0.000000        0.000000
2   647.024658   200.000000   447.024658 -3068.675781        0.0                0.0  200.000000      100.000000
3   647.024658   132.000000   547.024658 -3068.675781        0.0                0.0  100.000000        0.000000
4   947.024658   300.000000   647.024658 -3068.675781      100.0              100.0  200.000000      100.000000
5  1647.024658   700.000000   747.024658 -3068.675781      600.0              600.0  300.000000      200.000000
6  2947.024658  1300.000000   947.024658 -3068.675781     1800.0             1800.0  200.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:47]  --------------------------------------------------------------------------------
[07/13 21:17:47]  Iteration: 87
[07/13 21:17:48]  Generator returned sat in 0.178979 secs.
[07/13 21:17:48]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:17:48]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:17:48]  Verifer returned sat in 0.112686 secs.
[07/13 21:17:48]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   447.024414     0.087646   347.024658 -3068.675781        0.0                0.0   99.999756       99.999756
1   447.024658   100.000000   447.024658 -3068.675781        0.0                0.0    0.000000        0.000000
2   647.024658   200.000000   447.024658 -3068.675781        0.0                0.0  200.000000      100.000000
3   647.024658   132.333333   547.024658 -3068.675781        0.0                0.0  100.000000        0.000000
4   947.024658   300.000000   647.024658 -3068.675781      100.0              100.0  200.000000      100.000000
5  1647.024658   700.000000   747.024658 -3068.675781      600.0              600.0  300.000000      200.000000
6  2947.024658  1300.000000   947.024658 -3068.675781     1800.0             1800.0  200.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:48]  --------------------------------------------------------------------------------
[07/13 21:17:48]  Iteration: 88
[07/13 21:17:49]  Generator returned sat in 0.168005 secs.
[07/13 21:17:49]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:17:49]  Improved gap from 409599/4096 to 100
[07/13 21:17:49]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:17:49]  Verifer returned sat in 0.135890 secs.
[07/13 21:17:49]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   447.024170     0.087646   347.024414 -3068.675781        0.0                0.0   99.999756       99.999756
1   447.024414   100.000000   447.024414 -3068.675781        0.0                0.0    0.000000        0.000000
2   647.024414   200.000000   447.024658 -3068.675781        0.0                0.0  199.999756      100.000000
3   647.024414   132.666667   547.024414 -3068.675781        0.0                0.0  100.000000        0.000000
4   947.024414   300.000000   647.024414 -3068.675781      100.0              100.0  200.000000      100.000000
5  1647.024414   700.000000   747.024658 -3068.675781      600.0              600.0  299.999756      200.000000
6  2947.024414  1300.000000   947.024414 -3068.675781     1800.0             1800.0  200.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:49]  --------------------------------------------------------------------------------
[07/13 21:17:49]  Iteration: 89
[07/13 21:17:50]  Generator returned sat in 0.220304 secs.
[07/13 21:17:50]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:17:50]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:17:50]  Verifer returned sat in 0.091740 secs.
[07/13 21:17:50]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   447.024170     0.087402   347.024414 -3068.675781     0.000000           0.000000   99.999756       99.999756
1   447.024414   100.000000   447.024414 -3068.675781     0.000000           0.000000    0.000000        0.000000
2   647.024170   199.999756   447.024414 -3068.675781     0.000000           0.000000  199.999756       99.999756
3   647.024170   133.000000   547.024414 -3068.675781     0.000000           0.000000   99.999756       -0.000244
4   947.024170   300.000000   647.024414 -3068.675781    99.999756          99.999756  200.000000      100.000000
5  1647.024170   700.000000   747.024414 -3068.675781   599.999756         599.999756  300.000000      200.000000
6  2947.024170  1300.000000   947.024170 -3068.675781  1800.000000        1800.000000  200.000000      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:51]  --------------------------------------------------------------------------------
[07/13 21:17:51]  Iteration: 90
[07/13 21:17:52]  Generator returned sat in 0.191586 secs.
[07/13 21:17:52]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:17:52]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:17:52]  Verifer returned sat in 0.111646 secs.
[07/13 21:17:52]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   447.023926     0.087158   347.024170 -3068.675781     0.000000           0.000000   99.999756       99.999756
1   447.024170   100.000000   447.024170 -3068.675781     0.000000           0.000000    0.000000        0.000000
2   647.023926   199.999756   447.024170 -3068.675781     0.000000           0.000000  199.999756       99.999756
3   647.023926   133.333333   547.024170 -3068.675781     0.000000           0.000000   99.999756       -0.000244
4   947.023926   300.000000   647.024170 -3068.675781    99.999756          99.999756  200.000000      100.000000
5  1647.023926   700.000000   747.024170 -3068.675781   599.999756         599.999756  300.000000      200.000000
6  2947.023926  1300.000000   947.023926 -3068.675781  1799.999756        1799.999756  200.000244      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:52]  --------------------------------------------------------------------------------
[07/13 21:17:52]  Iteration: 91
[07/13 21:17:53]  Generator returned sat in 0.239130 secs.
[07/13 21:17:53]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:17:53]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:17:53]  Verifer returned sat in 0.137206 secs.
[07/13 21:17:53]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   447.023682     0.086914   249.980225 -3068.676025     0.000000           0.000000  197.043457       99.999512
1   447.024170   197.043945   447.024170 -3068.676025     0.000000           0.000000    0.000000        0.000000
2   647.023926   199.999756   447.024170 -3068.676025     0.000000           0.000000  199.999756       99.999756
3   647.023926   199.956299   647.023926 -3068.676025     0.000000           0.000000    0.000000       -0.000244
4   947.023926   300.000000   647.024170 -3068.676025    99.999756          99.999756  200.000000      100.000000
5  1647.023926   700.000000   747.024170 -3068.676025   599.999756         599.999756  300.000000      200.000000
6  2947.023926  1300.000000   947.023682 -3068.676025  1799.999756        1799.999756  200.000488      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:53]  --------------------------------------------------------------------------------
[07/13 21:17:53]  Iteration: 92
[07/13 21:17:54]  Generator returned sat in 0.218034 secs.
[07/13 21:17:55]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:17:55]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:17:55]  Verifer returned sat in 0.108165 secs.
[07/13 21:17:55]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   447.023682    0.086914   249.979980 -3068.676025     0.000000           0.000000  197.043701       99.999756
1   447.023926  197.043945   447.023926 -3068.676025     0.000000           0.000000    0.000000        0.000000
2   647.023682  199.999756   447.023926 -3068.676025     0.000000           0.000000  199.999756       99.999756
3   647.023682  133.318604   647.023682 -3068.676025     0.000000           0.000000    0.000000       -0.000244
4  1047.023438  399.999756   647.023926 -3068.676025    99.999512          99.999512  300.000000      200.000000
5  1447.023438  400.000000   747.024170 -3068.676025   499.999512         499.999512  199.999756      100.000000
6  2047.023926  600.000488   947.023926 -3068.676025  1000.000000        1000.000000  100.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:55]  --------------------------------------------------------------------------------
[07/13 21:17:55]  Iteration: 93
[07/13 21:17:56]  Generator returned sat in 0.285759 secs.
[07/13 21:17:56]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:17:56]  Improved number of small numbers from 77 to 79 out of a max of 79
[07/13 21:17:56]  Verifer returned sat in 0.114275 secs.
[07/13 21:17:56]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   447.023193    0.086426   249.979980 -3068.676514     0.000000           0.000000  197.043213       99.999268
1   447.023682  197.043701   447.023682 -3068.676514     0.000000           0.000000    0.000000       -0.000244
2   647.023438  199.999756   447.023926 -3068.676514     0.000000           0.000000  199.999512       99.999512
3   647.023438  199.978027   647.023438 -3068.676270     0.000000           0.000000    0.000000       -0.000244
4  1047.023193  399.999756   647.023682 -3068.676270    99.999512          99.999512  300.000000      200.000000
5  1447.023193  400.000000   747.024170 -3068.676270   499.999023         499.999023  200.000000      100.000488
6  2047.023682  600.000488   947.023438 -3068.676270  1000.000000        1000.000000  100.000244      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:56]  --------------------------------------------------------------------------------
[07/13 21:17:56]  Iteration: 94
[07/13 21:17:57]  Generator returned sat in 0.169271 secs.
[07/13 21:17:57]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:17:57]  Improved gap from 1/4096 to 100
[07/13 21:17:58]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:17:58]  Verifer returned sat in 0.109044 secs.
[07/13 21:17:58]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   447.023193     0.086426   347.023438 -3168.676025     0.000000           0.000000   99.999756       -0.000244
1   447.023682   100.000244   447.023682 -3168.676025     0.000000           0.000000    0.000000      -99.999756
2   747.023438   299.999756   547.023438 -3168.676025     0.000000           0.000000  200.000000      100.000000
3   747.023438   199.956787   647.023438 -3168.676025     0.000000           0.000000  100.000000        0.000000
4  1098.480225   351.456787   747.023438 -3168.676025   151.456787         151.456787  200.000000      100.000000
5  2049.936523   951.456299   847.023438 -3168.676025   902.913086         902.913086  300.000000      200.000000
6  3601.392822  1551.456299   947.023438 -3168.676025  2454.369385        2454.369385  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:17:58]  --------------------------------------------------------------------------------
[07/13 21:17:58]  Iteration: 95
[07/13 21:17:59]  Generator returned sat in 0.554022 secs.
[07/13 21:17:59]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:17:59]  Improved number of small numbers from 72 to 75 out of a max of 79
[07/13 21:17:59]  Verifer returned sat in 0.165094 secs.
[07/13 21:17:59]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   447.022949     0.086426   347.023438 -3168.676514     0.000000           0.000000   99.999512       -0.000488
1   447.023682   100.000244   447.023682 -3168.676270     0.000000           0.000000    0.000000      -99.999512
2   747.023193   299.999512   547.023193 -3168.676270     0.000000           0.000000  200.000000      100.000000
3   747.023193   199.956543   745.566895 -3168.676270     0.000000           0.000000    1.456299        0.000000
4   948.479736   201.456543   747.023438 -3168.676270     1.456299           1.456299  200.000000      100.000244
5  1649.207520   700.727783   947.023193 -3168.676270   502.184326         502.184326  200.000000      200.000000
6  2799.571411  1150.363892   947.023193 -3168.676270  1652.547852        1652.547852  200.000366      100.000366
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:00]  --------------------------------------------------------------------------------
[07/13 21:18:00]  Iteration: 96
[07/13 21:18:01]  Generator returned sat in 0.406685 secs.
[07/13 21:18:01]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:01]  Improved gap from 0 to 100
[07/13 21:18:01]  Improved number of small numbers from 51 to 80 out of a max of 80
[07/13 21:18:01]  Verifer returned sat in 0.256442 secs.
[07/13 21:18:01]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -255.859131    0.086426  -355.859131 -3168.67627     0.000000           0.000000  100.000000      100.000000
1  -255.859131    0.043213  -255.859131 -3168.67627     0.000000           0.000000    0.000000        0.000000
2  -252.815918    3.043213  -252.859131 -3168.67627     0.000000           0.000000    0.043213      -96.956787
3   144.140869  397.000000   -55.859131 -3168.67627     0.000000           0.000000  200.000000      200.000000
4   144.184082  200.000000   -55.859131 -3168.67627     0.043213           0.043213  200.000000      100.000000
5   644.184082  500.000000    44.140869 -3168.67627   300.043213         300.043213  300.000000      200.000000
6  1488.184082  844.000000   144.140869 -3168.67627  1044.043213        1044.043213  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:01]  --------------------------------------------------------------------------------
[07/13 21:18:01]  Iteration: 97
[07/13 21:18:02]  Generator returned sat in 0.175399 secs.
[07/13 21:18:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:03]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:18:03]  Verifer returned sat in 0.094585 secs.
[07/13 21:18:03]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -255.859131    0.086426  -355.859131 -3168.67627    0.000000           0.000000  100.000000      100.000000
1  -255.859131    0.043213  -255.859131 -3168.67627    0.000000           0.000000    0.000000        0.000000
2  -252.815918    3.043213  -252.859131 -3168.67627    0.000000           0.000000    0.043213      -96.956787
3   144.140869  397.000000   -55.859131 -3168.67627    0.000000           0.000000  200.000000      200.000000
4   144.184082  200.000000    -5.859131 -3168.67627    0.043213           0.043213  150.000000      100.000000
5   644.184082  500.000000    44.140869 -3168.67627  300.043213         300.043213  300.000000      200.000000
6  1238.184082  594.000000   144.140869 -3168.67627  894.043213         894.043213  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:03]  --------------------------------------------------------------------------------
[07/13 21:18:03]  Iteration: 98
[07/13 21:18:04]  Generator returned sat in 0.193381 secs.
[07/13 21:18:04]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:04]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:18:04]  Verifer returned sat in 0.103711 secs.
[07/13 21:18:04]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -255.859375     0.086426  -355.859375 -3168.676514     0.000000           0.000000  100.000000       99.999756
1  -255.859375     0.042969  -255.859375 -3168.676514     0.000000           0.000000    0.000000       -0.000244
2  -252.837646     3.021729  -252.859131 -3168.676514     0.000000           0.000000    0.021484      -96.978516
3   144.140869   397.000000   -55.859131 -3168.676514     0.000000           0.000000  200.000000      200.000000
4   144.162354   200.000000    44.140869 -3168.676514     0.021484           0.021484  100.000000      100.000000
5   944.162842   800.000488    44.140869 -3168.676514   600.021973         600.021973  300.000000      200.000000
6  2338.163330  1394.000488   144.140869 -3168.676514  1894.022461        1894.022461  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:04]  --------------------------------------------------------------------------------
[07/13 21:18:04]  Iteration: 99
[07/13 21:18:06]  Generator returned sat in 0.450678 secs.
[07/13 21:18:06]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:06]  Improved number of small numbers from 47 to 79 out of a max of 79
[07/13 21:18:06]  Verifer returned sat in 0.163963 secs.
[07/13 21:18:06]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -255.859375    0.086182  -355.859619 -3168.676514    0.000000           0.000000  100.000244       65.666504
1  -255.859375    0.042480  -255.859375 -3168.676514    0.000000           0.000000    0.000000      -34.333496
2  -121.504395  134.354980  -121.525879 -3168.676514    0.000000           0.000000    0.021484        0.021484
3   144.140625  265.666504  -121.525635 -3168.676514    0.000000           0.000000  265.666260      165.666504
4   278.495605  399.999756   -21.525879 -3168.676514    0.021484           0.021484  300.000000      200.000000
5   747.162598  468.666992    78.474121 -3168.676514  368.688477         368.688477  300.000000      200.000000
6  1147.162598  400.000000   178.474121 -3168.676514  768.688477         768.688477  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:06]  --------------------------------------------------------------------------------
[07/13 21:18:06]  Iteration: 100
[07/13 21:18:07]  Generator returned sat in 0.175648 secs.
[07/13 21:18:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:07]  Improved number of small numbers from 59 to 77 out of a max of 79
[07/13 21:18:07]  Verifer returned sat in 0.260174 secs.
[07/13 21:18:07]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -221.525879    0.085938  -421.525879 -3168.676514    0.000000           0.000000  200.000000      100.000000
1  -221.525879    0.043213  -221.525879 -3168.676514    0.000000           0.000000    0.000000        0.000000
2  -121.482910  100.042969  -121.525879 -3168.676514    0.000000           0.000000    0.042969        0.042969
3    10.807454  132.333333   -21.525879 -3168.676514    0.000000           0.000000   32.333333       32.333333
4   210.764160  200.000000   -21.525879 -3168.676514   32.290039          32.290039  200.000000      100.000000
5   710.764160  500.000000   107.474121 -3168.676514  368.688477         368.688477  234.601562      163.601562
6  1418.764160  708.000000   178.474121 -3168.676514  940.290283         940.290283  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:08]  --------------------------------------------------------------------------------
[07/13 21:18:08]  Iteration: 101
[07/13 21:18:09]  Generator returned sat in 0.183277 secs.
[07/13 21:18:09]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:09]  Improved number of small numbers from 77 to 77 out of a max of 79
[07/13 21:18:09]  Verifer returned sat in 0.105431 secs.
[07/13 21:18:09]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -221.525879     0.085938  -421.525879 -3168.676514     0.000000           0.000000  200.000000      100.000000
1  -221.525879     0.043213  -221.525879 -3168.676514     0.000000           0.000000    0.000000        0.000000
2  -121.482910   100.042969  -121.525879 -3168.676514     0.000000           0.000000    0.042969        0.042969
3    10.807454   132.333333   -21.525879 -3168.676514     0.000000           0.000000   32.333333       32.333333
4   210.764404   200.000000   -21.525879 -3168.676514    32.290283          32.290283  200.000000      100.000000
5   810.764404   600.000000   107.474121 -3168.676514   432.290283         432.290283  271.000000      200.000000
6  1868.764404  1058.000000   178.474121 -3168.676514  1390.290283        1390.290283  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:09]  --------------------------------------------------------------------------------
[07/13 21:18:09]  Iteration: 102
[07/13 21:18:10]  Generator returned sat in 0.272797 secs.
[07/13 21:18:10]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:10]  Improved gap from 0 to 100
[07/13 21:18:10]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:18:10]  Verifer returned sat in 0.120477 secs.
[07/13 21:18:10]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -221.525879     0.085938  -221.568848 -3168.676758     0.000000           0.000000    0.042969             0.0
1  -221.525879     0.021484  -221.525879 -3168.676758     0.000000           0.000000    0.000000          -100.0
2   -21.525879   200.000000  -121.525879 -3168.676758     0.000000           0.000000  100.000000             0.0
3   178.495605   300.000000   -21.525879 -3168.676758     0.021484           0.021484  200.000000           100.0
4   878.581543   700.085938   178.474121 -3168.676758   500.107422         500.107422  200.000000           200.0
5  2378.667480  1500.085938   178.474121 -3168.676758  1900.193359        1900.193359  300.000000           200.0
6  4478.753418  2100.085938   278.474121 -3168.676758  4000.279297        4000.279297  200.000000           100.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:11]  --------------------------------------------------------------------------------
[07/13 21:18:11]  Iteration: 103
[07/13 21:18:12]  Generator returned sat in 0.184785 secs.
[07/13 21:18:12]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:12]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:18:12]  Verifer returned sat in 0.101866 secs.
[07/13 21:18:12]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0  -221.526123     0.085693  -321.526123 -3168.676758     0.000000           0.000000    100.0             0.0
1  -221.526123     0.021484  -221.526123 -3168.676758     0.000000           0.000000      0.0          -100.0
2   -21.526123   200.000000  -121.526123 -3168.676758     0.000000           0.000000    100.0             0.0
3   178.495361   300.000000    78.473877 -3168.676758     0.021484           0.021484    100.0           100.0
4  1128.495361   950.000000   178.473877 -3168.676758   750.021484         750.021484    200.0           200.0
5  2403.495361  1275.000000   178.473877 -3168.676758  1925.021484        1925.021484    300.0           200.0
6  3640.995361  1237.500000   278.473877 -3168.676758  3162.521484        3162.521484    200.0           100.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:12]  --------------------------------------------------------------------------------
[07/13 21:18:12]  Iteration: 104
[07/13 21:18:13]  Generator returned sat in 0.224757 secs.
[07/13 21:18:13]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:13]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:18:13]  Verifer returned sat in 0.096532 secs.
[07/13 21:18:13]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -221.526367    0.085449  -282.526123 -3168.676758     0.000000           0.000000   60.999756             0.0
1  -221.526367    0.021240  -221.526367 -3168.676758     0.000000           0.000000    0.000000          -100.0
2   -21.526367  200.000000   -82.526123 -3168.676758     0.000000           0.000000   60.999756             0.0
3   178.495117  260.999756    78.473633 -3168.676758     0.021484           0.021484  100.000000           100.0
4   900.494629  721.999512   178.473633 -3168.676758   622.020996         622.020996  100.000000           100.0
5  1700.494629  800.000000   278.473633 -3168.676758  1322.020996        1322.020996  100.000000           100.0
6  2422.494141  721.999512   278.473633 -3168.676758  1944.020508        1944.020508  200.000000           100.0
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:14]  --------------------------------------------------------------------------------
[07/13 21:18:14]  Iteration: 105
[07/13 21:18:15]  Generator returned sat in 0.309530 secs.
[07/13 21:18:15]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:15]  Improved gap from 1556301/16384 to 100
[07/13 21:18:15]  Improved number of small numbers from 58 to 68 out of a max of 80
[07/13 21:18:15]  Verifer returned sat in 0.295670 secs.
[07/13 21:18:15]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -216.504883     0.085205  -221.526855 -3168.677002     0.000000           0.000000    5.021973        5.021729
1  -216.504883     0.010498  -216.504944 -3168.677002     0.000000           0.000000    0.000061      -94.978271
2   -21.526611   194.978333   -62.525635 -3168.677002     0.000000           0.000000   40.999023        0.000000
3   178.494873   240.999023    78.473145 -3168.677002     0.021484           0.021484  100.000244      100.000000
4   900.494385   721.999512   178.473389 -3168.677002   622.020752         622.020752  100.000244      100.000244
5  2052.950806  1152.456421   278.473389 -3168.677002  1574.477539        1574.477539  199.999878      199.999878
6  3312.677063  1259.726257   278.473389 -3168.677002  2834.203613        2834.203613  200.000061      100.000061
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:15]  --------------------------------------------------------------------------------
[07/13 21:18:15]  Iteration: 106
[07/13 21:18:17]  Generator returned sat in 0.355730 secs.
[07/13 21:18:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:17]  Improved number of small numbers from 64 to 67 out of a max of 79
[07/13 21:18:17]  Verifer returned sat in 0.254619 secs.
[07/13 21:18:17]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -216.504883     0.084961  -221.776855 -3168.677246     0.000000           0.000000    5.271973        5.021484
1  -216.504883     0.010254  -216.504944 -3168.677002     0.000000           0.000000    0.000061      -94.978271
2   -21.526611   194.978333   -62.525635 -3168.677002     0.000000           0.000000   40.999023        0.000000
3   178.494873   240.999023    78.473145 -3168.677002     0.021484           0.021484  100.000244      100.000000
4   900.494385   721.999512   178.473389 -3168.677002   622.020752         622.020752  100.000244      100.000244
5  2052.450806  1151.956421   278.473389 -3168.677002  1574.477539        1574.477539  199.499878      199.499878
6  3311.427063  1258.976257   278.473389 -3168.677002  2832.953613        2832.953613  200.000061      100.000061
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:17]  --------------------------------------------------------------------------------
[07/13 21:18:17]  Iteration: 107
[07/13 21:18:19]  Generator returned sat in 0.353247 secs.
[07/13 21:18:19]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:19]  Improved gap from 1556125/16384 to 100
[07/13 21:18:19]  Improved number of small numbers from 65 to 68 out of a max of 80
[07/13 21:18:19]  Verifer returned sat in 0.272971 secs.
[07/13 21:18:19]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -216.504883     0.084961  -221.526611 -3168.677246     0.000000           0.000000    5.021729        5.021729
1  -216.504883     0.010010  -216.504944 -3168.677246     0.000000           0.000000    0.000061      -94.978271
2   -21.526611   194.978333   -61.526611 -3168.677246     0.000000           0.000000   40.000000        0.000000
3   178.494873   240.000000    78.473145 -3168.677246     0.021484           0.021484  100.000244      100.000000
4   900.494385   721.999512   177.973389 -3168.677246   622.020508         622.020508  100.500488      100.000488
5  2052.450806  1151.956421   278.473389 -3168.677246  1574.477539        1574.477539  199.499878      199.499878
6  3310.429016  1257.978210   278.473389 -3168.677246  2831.955566        2831.955566  200.000061      100.000061
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:19]  --------------------------------------------------------------------------------
[07/13 21:18:19]  Iteration: 108
[07/13 21:18:20]  Generator returned sat in 0.262450 secs.
[07/13 21:18:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:21]  Improved number of small numbers from 64 to 67 out of a max of 79
[07/13 21:18:21]  Verifer returned sat in 0.258431 secs.
[07/13 21:18:21]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -216.504883     0.084961  -222.276855 -3168.67749     0.000000           0.000000    5.771973        5.021729
1  -216.504883     0.009766  -216.504944 -3168.67749     0.000000           0.000000    0.000061      -94.978271
2   -21.526611   194.978333   -61.526611 -3168.67749     0.000000           0.000000   40.000000        0.000000
3   178.494873   240.000000    78.472900 -3168.67749     0.021484           0.021484  100.000488      100.000000
4   900.494385   721.999512   177.973389 -3168.67749   622.020264         622.020264  100.500732      100.000732
5  2050.950806  1150.456421   278.473389 -3168.67749  1574.477539        1574.477539  197.999878      197.999878
6  3306.679016  1255.728210   278.473389 -3168.67749  2828.205566        2828.205566  200.000061      100.000061
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:21]  --------------------------------------------------------------------------------
[07/13 21:18:21]  Iteration: 109
[07/13 21:18:22]  Generator returned sat in 0.337791 secs.
[07/13 21:18:22]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:22]  Improved gap from 87/2048 to 100
[07/13 21:18:23]  Improved number of small numbers from 51 to 64 out of a max of 80
[07/13 21:18:23]  Verifer returned sat in 0.400200 secs.
[07/13 21:18:23]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   -22.026855     0.084717  -122.026611 -3268.17749     0.000000           0.000000   99.999756       99.999756
1   -22.026855     0.021240   -22.047852 -3268.17749     0.000000           0.000000    0.020996       -0.000244
2   -10.510986    11.536865   -10.553358 -3268.17749     0.000000           0.000000    0.042372      -88.484375
3   277.994629   288.526747    77.973389 -3268.17749     0.021240           0.021240  200.000000      100.000000
4   911.284749   633.290120   177.973389 -3268.17749   533.311279         533.311279  200.000081      100.000081
5  2061.741170  1150.456421   278.473389 -3268.17749  1583.767578        1583.767578  199.500203      100.000203
6  4076.952549  2015.211378   377.973389 -3268.17749  3398.979248        3398.979248  299.999912      199.999912
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:23]  --------------------------------------------------------------------------------
[07/13 21:18:23]  Iteration: 110
[07/13 21:18:24]  Generator returned sat in 0.225177 secs.
[07/13 21:18:24]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:24]  Improved gap from 0 to 100
[07/13 21:18:24]  Improved number of small numbers from 34 to 80 out of a max of 80
[07/13 21:18:24]  Verifer returned sat in 0.213601 secs.
[07/13 21:18:24]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    78.829102     0.084473    78.786865 -3168.17749     0.000000           0.000000    0.042236        0.042236
1    78.829102     0.020996    78.786865 -3168.17749     0.000000           0.000000    0.042236      -99.957764
2   478.829102   400.000000   278.786865 -3168.17749     0.042480           0.042480  199.999756      199.999756
3   478.850342   200.000000   278.786865 -3168.17749     0.063477           0.063477  200.000000      100.000000
4   980.350342   501.500000   406.786865 -3168.17749   301.563721         301.563721  271.999756      199.999756
5  2062.100342  1081.750000   577.786865 -3168.17749  1383.313477        1383.313477  101.000000      100.000000
6  3985.225342  1923.125000   578.786865 -3168.17749  3106.438721        3106.438721  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:25]  --------------------------------------------------------------------------------
[07/13 21:18:25]  Iteration: 111
[07/13 21:18:26]  Generator returned sat in 0.271801 secs.
[07/13 21:18:26]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:26]  Improved number of small numbers from 73 to 73 out of a max of 79
[07/13 21:18:26]  Verifer returned sat in 0.196598 secs.
[07/13 21:18:26]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    78.818604     0.084473    78.786865 -3168.17749     0.000000           0.000000    0.031738        0.031738
1    78.818604     0.015869    78.818604 -3168.17749     0.000000           0.000000    0.000000      -99.968262
2   478.786865   399.968262   278.786865 -3168.17749     0.000000           0.000000  200.000000      200.000000
3   478.850342   200.047607   278.882121 -3168.17749     0.015869           0.015869  199.952352      100.047607
4   980.017008   501.166667   408.151937 -3168.17749   301.563721         301.563721  270.301351      199.666423
5  2062.100342  1082.083333   577.786865 -3168.17749  1383.313477        1383.313477  101.000000      100.000000
6  3985.225342  1923.125000   578.786865 -3168.17749  3106.438721        3106.438721  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:26]  --------------------------------------------------------------------------------
[07/13 21:18:26]  Iteration: 112
[07/13 21:18:28]  Generator returned sat in 0.694862 secs.
[07/13 21:18:28]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:18:28]  Improved gap from 173/4096 to 100
[07/13 21:18:28]  Improved number of small numbers from 73 to 80 out of a max of 80
[07/13 21:18:28]  Verifer returned sat in 0.160438 secs.
[07/13 21:18:28]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   -21.181641    0.084229  -221.181396 -2868.209473     0.000000           0.000000  199.999756      199.999756
1    78.818359  299.999756  -221.181396 -2868.209473     0.000000           0.000000  299.999756      199.999756
2    78.818359    0.020996  -120.681396 -2868.209473     0.000000           0.000000  199.499756       99.999756
3   178.839844  299.500000   -21.181396 -2868.209473     0.021240           0.021240  200.000000      100.000000
4   378.860840  400.000000   178.818604 -2868.209473     0.042236           0.042236  200.000000      200.000000
5   979.360840  600.500000   178.818604 -2868.209473   600.542236         600.542236  200.000000      100.000000
6  1730.110840  750.750000   278.818604 -2868.209473  1151.292236        1151.292236  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:29]  --------------------------------------------------------------------------------
[07/13 21:18:29]  Iteration: 113
[07/13 21:18:31]  Generator returned sat in 0.917555 secs.
[07/13 21:18:31]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:18:31]  Improved number of small numbers from 57 to 79 out of a max of 79
[07/13 21:18:31]  Verifer returned sat in 0.137733 secs.
[07/13 21:18:31]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   -21.181885     0.084229  -221.181396 -2868.209717     0.000000           0.000000  199.999512      199.999512
1    78.818604   300.000000  -121.181396 -2868.209717     0.000000           0.000000  200.000000      200.000000
2    78.818604     0.041992   -21.181396 -2868.209717     0.000000           0.000000  100.000000      100.000000
3   278.776611   200.000000   -21.181396 -2868.209717    99.958008          99.958008  200.000000      100.000000
4   779.276611   500.500000   178.818604 -2868.209717   400.458008         400.458008  200.000000      200.000000
5  1730.276611   951.000000   178.818604 -2868.209717  1351.458008        1351.458008  200.000000      100.000000
6  2981.776611  1251.500000   278.818604 -2868.209717  2502.958008        2502.958008  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:31]  --------------------------------------------------------------------------------
[07/13 21:18:31]  Iteration: 114
[07/13 21:18:32]  Generator returned sat in 0.316968 secs.
[07/13 21:18:32]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:18:33]  Improved number of small numbers from 40 to 68 out of a max of 79
[07/13 21:18:33]  Verifer returned sat in 0.542436 secs.
[07/13 21:18:33]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0    12.731201     0.084229    12.689209 -2868.209961     0.000000           0.000000    0.041992        0.041992
1   312.688965   299.999756    92.689209 -2868.209961     0.000000           0.000000  219.999756      199.999756
2   312.688965     0.042236   212.689096 -2868.209961     0.000000           0.000000   99.999869       99.999756
3   533.832167   221.185185   212.689209 -2868.209961    99.957886          99.957886  221.185072      121.185072
4   967.609945   433.777778   312.689209 -2868.209961   454.920654         454.920654  200.000081      100.000081
5  1730.276611   762.666667   423.689096 -2868.209961  1117.587402        1117.587402  189.000113      100.000000
6  2981.776611  1251.500000   512.689209 -2868.209961  2269.087402        2269.087402  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:33]  --------------------------------------------------------------------------------
[07/13 21:18:33]  Iteration: 115
[07/13 21:18:35]  Generator returned sat in 0.656881 secs.
[07/13 21:18:35]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:18:35]  Improved gap from 345/16384 to 100
[07/13 21:18:35]  Improved number of small numbers from 40 to 80 out of a max of 80
[07/13 21:18:35]  Verifer returned sat in 0.231446 secs.
[07/13 21:18:35]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1630.182373    0.084229  1430.140137 -2868.209961    0.000000           0.000000  200.042236      100.042236
1  1630.182373  200.041992  1630.140137 -2868.209961    0.000000           0.000000    0.042236        0.042236
2  1730.139893   99.999756  1630.140137 -2868.209961    0.000000           0.000000   99.999756       -0.000244
3  1930.182373  300.000000  1736.140137 -2868.209961    0.042236           0.042236  194.000000      100.000000
4  1930.182373  154.500000  1830.140137 -2868.209961    0.042236           0.042236  100.000000        0.000000
5  2462.432373  532.250000  2030.140137 -2868.209961  232.292236         232.292236  200.000000      200.000000
6  2663.889893  201.500000  2030.140137 -2868.209961  432.249756         432.249756  201.500000      101.500000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:35]  --------------------------------------------------------------------------------
[07/13 21:18:35]  Iteration: 116
[07/13 21:18:37]  Generator returned sat in 0.445710 secs.
[07/13 21:18:37]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:18:37]  Improved gap from 345/16384 to 100
[07/13 21:18:37]  Improved number of small numbers from 60 to 80 out of a max of 80
[07/13 21:18:37]  Verifer returned sat in 0.160013 secs.
[07/13 21:18:37]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1830.139648    0.083984  1602.473389 -2968.209717    0.000000           0.000000  227.666260      199.999756
1  1830.139648    0.042236  1730.139893 -2968.209717    0.000000           0.000000   99.999756       99.999756
2  1830.182129  100.042236  1802.473389 -2968.209717    0.000000           0.000000   27.708740        0.042236
3  2030.182129  227.666748  1853.139893 -2968.209717    0.041992           0.041992  177.000244      100.000244
4  2407.139648  376.999756  1930.139893 -2968.209717  177.000000         177.000000  299.999756      199.999756
5  2408.182129  301.000000  2053.139893 -2968.209717  177.042236         177.042236  178.000000      101.000000
6  2607.223877  376.999756  2130.139893 -2968.209717  177.084229         177.084229  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:37]  --------------------------------------------------------------------------------
[07/13 21:18:37]  Iteration: 117
[07/13 21:18:40]  Generator returned sat in 1.214589 secs.
[07/13 21:18:40]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:18:40]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:18:40]  Verifer returned sat in 0.105554 secs.
[07/13 21:18:40]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0  1802.473389    0.083984  1551.473389 -2968.209717    0.000000           0.000000    251.0           200.0
1  1802.473389    0.041992  1702.473389 -2968.209717    0.000000           0.000000    100.0           100.0
2  2002.473389  300.000000  1802.473389 -2968.209717    0.000000           0.000000    200.0           200.0
3  2102.515381  300.000000  1802.473389 -2968.209717    0.041992           0.041992    300.0           200.0
4  2504.515381  402.000000  1902.473389 -2968.209717  302.041992         302.041992    300.0           200.0
5  2906.515381  402.000000  2002.473389 -2968.209717  604.041992         604.041992    300.0           200.0
6  3308.515381  402.000000  2102.473389 -2968.209717  906.041992         906.041992    300.0           200.0
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:40]  --------------------------------------------------------------------------------
[07/13 21:18:40]  Iteration: 118
[07/13 21:18:41]  Generator returned sat in 0.302020 secs.
[07/13 21:18:41]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:18:42]  Improved number of small numbers from 40 to 79 out of a max of 79
[07/13 21:18:42]  Verifer returned sat in 0.190286 secs.
[07/13 21:18:42]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1666.473145    0.083496  1370.306641 -2968.209717     0.000000           0.000000  296.166504           200.0
1  1666.473145    0.041992  1566.473145 -2968.209717     0.000000           0.000000  100.000000           100.0
2  1866.473145  300.000000  1666.473145 -2968.209717     0.000000           0.000000  200.000000           200.0
3  1966.515137  300.000000  1666.473145 -2968.209717     0.041992           0.041992  300.000000           200.0
4  2414.181641  447.666504  1833.473389 -2968.209717   347.708496         347.708496  232.999756           200.0
5  2906.515137  492.333496  1866.473145 -2968.209717   740.041992         740.041992  300.000000           200.0
6  3354.181885  447.666748  1966.473145 -2968.209717  1087.708740        1087.708740  300.000000           200.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:42]  --------------------------------------------------------------------------------
[07/13 21:18:42]  Iteration: 119
[07/13 21:18:44]  Generator returned sat in 1.452078 secs.
[07/13 21:18:44]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:18:45]  Improved number of small numbers from 55 to 79 out of a max of 79
[07/13 21:18:45]  Verifer returned sat in 0.156129 secs.
[07/13 21:18:45]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1567.139648    0.083252  1267.139648 -2968.209717    0.000000           0.000000  300.000000           200.0
1  1567.139648    0.041992  1367.139648 -2968.209717    0.000000           0.000000  200.000000           100.0
2  1767.139648  400.000000  1467.139648 -2968.209717    0.000000           0.000000  300.000000           200.0
3  1867.160645  400.000000  1666.473145 -2968.209717    0.020996           0.020996  200.666504           200.0
4  2067.827393  200.666748  1767.139648 -2968.209717  200.687744         200.687744  100.000000           100.0
5  2268.827393  201.000000  1866.473145 -2968.209717  300.687744         300.687744  101.666504           101.0
6  2469.494141  200.666748  1966.472900 -2968.209717  402.354492         402.354492  100.666748           100.0
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:45]  --------------------------------------------------------------------------------
[07/13 21:18:45]  Iteration: 120
[07/13 21:18:46]  Generator returned sat in 0.438446 secs.
[07/13 21:18:46]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:18:46]  Improved gap from 341/16384 to 100
[07/13 21:18:47]  Improved number of small numbers from 74 to 80 out of a max of 80
[07/13 21:18:47]  Verifer returned sat in 0.149347 secs.
[07/13 21:18:47]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1267.139648    0.083008  1167.139648 -2968.209961    0.000000           0.000000  100.000000      100.000000
1  1267.139648    0.041748  1267.139648 -2968.209961    0.000000           0.000000    0.000000        0.000000
2  1367.181152  100.041504  1367.139648 -2968.209961    0.000000           0.000000    0.041504        0.041504
3  1667.139648  300.000000  1367.139648 -2968.209961    0.000000           0.000000  300.000000      200.000000
4  2067.639648  400.500000  1567.139648 -2968.209961  400.499756         400.499756  100.000244      100.000244
5  2067.639648    1.500000  1567.139648 -2968.209961  400.499756         400.499756  100.000244        0.000244
6  2468.139648  400.500000  1667.139648 -2968.209961  600.999756         600.999756  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:47]  --------------------------------------------------------------------------------
[07/13 21:18:47]  Iteration: 121
[07/13 21:18:48]  Generator returned sat in 0.389590 secs.
[07/13 21:18:48]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:18:48]  Improved number of small numbers from 75 to 79 out of a max of 79
[07/13 21:18:48]  Verifer returned sat in 0.114609 secs.
[07/13 21:18:48]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1267.139648    0.082764  1167.139648 -2968.210205    0.000000           0.000000  100.000000      100.000000
1  1267.139648    0.041504  1267.139648 -2968.210205    0.000000           0.000000    0.000000        0.000000
2  1367.160645  100.020996  1367.139648 -2968.210205    0.000000           0.000000    0.020996        0.020996
3  1667.139404  299.999756  1367.139648 -2968.210205    0.000000           0.000000  299.999756      199.999756
4  2067.139404  400.000000  1567.139404 -2968.210205  399.999756         399.999756  100.000244      100.000000
5  2067.139404    1.500000  1567.139648 -2968.210205  399.999756         399.999756  100.000000        0.000000
6  2467.139404  400.000000  1667.139648 -2968.210205  599.999756         599.999756  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:49]  --------------------------------------------------------------------------------
[07/13 21:18:49]  Iteration: 122
[07/13 21:18:50]  Generator returned sat in 0.412791 secs.
[07/13 21:18:50]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:18:50]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:18:50]  Verifer returned sat in 0.103658 secs.
[07/13 21:18:50]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1267.139648    0.082764  1167.139648 -2968.210205    0.000000           0.000000  100.000000      100.000000
1  1267.139648    0.041504  1267.139648 -2968.210205    0.000000           0.000000    0.000000        0.000000
2  1367.160645  100.020996  1367.139648 -2968.210205    0.000000           0.000000    0.020996        0.020996
3  1367.160645    0.020996  1367.139648 -2968.210205    0.000000           0.000000    0.020996      -99.979004
4  1767.171143  400.010498  1467.139648 -2968.210205  100.031494         100.031494  200.000000      100.000000
5  1767.171143    1.500000  1591.139648 -2968.210205  100.031494         100.031494   76.000000        0.000000
6  2215.921143  448.750000  1667.139648 -2968.210205  348.781494         348.781494  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:51]  --------------------------------------------------------------------------------
[07/13 21:18:51]  Iteration: 123
[07/13 21:18:52]  Generator returned sat in 0.366794 secs.
[07/13 21:18:52]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:18:52]  Improved gap from 169/16384 to 100
[07/13 21:18:53]  Improved number of small numbers from 38 to 53 out of a max of 80
[07/13 21:18:53]  Verifer returned sat in 0.450068 secs.
[07/13 21:18:53]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1267.139648    0.082764  1167.139557 -2968.210449    0.000000           0.000000  100.000092      100.000092
1  1267.139648    0.041260  1267.139557 -2968.210449    0.000000           0.000000    0.000092        0.000092
2  1367.139557  100.000000  1267.160187 -2968.210449    0.000000           0.000000   99.979370        0.000000
3  1367.139557   99.979370  1367.139557 -2968.210449    0.000000           0.000000    0.000000     -100.000000
4  1817.129242  449.989685  1467.139557 -2968.210449   49.989746          49.989746  299.999939      199.999939
5  1817.129242  201.500000  1567.139557 -2968.210449   49.989746          49.989746  199.999939       99.999939
6  2517.837982  700.708740  1667.139648 -2968.210449  550.698486         550.698486  299.999847      199.999939
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:53]  --------------------------------------------------------------------------------
[07/13 21:18:53]  Iteration: 124
[07/13 21:18:54]  Generator returned sat in 0.364330 secs.
[07/13 21:18:54]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:18:55]  Improved number of small numbers from 43 to 79 out of a max of 79
[07/13 21:18:55]  Verifer returned sat in 0.176693 secs.
[07/13 21:18:55]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1367.139404    0.082764  1167.139648 -2968.210693    0.000000           0.000000  199.999756      199.999756
1  1367.139404    0.041016  1267.139648 -2968.210693    0.000000           0.000000   99.999756       99.999756
2  1367.139648  100.000000  1317.149658 -2968.210693    0.000000           0.000000   49.989990        0.000000
3  1367.139648   49.989502  1367.139648 -2968.210449    0.000000           0.000000    0.000000      -99.999756
4  1817.129150  449.989502  1467.139648 -2968.210449   49.989746          49.989746  299.999756      200.000000
5  1817.129150  201.500000  1567.139404 -2968.210449   49.989746          49.989746  200.000000      100.000000
6  2518.608643  701.479492  1667.139404 -2968.210449  551.469238         551.469238  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:55]  --------------------------------------------------------------------------------
[07/13 21:18:55]  Iteration: 125
[07/13 21:18:56]  Generator returned sat in 0.321910 secs.
[07/13 21:18:56]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:18:57]  Improved number of small numbers from 37 to 79 out of a max of 79
[07/13 21:18:57]  Verifer returned sat in 0.228846 secs.
[07/13 21:18:57]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   862.645996    0.082764   862.645996 -2868.210693    0.00000            0.00000    0.000000        0.000000
1  1162.645752  299.999756   962.645996 -2868.210693    0.00000            0.00000  199.999756      199.999756
2  1162.645752  199.958496   962.645996 -2868.210693    0.00000            0.00000  199.999756       99.999756
3  1464.145996  301.541260  1062.645996 -2868.210693  199.95874          199.95874  201.541260      101.541260
4  1464.145996  201.500000  1162.645996 -2868.210693  199.95874          199.95874  101.541260        1.541260
5  2267.145996  803.000000  1262.645996 -2868.210693  704.50000          704.50000  300.000000      200.000000
6  2268.687256  301.500000  1362.645996 -2868.210693  704.54126          704.54126  201.500000      101.500000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:57]  --------------------------------------------------------------------------------
[07/13 21:18:57]  Iteration: 126
[07/13 21:18:58]  Generator returned sat in 0.403762 secs.
[07/13 21:18:58]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:18:58]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:18:58]  Verifer returned sat in 0.100581 secs.
[07/13 21:18:58]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0   862.645996    0.082764   862.645996 -2868.210693    0.00000            0.00000      0.0             0.0
1  1467.187256  604.541260   962.645996 -2868.210693  304.54126          304.54126    200.0           200.0
2  1467.187256    0.041260   962.645996 -2868.210693  304.54126          304.54126    200.0           100.0
3  1867.145996  400.000000  1062.645996 -2868.210693  504.50000          504.50000    300.0           200.0
4  1867.145996  201.500000  1162.645996 -2868.210693  504.50000          504.50000    200.0           100.0
5  2267.145996  400.000000  1262.645996 -2868.210693  704.50000          704.50000    300.0           200.0
6  2268.687256  301.500000  1362.645996 -2868.210693  704.54126          704.54126    201.5           101.5
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:18:59]  --------------------------------------------------------------------------------
[07/13 21:18:59]  Iteration: 127
[07/13 21:19:00]  Generator returned sat in 0.311221 secs.
[07/13 21:19:00]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:00]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:19:00]  Verifer returned sat in 0.093719 secs.
[07/13 21:19:00]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0   862.645996    0.082764   862.645996 -2868.210693    0.000000           0.000000    0.000000        0.000000
1  1467.187012  604.541016   962.645996 -2868.210693  304.541260         304.541260  199.999756      199.999756
2  1467.187012    0.041016   962.645996 -2868.210693  304.541260         304.541260  199.999756       99.999756
3  1867.145752  400.000000  1062.645996 -2868.210693  504.499756         504.499756  300.000000      200.000000
4  1867.145752  201.500000  1162.645996 -2868.210693  504.499756         504.499756  200.000000      100.000000
5  2270.145752  403.000000  1262.645996 -2868.210693  707.499756         707.499756  300.000000      200.000000
6  2271.686768  301.500000  1362.645996 -2868.210693  707.540771         707.540771  201.500000      101.500000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:01]  --------------------------------------------------------------------------------
[07/13 21:19:01]  Iteration: 128
[07/13 21:19:02]  Generator returned sat in 0.351532 secs.
[07/13 21:19:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:02]  Improved gap from 0 to 100
[07/13 21:19:02]  Improved number of small numbers from 40 to 80 out of a max of 80
[07/13 21:19:02]  Verifer returned sat in 0.228757 secs.
[07/13 21:19:02]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0  1167.082764    0.082520  1167.082764 -2868.210938    0.000000           0.000000     0.00          -100.0
1  1667.082520  499.999756  1367.082764 -2868.210938  199.999756         199.999756   100.00           100.0
2  1667.082520    0.041260  1367.082764 -2868.210938  199.999756         199.999756   100.00             0.0
3  1967.124023  400.000000  1516.332764 -2868.210938  200.041260         200.041260   250.75           200.0
4  2067.165283  350.750000  1616.332764 -2868.210938  200.082520         200.082520   250.75           200.0
5  2067.206787  250.750000  1767.082764 -2868.210938  200.124023         200.124023   100.00           100.0
6  2468.706787  401.500000  1767.082764 -2868.210938  401.624023         401.624023   300.00           200.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:03]  --------------------------------------------------------------------------------
[07/13 21:19:03]  Iteration: 129
[07/13 21:19:04]  Generator returned sat in 0.486516 secs.
[07/13 21:19:04]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:04]  Improved gap from 200/3 to 100
[07/13 21:19:05]  Improved number of small numbers from 51 to 59 out of a max of 80
[07/13 21:19:05]  Verifer returned sat in 0.382614 secs.
[07/13 21:19:05]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1732.540039     0.082520  1732.539876 -2868.210938     0.00000            0.00000    0.000163        0.000163
1  1832.539876   100.000000  1765.873210 -2868.210938     0.00000            0.00000   66.666667        0.000000
2  2132.539876   366.666667  1832.539876 -2868.210938     0.00000            0.00000  300.000000      200.000000
3  2132.539876   299.999756  1971.690430 -2868.210938     0.00000            0.00000  160.849447      100.000000
4  2330.416260   358.725830  2032.539876 -2868.210938     0.00000            0.00000  297.876383      197.876383
5  2432.581136   400.000000  2232.539876 -2868.210938     0.04126            0.04126  200.000000      200.000000
6  3634.581136  1202.000000  2232.540039 -2868.210938  1102.04126         1102.04126  299.999837      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:05]  --------------------------------------------------------------------------------
[07/13 21:19:05]  Iteration: 130
[07/13 21:19:06]  Generator returned sat in 0.373874 secs.
[07/13 21:19:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:07]  Improved number of small numbers from 52 to 63 out of a max of 79
[07/13 21:19:07]  Verifer returned sat in 0.418619 secs.
[07/13 21:19:07]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1732.540039    0.082520  1732.540039 -2868.211182    0.000000           0.000000    0.000000       -0.000081
1  1832.539795   99.999756  1765.873210 -2868.210938    0.000000           0.000000   66.666585       -0.000081
2  2132.539876  366.666667  1832.540039 -2868.210938    0.000000           0.000000  299.999837      200.000000
3  2132.539876  299.999756  1971.690430 -2868.210938    0.000000           0.000000  160.849447      100.000000
4  2330.416016  358.725586  2032.539876 -2868.210938    0.000000           0.000000  297.876139      197.876139
5  2432.539917  400.000000  2232.539795 -2868.210938    0.000041           0.000041  200.000081      200.000000
6  2834.539917  402.000000  2232.540039 -2868.210938  402.000000         402.000000  199.999878      100.000041
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:07]  --------------------------------------------------------------------------------
[07/13 21:19:07]  Iteration: 131
[07/13 21:19:09]  Generator returned sat in 0.412691 secs.
[07/13 21:19:09]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:09]  Improved gap from 169/4096 to 100
[07/13 21:19:09]  Improved number of small numbers from 55 to 80 out of a max of 80
[07/13 21:19:09]  Verifer returned sat in 0.191531 secs.
[07/13 21:19:09]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1732.540039    0.082275  1732.539795 -2868.210938    0.00000            0.00000    0.000244        0.000244
1  1832.539795  100.000000  1732.539795 -2868.210938    0.00000            0.00000  100.000000        0.000000
2  2032.539795  300.000000  1932.539795 -2868.210938    0.00000            0.00000  100.000000      100.000000
3  2032.539795   49.000000  1932.539795 -2868.210938    0.00000            0.00000  100.000000        0.000000
4  2330.581055  398.000000  2032.539795 -2868.210938    0.04126            0.04126  298.000000      198.000000
5  2730.539795  400.000000  2232.539795 -2868.210938  298.00000          298.00000  200.000000      200.000000
6  3132.539795  402.000000  2232.540039 -2868.210938  600.00000          600.00000  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:09]  --------------------------------------------------------------------------------
[07/13 21:19:09]  Iteration: 132
[07/13 21:19:11]  Generator returned sat in 0.368508 secs.
[07/13 21:19:11]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:11]  Improved number of small numbers from 77 to 79 out of a max of 79
[07/13 21:19:11]  Verifer returned sat in 0.112426 secs.
[07/13 21:19:11]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1732.540039    0.082031  1732.539795 -2868.211182    0.000000           0.000000    0.000244        0.000244
1  1832.539795  100.000000  1732.539795 -2868.211182    0.000000           0.000000  100.000000        0.000000
2  2032.539795  300.000000  1833.539551 -2868.211182    0.000000           0.000000  199.000244      100.000000
3  2032.539795  199.000000  1932.539795 -2868.211182    0.000000           0.000000  100.000000        0.000000
4  2330.581055  398.000000  2032.539795 -2868.211182    0.041260           0.041260  298.000000      198.000000
5  2730.539551  400.000000  2232.539551 -2868.211182  297.999756         297.999756  200.000244      200.000000
6  3132.539551  402.000000  2232.539795 -2868.211182  599.999756         599.999756  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:11]  --------------------------------------------------------------------------------
[07/13 21:19:11]  Iteration: 133
[07/13 21:19:13]  Generator returned sat in 0.286901 secs.
[07/13 21:19:13]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:13]  Improved gap from 21/512 to 100
[07/13 21:19:13]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:19:13]  Verifer returned sat in 0.122553 secs.
[07/13 21:19:13]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1816.649170    0.082031  1732.539795 -2868.211182    0.000000           0.000000   84.109375       84.109375
1  1816.649170   84.109375  1816.608154 -2868.211182    0.000000           0.000000    0.041016      -15.890625
2  2032.539795  215.931641  1832.539795 -2868.211182    0.000000           0.000000  200.000000      100.000000
3  2032.539795   75.000000  1932.539795 -2868.211182    0.000000           0.000000  100.000000        0.000000
4  2082.539795  150.000000  2032.539795 -2868.211182    0.000000           0.000000   50.000000      -50.000000
5  2382.498779  300.000000  2232.539795 -2868.211182   49.958984          49.958984  100.000000      100.000000
6  3284.498779  902.000000  2232.539795 -2868.211182  751.958984         751.958984  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:13]  --------------------------------------------------------------------------------
[07/13 21:19:13]  Iteration: 134
[07/13 21:19:15]  Generator returned sat in 0.309221 secs.
[07/13 21:19:15]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:15]  Improved gap from 0 to 100
[07/13 21:19:15]  Improved number of small numbers from 31 to 80 out of a max of 80
[07/13 21:19:15]  Verifer returned sat in 0.252417 secs.
[07/13 21:19:15]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2132.529297    0.081787  2032.508545 -3168.180176    0.000000           0.000000  100.020752      100.020752
1  2132.529297  100.020508  2132.508545 -3168.180176    0.000000           0.000000    0.020752        0.020752
2  2432.508545  300.000000  2232.467773 -3168.180176    0.000000           0.000000  200.040771      200.000000
3  2432.508545  200.020264  2232.508789 -3168.180176    0.000000           0.000000  199.999756      100.000000
4  2432.529053  200.020264  2432.488525 -3168.180176    0.000000           0.000000    0.040527        0.020508
5  2632.529053  200.020264  2432.508789 -3168.180176    0.020264           0.020264  200.000000      100.000244
6  3134.610840  502.081787  2532.508789 -3168.180176  302.102295         302.102295  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:15]  --------------------------------------------------------------------------------
[07/13 21:19:15]  Iteration: 135
[07/13 21:19:17]  Generator returned sat in 0.456836 secs.
[07/13 21:19:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:17]  Improved gap from 335/8192 to 100
[07/13 21:19:17]  Improved number of small numbers from 41 to 80 out of a max of 80
[07/13 21:19:17]  Verifer returned sat in 0.183401 secs.
[07/13 21:19:17]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1401.388672    0.081787  1401.347412 -3168.180176    0.000000           0.000000    0.041260        0.041260
1  1401.388672    0.020508  1401.347412 -3168.180176    0.000000           0.000000    0.041260      -99.958740
2  1601.367920  200.020508  1601.347412 -3168.180176    0.000000           0.000000    0.020508        0.020508
3  1901.347412  300.000000  1601.347412 -3168.180176    0.000000           0.000000  300.000000      200.000000
4  1901.347412  300.000000  1701.347656 -3168.180176    0.000000           0.000000  199.999756      100.000000
5  2001.367920  300.000000  1801.347412 -3168.180176    0.020264           0.020264  200.000244      100.000244
6  2753.367920  752.000000  1901.347412 -3168.180176  552.020508         552.020508  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:17]  --------------------------------------------------------------------------------
[07/13 21:19:17]  Iteration: 136
[07/13 21:19:19]  Generator returned sat in 0.703782 secs.
[07/13 21:19:19]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:19]  Improved gap from 335/8192 to 100
[07/13 21:19:20]  Improved number of small numbers from 47 to 80 out of a max of 80
[07/13 21:19:20]  Verifer returned sat in 0.198621 secs.
[07/13 21:19:20]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1501.367676     0.081787  1401.347412 -3168.180176     0.000000           0.000000  100.020264      100.020264
1  1501.367676     0.020508  1501.347168 -3168.180176     0.000000           0.000000    0.020508        0.020264
2  1501.367676     0.020264  1501.347412 -3168.180176     0.000000           0.000000    0.020264      -99.979736
3  1801.388184   300.020508  1701.347412 -3168.180176     0.040771           0.040771  100.000000      100.000000
4  2553.408691   752.020508  1725.347168 -3168.180176   552.061523         552.061523  276.000000      199.999756
5  3643.429199  1090.020508  1901.347412 -3168.180176  1542.081787        1542.081787  200.000000      200.000000
6  5335.449707  1692.020508  1901.347412 -3168.180176  3234.102051        3234.102051  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:20]  --------------------------------------------------------------------------------
[07/13 21:19:20]  Iteration: 137
[07/13 21:19:22]  Generator returned sat in 0.426189 secs.
[07/13 21:19:22]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:22]  Improved number of small numbers from 70 to 73 out of a max of 79
[07/13 21:19:22]  Verifer returned sat in 0.232887 secs.
[07/13 21:19:22]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1501.367676    0.081543  1301.347412 -3168.18042     0.000000           0.000000  200.020264      100.020264
1  1501.367676    0.020264  1501.347168 -3168.18042     0.000000           0.000000    0.020508        0.020264
2  1501.367676    0.020264  1501.347412 -3168.18042     0.000000           0.000000    0.020264      -99.979736
3  1951.408691  450.041016  1701.347412 -3168.18042   150.061279         150.061279  100.000000      100.000000
4  2553.408691  602.000000  1701.347412 -3168.18042   552.061279         552.061279  300.000000      200.000000
5  2855.409058  302.000366  1901.347412 -3168.18042   852.061279         852.061279  102.000366      102.000366
6  3457.409058  602.000000  1901.347412 -3168.18042  1356.061523        1356.061523  200.000122      100.000122
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:22]  --------------------------------------------------------------------------------
[07/13 21:19:22]  Iteration: 138
[07/13 21:19:24]  Generator returned sat in 0.317473 secs.
[07/13 21:19:24]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:24]  Improved gap from 0 to 100
[07/13 21:19:24]  Improved number of small numbers from 33 to 48 out of a max of 80
[07/13 21:19:24]  Verifer returned sat in 0.637168 secs.
[07/13 21:19:24]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1801.352539     0.081543  1701.352295 -3468.185374     0.000000           0.000000  100.000244      100.000173
1  1801.352539     0.020020  1801.342234 -3468.185374     0.000000           0.000000    0.010305        0.000173
2  1801.352539     0.005127  1801.352366 -3468.185374     0.000000           0.000000    0.000173      -99.999827
3  2201.352366   400.000000  2001.352366 -3468.185374     0.000000           0.000000  200.000000      200.000000
4  2201.357432   200.000000  2101.352366 -3468.185374     0.005066           0.005066  100.000000      100.000000
5  2953.372629   752.015198  2101.352366 -3468.185374   652.020020         652.020020  200.000244      100.000244
6  4533.395426  1580.022797  2201.352539 -3468.185374  2032.043213        2032.043213  299.999674      199.999847
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:25]  --------------------------------------------------------------------------------
[07/13 21:19:25]  Iteration: 139
[07/13 21:19:26]  Generator returned sat in 0.342344 secs.
[07/13 21:19:26]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:27]  Improved number of small numbers from 24 to 44 out of a max of 79
[07/13 21:19:27]  Verifer returned sat in 0.593119 secs.
[07/13 21:19:27]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1801.372559     0.081543  1601.372559 -3468.185374     0.000000           0.000000  200.000000      199.999807
1  1801.372559     0.020508  1601.372751 -3468.185374     0.000000           0.000000  199.999807       99.999807
2  1801.372559     0.020264  1801.352366 -3468.185374     0.000000           0.000000    0.020193       -0.000193
3  1901.372751   100.020386  1901.331980 -3468.185374     0.000000           0.000000    0.040771        0.000000
4  2101.393137   200.040771  1967.991103 -3468.185374     0.020386           0.020386  133.381649      100.000000
5  2953.381821   851.988684  2001.372751 -3468.185374   652.009277         652.009277  299.999792      199.999792
6  4533.395426  1580.013605  2201.372559 -3468.185374  2132.022705        2132.022705  200.000162      199.999969
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:27]  --------------------------------------------------------------------------------
[07/13 21:19:27]  Iteration: 140
[07/13 21:19:29]  Generator returned sat in 0.745543 secs.
[07/13 21:19:29]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:29]  Verifer returned unsat in 0.014010 secs.
[07/13 21:19:29]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:29]  --------------------------------------------------------------------------------
[07/13 21:19:29]  Iteration: 141
[07/13 21:19:31]  Generator returned sat in 0.325957 secs.
[07/13 21:19:31]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:31]  Improved number of small numbers from 36 to 79 out of a max of 79
[07/13 21:19:31]  Verifer returned sat in 0.194651 secs.
[07/13 21:19:31]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1801.372559    0.081299  1501.372803 -3468.185547   0.000000           0.000000  299.999756      199.999756
1  1801.372559    0.020508  1601.372803 -3468.185547   0.000000           0.000000  199.999756       99.999756
2  1801.372559    0.020264  1801.352539 -3468.185547   0.000000           0.000000    0.020020       -0.000244
3  1901.352539  100.000000  1801.372803 -3468.185547   0.000000           0.000000   99.979736       -0.020264
4  2001.372803  200.000000  1901.372803 -3468.185547   0.000000           0.000000  100.000000        0.000000
5  2301.393066  400.000000  2101.372803 -3468.185547   0.020264           0.020264  200.000000      200.000000
6  2303.413330  202.000000  2101.372803 -3468.185547   0.040527           0.040527  202.000000      102.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:31]  --------------------------------------------------------------------------------
[07/13 21:19:31]  Iteration: 142
[07/13 21:19:33]  Generator returned sat in 0.419260 secs.
[07/13 21:19:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:34]  Improved number of small numbers from 43 to 68 out of a max of 79
[07/13 21:19:34]  Verifer returned sat in 0.437171 secs.
[07/13 21:19:34]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  1837.090332    0.081055  1537.090332 -3503.903076   0.000000           0.000000  300.000000      200.000000
1  1837.090332    0.020508  1637.090332 -3503.903076   0.000000           0.000000  200.000000      100.000000
2  1837.090332    0.010254  1837.079997 -3503.903076   0.000000           0.000000    0.010335        0.000000
3  1903.413330   66.333333  1903.403198 -3503.903076   0.000000           0.000000    0.010132      -33.677002
4  2036.069865  132.666667  2036.049601 -3503.903076   0.000000           0.000000    0.020264       -1.020467
5  2301.393066  265.333333  2037.090332 -3503.903076   0.010132           0.010132  264.292603      164.292603
6  2437.130615  400.000000  2137.090332 -3503.903076   0.040283           0.040283  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:34]  --------------------------------------------------------------------------------
[07/13 21:19:34]  Iteration: 143
[07/13 21:19:36]  Generator returned sat in 1.090529 secs.
[07/13 21:19:36]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:36]  Verifer returned unsat in 0.009303 secs.
[07/13 21:19:36]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:19:36]  --------------------------------------------------------------------------------
[07/13 21:19:36]  Iteration: 144
[07/13 21:19:42]  Generator returned sat in 4.170270 secs.
[07/13 21:19:42]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:19:42]  Improved gap from 83/4096 to 100
[07/13 21:19:42]  Improved number of small numbers from 43 to 80 out of a max of 80
[07/13 21:19:42]  Verifer returned sat in 0.194330 secs.
[07/13 21:19:42]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2097.883301    0.081055  1897.883301 -3764.696289   0.000000           0.000000  200.000000       200.00000
1  2097.883301    0.020020  1997.883301 -3764.696289   0.000000           0.000000  100.000000       100.00000
2  2097.883301    0.020020  2097.863281 -3764.696289   0.000000           0.000000    0.020020         0.00000
3  2196.863281   99.000000  2097.883301 -3764.696289   0.000000           0.000000   98.979980        -1.02002
4  2397.903564  300.000000  2247.383301 -3764.696289   0.020264           0.020264  150.500000       100.00000
5  2497.923828  250.500000  2397.373291 -3764.696289   0.040527           0.040527  100.510010       100.00000
6  2697.944092  300.510010  2397.883545 -3764.696289   0.060791           0.060791  299.999756       200.00000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:42]  --------------------------------------------------------------------------------
[07/13 21:19:42]  Iteration: 145
[07/13 21:19:44]  Generator returned sat in 0.408568 secs.
[07/13 21:19:44]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:19:44]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:19:44]  Verifer returned sat in 0.097450 secs.
[07/13 21:19:44]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2097.883301    0.081055  1896.883301 -3764.696289   0.000000           0.000000  201.000000       200.00000
1  2097.883301    0.020020  1997.883301 -3764.696289   0.000000           0.000000  100.000000       100.00000
2  2097.883301    0.020020  2097.863281 -3764.696289   0.000000           0.000000    0.020020         0.00000
3  2196.863281   99.000000  2097.883301 -3764.696289   0.000000           0.000000   98.979980        -1.02002
4  2397.903564  300.000000  2247.383301 -3764.696289   0.020264           0.020264  150.500000       100.00000
5  2497.923828  250.500000  2397.373291 -3764.696289   0.040527           0.040527  100.510010       100.00000
6  2697.944092  300.510010  2397.883545 -3764.696289   0.060791           0.060791  299.999756       200.00000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:44]  --------------------------------------------------------------------------------
[07/13 21:19:44]  Iteration: 146
[07/13 21:19:46]  Generator returned sat in 0.423703 secs.
[07/13 21:19:46]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:19:46]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:19:46]  Verifer returned sat in 0.094499 secs.
[07/13 21:19:46]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2097.883301    0.081055  1895.883301 -3764.696533   0.000000           0.000000  202.000000      200.000000
1  2097.883301    0.019775  1997.883301 -3764.696533   0.000000           0.000000  100.000000      100.000000
2  2097.883301    0.019775  2097.863037 -3764.696533   0.000000           0.000000    0.020264        0.000000
3  2196.863037   99.000000  2097.883301 -3764.696533   0.000000           0.000000   98.979736       -1.020264
4  2397.903320  300.000000  2247.383301 -3764.696533   0.020020           0.020020  150.500000      100.000000
5  2497.923584  250.500000  2397.373047 -3764.696533   0.040283           0.040283  100.510254      100.000000
6  2697.943848  300.510010  2397.883301 -3764.696533   0.060791           0.060791  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:46]  --------------------------------------------------------------------------------
[07/13 21:19:46]  Iteration: 147
[07/13 21:19:50]  Generator returned sat in 1.711406 secs.
[07/13 21:19:50]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:19:50]  Improved gap from 23999/240 to 100
[07/13 21:19:50]  Improved number of small numbers from 70 to 76 out of a max of 80
[07/13 21:19:50]  Verifer returned sat in 0.209419 secs.
[07/13 21:19:50]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2097.883301    0.080566  1897.879150 -3764.697021   0.000000           0.000000  200.004150      200.000000
1  2097.883301  200.002686  1997.883057 -3764.697021   0.000000           0.000000  100.000244      100.000000
2  2097.883301   99.998779  2097.882051 -3764.697021   0.000000           0.000000    0.001250        0.000000
3  2097.883301    0.001221  2097.883301 -3764.697021   0.000000           0.000000    0.000000     -100.000000
4  2399.890137  302.006836  2297.883301 -3764.697021   2.006836           2.006836  100.000000      100.000000
5  2399.890137    0.010000  2297.883301 -3764.697021   2.006836           2.006836  100.000000        0.000000
6  2601.898301  302.006875  2397.883301 -3764.697021   2.008125           2.008125  202.006875      102.006875
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:50]  --------------------------------------------------------------------------------
[07/13 21:19:50]  Iteration: 148
[07/13 21:19:52]  Generator returned sat in 0.477146 secs.
[07/13 21:19:52]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:19:52]  Improved gap from 1/800 to 100
[07/13 21:19:52]  Improved number of small numbers from 58 to 72 out of a max of 80
[07/13 21:19:52]  Verifer returned sat in 0.398308 secs.
[07/13 21:19:52]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2097.883057    0.080566  2097.883057 -3464.710693   0.000000           0.000000    0.000000        0.000000
1  2232.220947  134.337891  2197.882812 -3464.710693   0.000000           0.000000   34.338135       34.337891
2  2232.220947    0.001250  2232.219723 -3464.710693   0.000000           0.000000    0.001224      -65.662109
3  2297.885557   65.665833  2297.883057 -3464.710693   0.000000           0.000000    0.002500      -99.997500
4  2632.217223  334.332917  2497.882812 -3464.710693   0.001250           0.001250  134.333161      134.332917
5  2632.217223    0.010000  2497.883057 -3464.710693   0.001250           0.001250  134.332917       34.332917
6  2897.885742  400.000000  2597.883057 -3464.710693   0.002686           0.002686  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:53]  --------------------------------------------------------------------------------
[07/13 21:19:53]  Iteration: 149
[07/13 21:19:56]  Generator returned sat in 2.070193 secs.
[07/13 21:19:56]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:19:56]  Improved number of small numbers from 54 to 69 out of a max of 79
[07/13 21:19:56]  Verifer returned sat in 0.294704 secs.
[07/13 21:19:56]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2197.903076    0.080078  2097.883057 -3464.711182     0.000000           0.000000  100.020020      100.020020
1  2197.903076    0.020020  2197.883057 -3464.711182     0.000000           0.000000    0.020020        0.020020
2  2297.923340  100.040283  2297.883057 -3464.711182     0.000000           0.000000    0.040283        0.040283
3  2297.923340    0.020081  2297.883057 -3464.711182     0.000000           0.000000    0.040283      -99.959717
4  2599.923218  302.040161  2397.883057 -3464.711182     0.000000           0.000000  202.040161      102.040161
5  3506.003540  906.080322  2497.883057 -3464.711182   808.120361         808.120361  200.000122      100.000122
6  4060.043701  554.040161  2597.883057 -3464.711182  1162.160645        1162.160645  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:57]  --------------------------------------------------------------------------------
[07/13 21:19:57]  Iteration: 150
[07/13 21:19:59]  Generator returned sat in 0.554988 secs.
[07/13 21:19:59]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:19:59]  Improved number of small numbers from 69 to 69 out of a max of 79
[07/13 21:19:59]  Verifer returned sat in 0.195758 secs.
[07/13 21:19:59]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2197.903076    0.080078  2097.396647 -3464.711182     0.000000           0.000000  100.506429      100.020020
1  2197.903076    0.020020  2197.883057 -3464.711182     0.000000           0.000000    0.020020        0.020020
2  2297.923340  100.040283  2297.883057 -3464.711182     0.000000           0.000000    0.040283        0.040283
3  2297.923340    0.030273  2297.883057 -3464.711182     0.000000           0.000000    0.040283      -99.959717
4  2600.173218  302.290161  2397.883057 -3464.711182     0.000000           0.000000  202.290161      102.290161
5  3506.253540  906.080322  2497.883057 -3464.711182   808.120361         808.120361  200.250122      100.250122
6  4060.293701  554.040161  2597.883057 -3464.711182  1162.410645        1162.410645  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:19:59]  --------------------------------------------------------------------------------
[07/13 21:19:59]  Iteration: 151
[07/13 21:20:01]  Generator returned sat in 0.694625 secs.
[07/13 21:20:01]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:20:01]  Improved number of small numbers from 44 to 79 out of a max of 79
[07/13 21:20:01]  Verifer returned sat in 0.155113 secs.
[07/13 21:20:01]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2297.923096    0.079590  2187.883057 -3464.711426   0.000000           0.000000  110.040039      110.040039
1  2297.923096    0.020020  2287.883057 -3464.711426   0.000000           0.000000   10.040039       10.040039
2  2297.923096   10.039795  2297.922852 -3464.711426   0.000000           0.000000    0.000244      -89.959961
3  2641.923096  344.000000  2405.883057 -3464.711426   0.019775           0.019775  236.020264      154.020264
4  2687.922852  282.000000  2587.883057 -3464.711426   0.039795           0.039795  100.000000      100.000000
5  2879.942871  292.000000  2587.883301 -3464.711426   0.059814           0.059814  291.999756      192.000000
6  2879.942871  291.980225  2687.883301 -3464.711426   0.059814           0.059814  191.999756       92.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:02]  --------------------------------------------------------------------------------
[07/13 21:20:02]  Iteration: 152
[07/13 21:20:04]  Generator returned sat in 0.724079 secs.
[07/13 21:20:04]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:20:04]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:20:04]  Verifer returned sat in 0.110457 secs.
[07/13 21:20:04]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2297.923096    0.079590  2183.883057 -3464.711426   0.000000           0.000000  114.040039      110.040039
1  2297.923096    0.020020  2287.883057 -3464.711426   0.000000           0.000000   10.040039       10.040039
2  2297.923096   10.039795  2297.922852 -3464.711426   0.000000           0.000000    0.000244      -89.959961
3  2641.923096  344.000000  2404.883057 -3464.711426   0.019775           0.019775  237.020264      154.020264
4  2687.922852  283.000000  2587.883057 -3464.711426   0.039795           0.039795  100.000000      100.000000
5  2879.942871  292.000000  2587.883301 -3464.711426   0.059814           0.059814  291.999756      192.000000
6  2879.942871  291.480225  2687.883301 -3464.711426   0.059814           0.059814  191.999756       92.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:04]  --------------------------------------------------------------------------------
[07/13 21:20:04]  Iteration: 153
[07/13 21:20:06]  Generator returned sat in 0.557464 secs.
[07/13 21:20:06]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:20:06]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:20:06]  Verifer returned sat in 0.094820 secs.
[07/13 21:20:06]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2297.922852    0.079590  2182.883057 -3464.711426   0.000000           0.000000  115.039795      110.039795
1  2297.922852    0.019775  2287.883057 -3464.711426   0.000000           0.000000   10.039795       10.039795
2  2297.922852   10.039795  2297.922852 -3464.711426   0.000000           0.000000    0.000000      -89.960205
3  2641.922852  344.000000  2404.883057 -3464.711426   0.019531           0.019531  237.020264      154.020264
4  2687.922607  283.000000  2587.883057 -3464.711426   0.039551           0.039551  100.000000      100.000000
5  2879.942871  291.500000  2587.883301 -3464.711426   0.559814           0.559814  291.499756      191.500000
6  2879.942871  290.730225  2687.883057 -3464.711426   0.559814           0.559814  191.500000       91.500000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:06]  --------------------------------------------------------------------------------
[07/13 21:20:06]  Iteration: 154
[07/13 21:20:09]  Generator returned sat in 0.940995 secs.
[07/13 21:20:09]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:20:09]  Improved gap from 2 to 100
[07/13 21:20:09]  Improved number of small numbers from 35 to 80 out of a max of 80
[07/13 21:20:09]  Verifer returned sat in 0.203981 secs.
[07/13 21:20:09]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2150.567871    0.079102  2150.528076 -3464.71167    0.000000           0.000000    0.039795        0.000000
1  2150.567871    0.019775  2150.567871 -3464.71167    0.000000           0.000000    0.000000     -100.000000
2  2285.254395  134.686523  2285.234619 -3464.71167    0.000000           0.000000    0.019775      -65.313477
3  2389.783691  104.549072  2389.743896 -3464.71167    0.000000           0.000000    0.039795      -60.784180
4  2750.587402  360.823730  2450.567871 -3464.71167    0.019775           0.019775  299.999756      199.999756
5  2750.587402    0.500000  2550.575928 -3464.71167    0.019775           0.019775  199.991699       99.999756
6  3150.599365  400.011963  2650.567871 -3464.71167  200.031494         200.031494  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:09]  --------------------------------------------------------------------------------
[07/13 21:20:09]  Iteration: 155
[07/13 21:20:11]  Generator returned sat in 0.658123 secs.
[07/13 21:20:11]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:20:12]  Improved number of small numbers from 71 to 79 out of a max of 79
[07/13 21:20:12]  Verifer returned sat in 0.116366 secs.
[07/13 21:20:12]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2150.567871    0.079102  2150.558105 -3464.711914    0.000000           0.000000    0.009766        0.000000
1  2150.567871    0.004883  2150.567871 -3464.711914    0.000000           0.000000    0.000000     -100.000000
2  2285.254395  134.686523  2285.234375 -3464.711914    0.000000           0.000000    0.020020      -65.313477
3  2389.783447  104.549072  2369.052002 -3464.711670    0.000000           0.000000   20.731445      -60.784180
4  2750.587158  381.515381  2450.567627 -3464.711670    0.019775           0.019775  299.999756      199.999756
5  2750.587158    0.500000  2550.575684 -3464.711670    0.019775           0.019775  199.991699       99.999756
6  3150.349121  399.761963  2650.567627 -3464.711670  200.011475         200.011475  299.770020      199.770020
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:12]  --------------------------------------------------------------------------------
[07/13 21:20:12]  Iteration: 156
[07/13 21:20:15]  Generator returned sat in 2.143112 secs.
[07/13 21:20:15]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:20:15]  Improved gap from 331831/4096 to 100
[07/13 21:20:16]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:20:16]  Verifer returned sat in 0.123849 secs.
[07/13 21:20:16]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2349.583984    0.079102  2249.583984 -3563.728027    0.000000           0.000000  100.000000      100.000000
1  2349.583984    0.004883  2349.583984 -3563.728027    0.000000           0.000000    0.000000        0.000000
2  2349.585205    0.001221  2349.583984 -3563.728027    0.000000           0.000000    0.001221      -99.998779
3  2449.586426  100.002441  2449.583984 -3563.728027    0.000000           0.000000    0.002441      -99.997559
4  2800.088867  350.503662  2549.583984 -3563.728027    0.001221           0.001221  250.503662      150.503662
5  2800.088867  200.500000  2649.583984 -3563.728027    0.001221           0.001221  150.503662       50.503662
6  3401.338867  601.250000  2749.583984 -3563.728027  351.754883         351.754883  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:16]  --------------------------------------------------------------------------------
[07/13 21:20:16]  Iteration: 157
[07/13 21:20:18]  Generator returned sat in 0.564341 secs.
[07/13 21:20:18]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:20:18]  Improved number of small numbers from 52 to 79 out of a max of 79
[07/13 21:20:18]  Verifer returned sat in 0.145115 secs.
[07/13 21:20:18]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2337.583740    0.078857  2249.583740 -3563.728271    0.000000           0.000000   88.000000       88.000000
1  2337.583740    0.004639  2337.583496 -3563.728027    0.000000           0.000000    0.000244      -11.999756
2  2349.916260   12.332764  2349.915283 -3563.728027    0.000000           0.000000    0.000977      -99.667236
3  2449.584229   99.668945  2449.583740 -3563.728027    0.000000           0.000000    0.000488      -99.999268
4  2800.087646  350.503418  2549.583496 -3563.728027    0.000488           0.000488  250.503662      150.503662
5  2800.087646  212.500000  2649.583740 -3563.728027    0.000488           0.000488  150.503418       50.503662
6  3419.506104  619.418457  2749.583740 -3563.728027  369.922607         369.922607  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:18]  --------------------------------------------------------------------------------
[07/13 21:20:18]  Iteration: 158
[07/13 21:20:20]  Generator returned sat in 0.625486 secs.
[07/13 21:20:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:20:20]  Improved gap from 12 to 100
[07/13 21:20:21]  Improved number of small numbers from 61 to 80 out of a max of 80
[07/13 21:20:21]  Verifer returned sat in 0.155272 secs.
[07/13 21:20:21]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2337.583496    0.078857  2200.586182 -3563.728027    0.000000           0.000000  136.997314       88.000000
1  2337.583496    0.004395  2250.083496 -3563.728027    0.000000           0.000000   87.500000      -12.000000
2  2349.916260   99.832764  2349.916260 -3563.728027    0.000000           0.000000    0.000000      -99.667236
3  2449.584229   99.667969  2449.583740 -3563.728027    0.000000           0.000000    0.000488      -99.999268
4  2849.583740  399.999512  2549.583496 -3563.728027    0.000488           0.000488  299.999756      199.999756
5  2849.583984  300.000000  2649.583496 -3563.728027    0.000488           0.000488  200.000000      100.000000
6  3600.751221  751.167236  2749.583740 -3563.728027  551.167969         551.167969  299.999512      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:21]  --------------------------------------------------------------------------------
[07/13 21:20:21]  Iteration: 159
[07/13 21:20:23]  Generator returned sat in 0.486834 secs.
[07/13 21:20:23]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:20:23]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:20:23]  Verifer returned sat in 0.109023 secs.
[07/13 21:20:23]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2337.583496    0.078857  2201.086182 -3563.728027    0.000000           0.000000  136.497314       88.000000
1  2337.583496    0.004395  2250.083496 -3563.728027    0.000000           0.000000   87.500000      -12.000000
2  2349.916260   99.832764  2349.916260 -3563.728027    0.000000           0.000000    0.000000      -99.667236
3  2449.584229   99.667969  2449.583740 -3563.728027    0.000000           0.000000    0.000488      -99.999268
4  2849.583740  399.999512  2549.583496 -3563.728027    0.000488           0.000488  299.999756      199.999756
5  2849.583984  300.000000  2649.583496 -3563.728027    0.000488           0.000488  200.000000      100.000000
6  3601.251221  751.667236  2749.583740 -3563.728027  551.667725         551.667725  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:23]  --------------------------------------------------------------------------------
[07/13 21:20:23]  Iteration: 160
[07/13 21:20:25]  Generator returned sat in 0.723787 secs.
[07/13 21:20:25]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:20:26]  Improved number of small numbers from 44 to 79 out of a max of 79
[07/13 21:20:26]  Verifer returned sat in 0.169450 secs.
[07/13 21:20:26]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2296.082520     0.078369  2199.080566 -3513.225342        0.0                0.0   97.001953       97.001953
1  2296.082520     0.004395  2296.080566 -3513.225342        0.0                0.0    0.001953       -2.998047
2  2303.580566     7.500000  2303.580566 -3513.225342        0.0                0.0    0.000000      -95.500000
3  2399.080566    95.500000  2399.080566 -3513.225342        0.0                0.0    0.000000     -100.000000
4  2792.080566   393.000000  2499.080566 -3513.225342       93.0               93.0  200.000000      100.000000
5  2992.080566   400.000000  2599.080566 -3513.225342       93.0               93.0  300.000000      200.000000
6  4089.580566  1097.500000  2699.080566 -3513.225342     1090.5             1090.5  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:26]  --------------------------------------------------------------------------------
[07/13 21:20:26]  Iteration: 161
[07/13 21:20:28]  Generator returned sat in 0.494722 secs.
[07/13 21:20:28]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:20:28]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:20:28]  Verifer returned sat in 0.098010 secs.
[07/13 21:20:28]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2296.082520     0.078369  2199.080566 -3513.225342        0.0                0.0   97.001953       97.001953
1  2296.082520     0.004395  2296.080566 -3513.225342        0.0                0.0    0.001953       -2.998047
2  2303.330566     7.250000  2303.330566 -3513.225342        0.0                0.0    0.000000      -95.750000
3  2399.080566    95.750000  2399.080566 -3513.225342        0.0                0.0    0.000000     -100.000000
4  2792.080566   393.000000  2499.080566 -3513.225342       93.0               93.0  200.000000      100.000000
5  2992.080566   400.000000  2599.330566 -3513.225342       93.0               93.0  299.750000      200.000000
6  4089.580566  1097.500000  2699.080566 -3513.225342     1090.5             1090.5  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:28]  --------------------------------------------------------------------------------
[07/13 21:20:28]  Iteration: 162
[07/13 21:20:31]  Generator returned sat in 1.744157 secs.
[07/13 21:20:31]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:20:32]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:20:32]  Verifer returned sat in 0.102736 secs.
[07/13 21:20:32]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2296.082520     0.078125  2199.080566 -3513.225342        0.0                0.0   97.001953       97.001953
1  2296.082520     0.004150  2296.080566 -3513.225342        0.0                0.0    0.001953       -2.998047
2  2303.330566     7.250000  2303.330566 -3513.225342        0.0                0.0    0.000000      -95.750000
3  2399.080566    95.750000  2399.080566 -3513.225342        0.0                0.0    0.000000     -100.000000
4  2791.580566   392.500000  2499.080566 -3513.225342       92.5               92.5  200.000000      100.000000
5  2991.330566   399.750000  2599.330566 -3513.225342       92.5               92.5  299.500000      199.750000
6  4087.830566  1096.500000  2699.080566 -3513.225342     1090.5             1090.5  298.250000      198.250000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:32]  --------------------------------------------------------------------------------
[07/13 21:20:32]  Iteration: 163
[07/13 21:20:34]  Generator returned sat in 0.668942 secs.
[07/13 21:20:34]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:20:34]  Improved gap from 383/4 to 100
[07/13 21:20:34]  Improved number of small numbers from 49 to 80 out of a max of 80
[07/13 21:20:34]  Verifer returned sat in 0.198562 secs.
[07/13 21:20:34]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2092.580078     0.077637  1944.041504 -3513.225342     0.000000           0.000000  148.538574      100.038818
1  2092.580078     0.039062  2092.541260 -3513.225342     0.000000           0.000000    0.038818        0.038818
2  2092.580078     0.038818  2092.541504 -3513.225342     0.000000           0.000000    0.038574      -99.961182
3  2392.580078   300.000000  2192.541504 -3513.225342     0.038818           0.038818  199.999756      100.000000
4  2791.580078   399.000000  2292.541260 -3513.225342   299.038818         299.038818  200.000000      100.000000
5  2991.580078   400.000000  2392.541504 -3513.225342   299.038818         299.038818  299.999756      200.000000
6  4092.080078  1100.500000  2492.541504 -3513.225342  1299.539062        1299.539062  299.999512      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:34]  --------------------------------------------------------------------------------
[07/13 21:20:34]  Iteration: 164
[07/13 21:20:39]  Generator returned sat in 2.838550 secs.
[07/13 21:20:39]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:20:39]  Improved gap from 159/4096 to 100
[07/13 21:20:39]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:20:39]  Verifer returned sat in 0.135208 secs.
[07/13 21:20:39]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0  2092.541260    0.077637   1992.54126 -3513.225342     0.000000           0.000000    100.0           100.0
1  2092.541260    0.038818   1992.54126 -3513.225342     0.000000           0.000000    100.0             0.0
2  2292.541260  300.000000   2184.54126 -3513.225342     0.000000           0.000000    108.0           100.0
3  2292.541260   49.500000   2192.54126 -3513.225342     0.000000           0.000000    100.0             0.0
4  2492.580078  300.000000   2292.54126 -3513.225342     0.038818           0.038818    200.0           100.0
5  3093.080078  600.500000   2492.54126 -3513.225342   400.538818         400.538818    200.0           200.0
6  3855.830078  762.750000   2492.54126 -3513.225342  1063.288818        1063.288818    300.0           200.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:39]  --------------------------------------------------------------------------------
[07/13 21:20:39]  Iteration: 165
[07/13 21:20:41]  Generator returned sat in 0.760262 secs.
[07/13 21:20:42]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:20:42]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:20:42]  Verifer returned sat in 0.103215 secs.
[07/13 21:20:42]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2092.541260    0.077637   1992.04126 -3513.225342     0.000000           0.000000  100.500000      100.000000
1  2092.541260    0.038818   1992.54126 -3513.225342     0.000000           0.000000  100.000000        0.000000
2  2292.541260  300.000000   2184.54126 -3513.225342     0.000000           0.000000  108.000000      100.000000
3  2292.541260   49.500000   2192.54126 -3513.225342     0.000000           0.000000  100.000000        0.000000
4  2492.579834  300.000000   2292.54126 -3513.225342     0.038574           0.038574  200.000000      100.000000
5  3093.079834  600.500000   2492.54126 -3513.225342   400.538818         400.538818  199.999756      199.999756
6  3855.829834  762.750000   2492.54126 -3513.225342  1063.288818        1063.288818  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:42]  --------------------------------------------------------------------------------
[07/13 21:20:42]  Iteration: 166
[07/13 21:20:44]  Generator returned sat in 0.719417 secs.
[07/13 21:20:44]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:20:44]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:20:44]  Verifer returned sat in 0.128476 secs.
[07/13 21:20:44]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2092.541260    0.077637  1992.041260 -3513.225342     0.000000           0.000000  100.500000      100.000244
1  2092.541260    0.038818  1992.541016 -3513.225342     0.000000           0.000000  100.000244        0.000244
2  2292.541016  300.000000  2184.541016 -3513.225342     0.000000           0.000000  108.000000      100.000000
3  2292.541016   49.750000  2192.541260 -3513.225342     0.000000           0.000000   99.999756        0.000000
4  2492.579590  300.000000  2292.541016 -3513.225342     0.038330           0.038330  200.000244      100.000244
5  3093.079590  600.500000  2492.541016 -3513.225342   400.538818         400.538818  199.999756      199.999756
6  3855.829590  762.750000  2492.541260 -3513.225342  1063.288818        1063.288818  299.999512      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:45]  --------------------------------------------------------------------------------
[07/13 21:20:45]  Iteration: 167
[07/13 21:20:47]  Generator returned sat in 0.923756 secs.
[07/13 21:20:47]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:20:47]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:20:47]  Verifer returned sat in 0.104113 secs.
[07/13 21:20:47]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2092.541016    0.077393  1992.041260 -3513.225342     0.000000           0.000000  100.499756      100.000000
1  2092.541016    0.038818  1992.541016 -3513.225342     0.000000           0.000000  100.000000        0.000000
2  2292.541016  300.000000  2184.540771 -3513.225342     0.000000           0.000000  108.000244      100.000000
3  2292.541016   49.000000  2192.541260 -3513.225342     0.000000           0.000000   99.999756        0.000000
4  2492.579346  300.000000  2292.541016 -3513.225342     0.038086           0.038086  200.000244      100.000244
5  3093.079346  600.500000  2492.540771 -3513.225342   400.538818         400.538818  199.999756      199.999512
6  3855.829346  762.750000  2492.541016 -3513.225342  1063.288818        1063.288818  299.999512      199.999512
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:47]  --------------------------------------------------------------------------------
[07/13 21:20:47]  Iteration: 168
[07/13 21:20:50]  Generator returned sat in 0.597439 secs.
[07/13 21:20:50]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:20:50]  Improved number of small numbers from 71 to 71 out of a max of 79
[07/13 21:20:50]  Verifer returned sat in 0.201143 secs.
[07/13 21:20:50]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2092.540771    0.077148  1992.041260 -3513.225342     0.000000           0.000000  100.499512      100.000000
1  2092.540771    0.038574  1993.028483 -3513.225342     0.000000           0.000000   99.512288        0.000000
2  2292.541016  299.512533  2184.540771 -3513.225342     0.000000           0.000000  108.000244      100.000244
3  2292.541016   49.000000  2192.541260 -3513.225342     0.000000           0.000000   99.999756        0.000244
4  2493.060547  300.500000  2292.541016 -3513.225342     0.019287           0.019287  200.500244      100.500488
5  3093.079346  600.018799  2492.540771 -3513.225342   400.538818         400.538818  199.999756      199.999756
6  3855.588745  762.509399  2492.540771 -3513.225342  1063.288574        1063.288574  299.759399      199.759399
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:50]  --------------------------------------------------------------------------------
[07/13 21:20:50]  Iteration: 169
[07/13 21:20:52]  Generator returned sat in 0.748836 secs.
[07/13 21:20:52]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:20:53]  Improved gap from 16699/8192 to 100
[07/13 21:20:53]  Improved number of small numbers from 42 to 80 out of a max of 80
[07/13 21:20:53]  Verifer returned sat in 0.188098 secs.
[07/13 21:20:53]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2168.569336    0.076660  1959.261719 -3513.225342    0.000000           0.000000  209.307617      200.000000
1  2168.569336    0.009766  2068.569336 -3513.225342    0.000000           0.000000  100.000000      100.000000
2  2168.569336    0.009766  2168.569336 -3513.225342    0.000000           0.000000    0.000000        0.000000
3  2168.588623    0.019287  2168.569336 -3513.225342    0.000000           0.000000    0.019287      -99.980713
4  2484.578857  316.000000  2368.569336 -3513.225342    0.009521           0.009521  116.000000      116.000000
5  3093.078857  608.500000  2368.569336 -3513.225342  424.509521         424.509521  300.000000      200.000000
6  3697.828857  604.750000  2468.569580 -3513.225342  965.259521         965.259521  263.999756      164.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:53]  --------------------------------------------------------------------------------
[07/13 21:20:53]  Iteration: 170
[07/13 21:20:56]  Generator returned sat in 1.130576 secs.
[07/13 21:20:56]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:20:56]  Improved number of small numbers from 51 to 59 out of a max of 79
[07/13 21:20:56]  Verifer returned sat in 0.299948 secs.
[07/13 21:20:56]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2146.586426    0.076416  1946.586372 -3513.225586    0.000000           0.000000  200.000054      200.000000
1  2146.586426    0.019043  2046.586426 -3513.225586    0.000000           0.000000  100.000000      100.000000
2  2146.586426    0.019287  2146.586372 -3513.225586    0.000000           0.000000    0.000054        0.000000
3  2168.607666   22.021294  2168.569336 -3513.225586    0.000000           0.000000    0.038330      -77.978760
4  2546.605537  378.017036  2346.586372 -3513.225586    0.019165           0.019165  200.000000      199.999946
5  2546.605537    0.500000  2397.264395 -3513.225586    0.019165           0.019165  149.321976       99.999946
6  2924.622572  378.017036  2446.586426 -3513.225586  278.036133         278.036133  200.000014      100.000014
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:20:56]  --------------------------------------------------------------------------------
[07/13 21:20:56]  Iteration: 171
[07/13 21:20:59]  Generator returned sat in 1.243044 secs.
[07/13 21:20:59]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:20:59]  Improved number of small numbers from 54 to 57 out of a max of 79
[07/13 21:20:59]  Verifer returned sat in 0.343950 secs.
[07/13 21:20:59]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  2146.586426    0.076172  1946.586372 -3513.225586    0.000000           0.000000  200.000054      200.000000
1  2146.586426    0.018799  2046.586426 -3513.225586    0.000000           0.000000  100.000000      100.000000
2  2146.586426    0.019043  2146.586372 -3513.225586    0.000000           0.000000    0.000054        0.000000
3  2168.607666   22.021294  2168.569336 -3513.225586    0.000000           0.000000    0.038330      -77.978760
4  2546.605537  378.017036  2346.586372 -3513.225586    0.019165           0.019165  200.000000      199.999946
5  2546.605537  189.508518  2397.264395 -3513.225586    0.019165           0.019165  149.321976       99.999946
6  3302.639608  756.034071  2446.586426 -3513.225586  556.053223         556.053223  299.999959      199.999959
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:00]  --------------------------------------------------------------------------------
[07/13 21:21:00]  Iteration: 172
[07/13 21:21:10]  Generator returned sat in 9.109973 secs.
[07/13 21:21:10]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:21:11]  Improved gap from 0 to 100
[07/13 21:21:11]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:21:11]  Verifer returned sat in 0.192067 secs.
[07/13 21:21:11]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -448.999512     0.076172  -449.037598 -3513.22583        0.0                0.0    0.038086        0.038086
1  -448.999512     0.038086  -449.037598 -3513.22583        0.0                0.0    0.038086      -99.961914
2  -348.999512   100.038086  -349.037598 -3513.22583        0.0                0.0    0.038086      -99.961914
3  -249.037598   100.000000  -249.037598 -3513.22583        0.0                0.0    0.000000     -100.000000
4   250.962402   500.000000  -149.037598 -3513.22583      200.0              200.0  200.000000      100.000000
5  1450.962402  1200.000000   -45.037598 -3513.22583     1200.0             1200.0  296.000000      200.000000
6  3706.962402  2256.000000   150.962402 -3513.22583     3356.0             3356.0  200.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:11]  --------------------------------------------------------------------------------
[07/13 21:21:11]  Iteration: 173
[07/13 21:21:13]  Generator returned sat in 0.646972 secs.
[07/13 21:21:13]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:13]  Improved gap from 51239/1024 to 100
[07/13 21:21:13]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:21:13]  Verifer returned sat in 0.131607 secs.
[07/13 21:21:13]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -449.037842     0.075928  -549.037842 -3413.22583     0.000000           0.000000  100.000000      100.000000
1  -449.037842     0.019043  -499.075928 -3413.22583     0.000000           0.000000   50.038086        0.000000
2  -348.999756   150.076172  -349.037842 -3413.22583     0.000000           0.000000    0.038086        0.038086
3  -249.037842   100.000000  -349.037842 -3413.22583     0.000000           0.000000  100.000000        0.000000
4   251.462158   500.500000  -149.037842 -3413.22583   200.500000         200.500000  200.000000      200.000000
5  1527.269287  1275.807129   -49.037842 -3413.22583  1376.307129        1376.307129  200.000000      200.000000
6  3890.979980  2363.710693   -49.037842 -3413.22583  3640.017822        3640.017822  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:14]  --------------------------------------------------------------------------------
[07/13 21:21:14]  Iteration: 174
[07/13 21:21:17]  Generator returned sat in 1.929464 secs.
[07/13 21:21:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:21:18]  Improved number of small numbers from 58 to 71 out of a max of 79
[07/13 21:21:18]  Verifer returned sat in 0.348934 secs.
[07/13 21:21:18]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0  -488.653809     0.075684  -688.653564 -3413.226074     0.000000           0.000000  199.999756       99.999756
1  -488.653809     0.037842  -588.653564 -3413.226074     0.000000           0.000000   99.999756       -0.000244
2  -348.999756   239.653809  -478.653809 -3413.226074     0.000000           0.000000  129.654053       39.653809
3  -348.999756   129.654053  -349.000000 -3413.226074     0.000000           0.000000    0.000244      -60.346191
4   251.461914   600.461670  -188.653564 -3413.226074   240.115479         240.115479  200.000000      200.000000
5  1352.154419  1100.692505   -88.653809 -3413.226074  1340.807861        1340.807861  100.000366      100.000122
6  3198.193176  1846.038757   -49.037842 -3413.226074  3086.846680        3086.846680  160.384338      100.000061
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:18]  --------------------------------------------------------------------------------
[07/13 21:21:18]  Iteration: 175
[07/13 21:21:20]  Generator returned sat in 0.809074 secs.
[07/13 21:21:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:21:20]  Improved gap from 155/8192 to 100
[07/13 21:21:21]  Improved number of small numbers from 32 to 78 out of a max of 80
[07/13 21:21:21]  Verifer returned sat in 0.447019 secs.
[07/13 21:21:21]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1596.968506    0.075439 -1697.006592 -2304.873291     0.000000           0.000000  100.038086      100.038086
1 -1596.968506  100.037842 -1597.006592 -2304.873291     0.000000           0.000000    0.038086        0.038086
2 -1497.006592  100.000000 -1597.006348 -2304.873291     0.000000           0.000000   99.999756        0.000000
3 -1497.006592   49.518921 -1497.006592 -2304.873291     0.000000           0.000000    0.000000     -100.000000
4 -1196.968750  300.037842 -1397.006348 -2304.873291     0.037598           0.037598  200.000000      100.000244
5  -646.911865  550.056885 -1297.006592 -2304.873291   350.094727         350.094727  300.000000      200.000000
6   328.173340  975.085205 -1197.006592 -2304.873291  1325.179688        1325.179688  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:21]  --------------------------------------------------------------------------------
[07/13 21:21:21]  Iteration: 176
[07/13 21:21:23]  Generator returned sat in 0.775166 secs.
[07/13 21:21:23]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:23]  Improved gap from 0 to 100
[07/13 21:21:24]  Improved number of small numbers from 28 to 46 out of a max of 80
[07/13 21:21:24]  Verifer returned sat in 0.569015 secs.
[07/13 21:21:24]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1647.552734    0.075439 -1747.552744 -2104.930767    0.000000           0.000000  100.000010      100.000010
1 -1647.552734    0.037842 -1647.552744 -2104.930767    0.000000           0.000000    0.000010        0.000010
2 -1547.552744  100.000000 -1647.552734 -2104.930767    0.000000           0.000000   99.999990        0.000000
3 -1547.552744   49.768860 -1547.552744 -2104.930767    0.000000           0.000000    0.000000     -100.000000
4 -1247.515024  300.037720 -1447.552744 -2104.930767    0.037598           0.037598  200.000122      100.000122
5  -847.477305  400.037720 -1347.552734 -2104.930767  200.075439         200.075439  299.999990      200.000000
6  -297.439585  550.037720 -1247.552734 -2104.930767  650.113281         650.113281  299.999868      199.999878
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:24]  --------------------------------------------------------------------------------
[07/13 21:21:24]  Iteration: 177
[07/13 21:21:26]  Generator returned sat in 0.630089 secs.
[07/13 21:21:27]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:27]  Improved gap from 309/16384 to 100
[07/13 21:21:27]  Improved number of small numbers from 32 to 49 out of a max of 80
[07/13 21:21:27]  Verifer returned sat in 0.528173 secs.
[07/13 21:21:27]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1947.533936     0.075195 -1947.571604 -2103.279888     0.000000           0.000000    0.037668        0.037668
1 -1947.533936     0.018799 -1947.571533 -2103.279888     0.000000           0.000000    0.037598      -99.962332
2 -1547.571777   399.999756 -1747.571604 -2103.279888     0.000000           0.000000  199.999827      199.999827
3 -1547.552744   200.000000 -1747.533884 -2103.279888     0.018860           0.018860  199.962280      100.000000
4 -1047.533884   500.018860 -1647.571533 -2103.279888   400.037598         400.037598  200.000051      100.000122
5   102.503835  1150.037720 -1547.571604 -2103.279888  1350.075439        1350.075439  300.000000      200.000000
6  2502.579275  2400.075439 -1447.571533 -2103.279888  3650.150879        3650.150879  299.999929      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:27]  --------------------------------------------------------------------------------
[07/13 21:21:27]  Iteration: 178
[07/13 21:21:30]  Generator returned sat in 1.185620 secs.
[07/13 21:21:30]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:30]  Improved number of small numbers from 31 to 79 out of a max of 79
[07/13 21:21:30]  Verifer returned sat in 0.165358 secs.
[07/13 21:21:30]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1346.071777    0.074951 -1646.071533 -2504.779785    0.000000           0.000000  299.999756      199.999756
1 -1346.071777    0.018555 -1546.071533 -2504.779785    0.000000           0.000000  199.999756       99.999756
2 -1046.090332  400.000000 -1446.071533 -2504.779785   99.981201          99.981201  300.000000      200.000000
3 -1046.081055  300.000000 -1246.071533 -2504.779785   99.990479          99.990479  100.000000      100.000000
4  -846.081055  200.000000 -1146.071533 -2504.779785  199.990479         199.990479  100.000000      100.000000
5  -646.081055  200.000000 -1046.071533 -2504.779785  299.990479         299.990479  100.000000      100.000000
6  -446.081055  200.000000 -1046.071533 -2504.779785  399.990479         399.990479  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:31]  --------------------------------------------------------------------------------
[07/13 21:21:31]  Iteration: 179
[07/13 21:21:34]  Generator returned sat in 1.509127 secs.
[07/13 21:21:34]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:34]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:21:34]  Verifer returned sat in 0.104041 secs.
[07/13 21:21:34]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1446.062256     0.074951 -1546.071533 -2504.779785     0.000000           0.000000  100.009277      100.009277
1 -1446.062256     0.018555 -1446.071533 -2504.779785     0.000000           0.000000    0.009277        0.009277
2 -1146.071533   300.000000 -1346.071533 -2504.779785     0.000000           0.000000  200.000000      200.000000
3 -1146.062256   200.000000 -1346.071533 -2504.779785     0.009277           0.009277  200.000000      100.000000
4  -746.062256   400.000000 -1209.071533 -2504.779785   300.009277         300.009277  163.000000      100.000000
5   -27.562256   718.500000 -1046.071533 -2504.779785   918.509277         918.509277  100.000000      100.000000
6  1200.187744  1227.750000 -1046.071533 -2504.779785  2046.259277        2046.259277  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:34]  --------------------------------------------------------------------------------
[07/13 21:21:34]  Iteration: 180
[07/13 21:21:36]  Generator returned sat in 0.604862 secs.
[07/13 21:21:37]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:37]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:21:37]  Verifer returned sat in 0.096538 secs.
[07/13 21:21:37]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1446.062500    0.074707 -1646.071777 -2504.779785     0.000000           0.000000  200.009277      100.009277
1 -1446.062500    0.018311 -1546.071777 -2504.779785     0.000000           0.000000  100.009277        0.009277
2 -1146.071777  400.000000 -1396.071777 -2504.779785     0.000000           0.000000  250.000000      200.000000
3 -1146.062500  250.000000 -1346.071777 -2504.779785     0.009277           0.009277  200.000000      100.000000
4  -746.062500  400.000000 -1146.071777 -2504.779785   300.009277         300.009277  100.000000      100.000000
5  -146.062500  600.000000 -1146.071777 -2504.779785   800.009277         800.009277  200.000000      100.000000
6   578.937500  725.000000 -1046.071777 -2504.779785  1425.009277        1425.009277  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:37]  --------------------------------------------------------------------------------
[07/13 21:21:37]  Iteration: 181
[07/13 21:21:42]  Generator returned sat in 3.372721 secs.
[07/13 21:21:42]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:42]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:21:42]  Verifer returned sat in 0.100669 secs.
[07/13 21:21:42]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1446.062744    0.074463 -1646.071777 -2504.780029     0.000000           0.000000  200.009033      100.009033
1 -1446.062744    0.018066 -1546.071777 -2504.780029     0.000000           0.000000  100.009033        0.009033
2 -1146.072021  399.999756 -1346.071777 -2504.780029     0.000000           0.000000  199.999756      199.999756
3 -1146.062500  200.000000 -1346.071777 -2504.780029     0.009277           0.009277  200.000000      100.000000
4  -746.062500  400.000000 -1146.071777 -2504.780029   300.009033         300.009033  100.000244      100.000244
5  -146.062500  600.000000 -1126.071777 -2504.780029   800.009277         800.009277  180.000000      100.000000
6   373.937500  520.000000 -1046.071777 -2504.780029  1220.009277        1220.009277  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:42]  --------------------------------------------------------------------------------
[07/13 21:21:42]  Iteration: 182
[07/13 21:21:45]  Generator returned sat in 0.985458 secs.
[07/13 21:21:45]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:45]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:21:45]  Verifer returned sat in 0.117877 secs.
[07/13 21:21:45]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1446.062744    0.074463 -1546.071777 -2504.780029     0.000000           0.000000  100.009033      100.009033
1 -1446.062744    0.018066 -1446.071777 -2504.780029     0.000000           0.000000    0.009033        0.009033
2 -1146.071777  300.000000 -1346.071777 -2504.780029     0.000000           0.000000  200.000000      200.000000
3 -1146.062744  200.000000 -1346.071777 -2504.780029     0.009033           0.009033  200.000000      100.000000
4  -746.062744  400.000000 -1210.071777 -2504.780029   300.009033         300.009033  164.000000      100.000000
5  -192.062744  554.000000 -1134.071777 -2504.780029   754.009033         754.009033  188.000000      100.000000
6   402.937256  595.000000 -1046.071777 -2504.780029  1249.009033        1249.009033  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:45]  --------------------------------------------------------------------------------
[07/13 21:21:45]  Iteration: 183
[07/13 21:21:48]  Generator returned sat in 0.735144 secs.
[07/13 21:21:48]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:48]  Improved number of small numbers from 62 to 79 out of a max of 79
[07/13 21:21:48]  Verifer returned sat in 0.157592 secs.
[07/13 21:21:48]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1446.062744     0.074219 -1546.071777 -2504.780273     0.000000           0.000000  100.009033      100.009033
1 -1446.062744     0.017578 -1446.071777 -2504.780273     0.000000           0.000000    0.009033        0.009033
2 -1146.072021   299.999756 -1346.071777 -2504.780273     0.000000           0.000000  199.999756      199.999756
3 -1146.067383   200.000000 -1346.071777 -2504.780273     0.004395           0.004395  200.000000      100.000000
4  -646.067383   500.000000 -1210.071777 -2504.780273   300.009033         300.009033  263.995361      199.995361
5   207.932617   854.000000 -1134.071777 -2504.780273  1054.004639        1054.004639  287.999756      199.999756
6  1379.932617  1172.000000 -1046.071777 -2504.780273  2126.004639        2126.004639  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:48]  --------------------------------------------------------------------------------
[07/13 21:21:48]  Iteration: 184
[07/13 21:21:51]  Generator returned sat in 0.885576 secs.
[07/13 21:21:51]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:51]  Improved gap from 19/1024 to 100
[07/13 21:21:51]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:21:51]  Verifer returned sat in 0.137326 secs.
[07/13 21:21:51]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1246.067383    0.074219 -1346.067383 -2504.780273     0.000000           0.000000  100.000000      100.000000
1 -1246.067383    0.018555 -1346.067383 -2504.780273     0.000000           0.000000  100.000000        0.000000
2 -1146.030273  200.037109 -1146.067383 -2504.780273     0.000000           0.000000    0.037109        0.037109
3  -946.048828  200.000000 -1046.067383 -2504.780273     0.018555           0.018555  100.000000      100.000000
4  -646.067383  300.000000  -946.067383 -2504.780273   100.000000         100.000000  200.000000      200.000000
5  -196.067383  450.000000  -846.067383 -2504.780273   550.000000         550.000000  100.000000      100.000000
6   478.932617  675.000000  -846.067383 -2504.780273  1025.000000        1025.000000  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:51]  --------------------------------------------------------------------------------
[07/13 21:21:51]  Iteration: 185
[07/13 21:21:54]  Generator returned sat in 1.147507 secs.
[07/13 21:21:54]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:55]  Improved number of small numbers from 73 to 79 out of a max of 79
[07/13 21:21:55]  Verifer returned sat in 0.107522 secs.
[07/13 21:21:55]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -1146.067383    0.073730 -1346.067383 -2504.780762    0.000000           0.000000  200.000000      200.000000
1 -1146.067383    0.002441 -1346.067383 -2504.780762    0.000000           0.000000  200.000000      100.000000
2  -946.067627  399.999756 -1246.067383 -2504.780762    0.000000           0.000000  299.999756      199.999756
3  -846.067627  399.999756 -1096.317383 -2504.780762    0.000000           0.000000  250.249756      199.999756
4  -846.064941  250.250000  -946.067383 -2504.780762    0.002441           0.002441  100.000000      100.000000
5  -846.064941    0.010000  -846.067383 -2504.780762    0.002441           0.002441    0.000000        0.000000
6  -445.564941  400.500000  -846.067383 -2504.780762  200.502441         200.502441  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:55]  --------------------------------------------------------------------------------
[07/13 21:21:55]  Iteration: 186
[07/13 21:21:59]  Generator returned sat in 2.362228 secs.
[07/13 21:21:59]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:21:59]  Improved gap from 151/8192 to 100
[07/13 21:21:59]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:21:59]  Verifer returned sat in 0.147866 secs.
[07/13 21:21:59]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -5149.491211     0.073730 -5249.528076 -2504.780762      0.000              0.000  100.036865      100.036865
1 -5149.491211     0.036865 -5149.528076 -2504.780762      0.000              0.000    0.036865        0.036865
2 -5049.528076   100.000000 -5149.528076 -2504.780762      0.000              0.000  100.000000        0.000000
3 -4749.528076   400.000000 -5049.528076 -2504.780762      0.000              0.000  300.000000      200.000000
4 -4349.028076   400.500000 -4849.528076 -2504.780762    400.500            400.500  100.000000      100.000000
5 -3448.278076   900.750000 -4749.528076 -2504.780762   1201.250           1201.250  100.000000      100.000000
6 -1697.153076  1751.125000 -4749.528076 -2504.780762   2752.375           2752.375  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:21:59]  --------------------------------------------------------------------------------
[07/13 21:21:59]  Iteration: 187
[07/13 21:22:02]  Generator returned sat in 1.247182 secs.
[07/13 21:22:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:22:03]  Improved number of small numbers from 59 to 65 out of a max of 79
[07/13 21:22:03]  Verifer returned sat in 0.316149 secs.
[07/13 21:22:03]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -5149.491455     0.073486 -5249.528076 -2504.781006     0.000000           0.000000  100.036621      100.036621
1 -5149.491455     0.036377 -5149.528076 -2504.781006     0.000000           0.000000    0.036621        0.036621
2 -5049.528320    99.999756 -5149.528076 -2504.780762     0.000000           0.000000   99.999756        0.000000
3 -4927.305926   222.222150 -5049.528076 -2504.780762     0.000000           0.000000  122.222150       22.222394
4 -4415.694851   511.611075 -4949.528076 -2504.780762   333.833252         333.833252  199.999973      100.000217
5 -3448.278239   967.416612 -4849.528076 -2504.780762  1201.249756        1201.249756  200.000081      100.000326
6 -1697.153320  1751.124919 -4749.528320 -2504.780762  2752.375000        2752.375000  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:03]  --------------------------------------------------------------------------------
[07/13 21:22:03]  Iteration: 188
[07/13 21:22:06]  Generator returned sat in 0.945596 secs.
[07/13 21:22:06]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:22:06]  Improved gap from 149/16384 to 100
[07/13 21:22:06]  Improved number of small numbers from 33 to 80 out of a max of 80
[07/13 21:22:06]  Verifer returned sat in 0.198487 secs.
[07/13 21:22:06]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -5315.553711    0.073242 -5515.553467 -2504.780762    0.000000           0.000000  199.999756       99.999756
1 -5315.553711    0.036377 -5415.535400 -2504.780762    0.000000           0.000000   99.981689       -0.000244
2 -5215.553711  199.981689 -5315.553467 -2504.780762    0.000000           0.000000   99.999756       -0.000244
3 -5015.535156  300.000000 -5115.553711 -2504.780762    0.018311           0.018311  100.000244      100.000000
4 -4615.535400  399.999756 -5115.553467 -2504.780762  200.018311         200.018311  299.999756      199.999756
5 -4615.535400  299.981934 -5015.553467 -2504.780762  200.018311         200.018311  199.999756       99.999756
6 -3865.044434  750.490967 -4915.553467 -2504.780762  750.509033         750.509033  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:06]  --------------------------------------------------------------------------------
[07/13 21:22:06]  Iteration: 189
[07/13 21:22:09]  Generator returned sat in 0.973341 secs.
[07/13 21:22:09]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:22:09]  Improved number of small numbers from 75 to 79 out of a max of 79
[07/13 21:22:09]  Verifer returned sat in 0.110358 secs.
[07/13 21:22:09]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -5315.544189    0.073242 -5465.544434 -2504.780762    0.000000           0.000000  150.000244      100.009521
1 -5315.544189    0.036377 -5315.553711 -2504.780762    0.000000           0.000000    0.009521        0.009521
2 -5215.553955   99.999756 -5315.553711 -2504.780762    0.000000           0.000000   99.999756       -0.000244
3 -5015.535400  300.000000 -5115.553711 -2504.780762    0.018311           0.018311  100.000000      100.000000
4 -4665.544678  349.990723 -5115.553711 -2504.780762  200.018311         200.018311  249.990723      149.990723
5 -4665.544678  200.000000 -5015.553711 -2504.780762  200.018311         200.018311  149.990723       49.990723
6 -3865.044678  800.500000 -4915.553711 -2504.780762  750.509033         750.509033  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:09]  --------------------------------------------------------------------------------
[07/13 21:22:09]  Iteration: 190
[07/13 21:22:14]  Generator returned sat in 2.490407 secs.
[07/13 21:22:14]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:14]  Improved gap from 0 to 100
[07/13 21:22:14]  Improved number of small numbers from 51 to 80 out of a max of 80
[07/13 21:22:14]  Verifer returned sat in 0.158733 secs.
[07/13 21:22:14]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0 -5215.503906    0.072998 -5315.503906 -2504.780762    0.000000           0.000000    100.0           100.0
1 -5215.503906    0.036621 -5215.503906 -2504.780762    0.000000           0.000000      0.0             0.0
2 -5115.503906  100.000000 -5135.503906 -2504.780762    0.000000           0.000000     20.0             0.0
3 -5115.503906   20.000000 -5115.503906 -2504.780762    0.000000           0.000000      0.0          -100.0
4 -4715.503906  400.000000 -5015.503906 -2504.780762    0.000000           0.000000    300.0           200.0
5 -4615.467285  400.000000 -4815.503906 -2504.780762    0.036621           0.036621    200.0           200.0
6 -3695.467285  920.000000 -4815.503906 -2504.780762  920.036621         920.036621    200.0           100.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:14]  --------------------------------------------------------------------------------
[07/13 21:22:14]  Iteration: 191
[07/13 21:22:17]  Generator returned sat in 0.721667 secs.
[07/13 21:22:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:17]  Improved gap from 0 to 100
[07/13 21:22:17]  Improved number of small numbers from 49 to 64 out of a max of 80
[07/13 21:22:17]  Verifer returned sat in 0.358245 secs.
[07/13 21:22:17]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -5215.503906     0.072754 -5315.503906 -2504.781006     0.000000           0.000000  100.000000      100.000000
1 -5215.503906     0.018311 -5215.503906 -2504.781006     0.000000           0.000000    0.000000        0.000000
2 -5115.485840   100.018066 -5115.503906 -2504.781006     0.000000           0.000000    0.018066        0.018066
3 -5115.485657     0.018250 -5115.503906 -2504.781006     0.000000           0.000000    0.018250      -99.981750
4 -4715.458282   400.027374 -5015.503906 -2504.781006   100.045410         100.045410  200.000214      100.000214
5 -3915.417221   800.041061 -4815.503906 -2504.781006   700.086914         700.086914  199.999771      199.999771
6 -2415.355629  1500.061592 -4815.503906 -2504.781006  2200.148193        2200.148193  200.000084      100.000084
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:17]  --------------------------------------------------------------------------------
[07/13 21:22:17]  Iteration: 192
[07/13 21:22:20]  Generator returned sat in 1.058034 secs.
[07/13 21:22:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:20]  Improved number of small numbers from 58 to 79 out of a max of 79
[07/13 21:22:20]  Verifer returned sat in 0.143752 secs.
[07/13 21:22:20]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -5215.503906     0.072754 -5315.504150 -2504.781250     0.000000           0.000000  100.000244      100.000000
1 -5215.503906     0.018066 -5215.503906 -2504.781250     0.000000           0.000000    0.000000        0.000000
2 -5115.486084   100.017822 -5115.503906 -2504.781250     0.000000           0.000000    0.017822        0.017822
3 -5115.485840     0.018066 -5115.503906 -2504.781006     0.000000           0.000000    0.018066      -99.981689
4 -4715.449219   400.036621 -5015.504150 -2504.781006   100.045166         100.045166  200.009766      100.009766
5 -3915.394531   800.054688 -4815.524414 -2504.781006   700.109619         700.109619  200.020264      200.000000
6 -2415.333008  1500.061523 -4815.503906 -2504.781006  2200.147949        2200.147949  200.022949      100.023193
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:21]  --------------------------------------------------------------------------------
[07/13 21:22:21]  Iteration: 193
[07/13 21:22:23]  Generator returned sat in 0.750831 secs.
[07/13 21:22:23]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:23]  Improved gap from 409599/4096 to 100
[07/13 21:22:24]  Improved number of small numbers from 56 to 68 out of a max of 80
[07/13 21:22:24]  Verifer returned sat in 0.379130 secs.
[07/13 21:22:24]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -5315.504150     0.072510 -5315.521484 -2504.781006     0.000000           0.000000    0.017334        0.000000
1 -5315.504150     0.013184 -5315.504150 -2504.781006     0.000000           0.000000    0.000000     -100.000000
2 -5115.500081   200.004069 -5115.504150 -2504.781006     0.000000           0.000000    0.004069        0.004069
3 -5115.500081     0.003906 -5115.504150 -2504.781006     0.000000           0.000000    0.004069      -99.995931
4 -4715.463460   400.036621 -5015.504150 -2504.781006   100.040527         100.040527  200.000163      100.000163
5 -3815.408529   900.054932 -4915.504150 -2504.781006   800.095703         800.095703  299.999919      199.999919
6 -2265.326131  1550.082397 -4815.504150 -2504.781006  2250.178223        2250.178223  299.999797      199.999797
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:24]  --------------------------------------------------------------------------------
[07/13 21:22:24]  Iteration: 194
[07/13 21:22:26]  Generator returned sat in 0.766216 secs.
[07/13 21:22:26]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:27]  Improved gap from 325/196608 to 100
[07/13 21:22:27]  Improved number of small numbers from 37 to 80 out of a max of 80
[07/13 21:22:27]  Verifer returned sat in 0.274825 secs.
[07/13 21:22:27]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -7710.618164     0.072266 -7910.617920 -2504.781006     0.000000           0.000000  199.999756      199.999756
1 -7710.618164     0.036377 -7810.618164 -2504.781006     0.000000           0.000000  100.000000       99.999756
2 -7510.618164   300.000000 -7763.617920 -2504.781006     0.000000           0.000000  252.999756      199.999756
3 -7510.581543   253.000000 -7710.617920 -2504.781006     0.036377           0.036377  200.000000      100.000000
4 -6931.081543   579.500000 -7581.618164 -2504.781006   379.536377         379.536377  271.000244      200.000000
5 -5832.831543  1098.250000 -7510.617920 -2504.781006  1377.786377        1377.786377  300.000000      200.000000
6 -3932.456543  1900.375000 -7410.617920 -2504.781006  3178.161377        3178.161377  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:27]  --------------------------------------------------------------------------------
[07/13 21:22:27]  Iteration: 195
[07/13 21:22:30]  Generator returned sat in 0.785917 secs.
[07/13 21:22:30]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:30]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:22:30]  Verifer returned sat in 0.112740 secs.
[07/13 21:22:30]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -7710.618164    0.072266 -8010.617920 -2504.781006    0.000000           0.000000  299.999756      199.999756
1 -7710.618164    0.036377 -7910.617920 -2504.781006    0.000000           0.000000  199.999756       99.999756
2 -7510.618164  399.999756 -7763.617920 -2504.781006    0.000000           0.000000  252.999756      199.999756
3 -7231.081543  353.000000 -7710.617920 -2504.781006  179.536377         179.536377  300.000000      200.000000
4 -6931.081543  300.000000 -7581.618164 -2504.781006  479.536377         479.536377  171.000244      100.000000
5 -6602.081787  328.999756 -7410.617920 -2504.781006  650.536621         650.536621  157.999512      157.999512
6 -6249.081787  353.000000 -7410.617920 -2504.781006  861.536133         861.536133  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:30]  --------------------------------------------------------------------------------
[07/13 21:22:30]  Iteration: 196
[07/13 21:22:33]  Generator returned sat in 0.960429 secs.
[07/13 21:22:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:33]  Improved gap from 0 to 48.4375
[07/13 21:22:33]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:22:33]  Verifer returned sat in 0.135927 secs.
[07/13 21:22:33]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -7710.617920    0.072266 -8010.617920 -2504.781006        0.0                0.0  300.000000      200.000000
1 -7710.617920    0.036133 -7810.617920 -2504.781006        0.0                0.0  100.000000      100.000000
2 -7512.144287  298.473633 -7710.617920 -2504.781006        0.0                0.0  198.473633      198.473633
3 -7512.144287   48.437500 -7610.617920 -2504.781006        0.0                0.0   98.473633       98.473633
4 -7512.144287   48.437500 -7512.162354 -2504.781006        0.0                0.0    0.018066       -1.526367
5 -7463.724854   48.437500 -7510.617920 -2453.218506        0.0                0.0   46.893066       -1.544434
6 -7462.180420   48.437500 -7462.180420 -2453.218506        0.0                0.0    0.000000     -100.000000
high_util=False, low_loss=True, ramp_up=False, ramp_down=False, measured_loss_rate=0.
[07/13 21:22:33]  --------------------------------------------------------------------------------
[07/13 21:22:33]  Iteration: 197
[07/13 21:22:36]  Generator returned sat in 1.008419 secs.
[07/13 21:22:36]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:36]  Verifer returned unsat in 0.011582 secs.
[07/13 21:22:36]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:36]  --------------------------------------------------------------------------------
[07/13 21:22:36]  Iteration: 198
[07/13 21:22:39]  Generator returned sat in 0.780902 secs.
[07/13 21:22:39]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:39]  Verifer returned unsat in 0.015618 secs.
[07/13 21:22:39]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:39]  --------------------------------------------------------------------------------
[07/13 21:22:39]  Iteration: 199
[07/13 21:22:42]  Generator returned sat in 1.034056 secs.
[07/13 21:22:42]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:42]  Verifer returned unsat in 0.012400 secs.
[07/13 21:22:42]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:42]  --------------------------------------------------------------------------------
[07/13 21:22:42]  Iteration: 200
[07/13 21:22:45]  Generator returned sat in 0.869040 secs.
[07/13 21:22:45]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:45]  Improved gap from 7/600 to 48.4375
[07/13 21:22:45]  Improved number of small numbers from 51 to 80 out of a max of 80
[07/13 21:22:45]  Verifer returned sat in 0.160551 secs.
[07/13 21:22:45]  Counter example:
   arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -7859.045898    0.072021 -8059.045898 -2504.781494   0.000000           0.000000  200.000000      199.999756
1 -7859.045898  199.997314 -7959.045898 -2504.781494   0.000000           0.000000  100.000000       99.999756
2 -7659.045898  300.000000 -7859.045654 -2504.781494   0.000000           0.000000  199.999756      199.999756
3 -7610.605713  248.437500 -7759.045898 -2504.781494   0.002441           0.002441  148.437744      148.437500
4 -7610.605713    0.010000 -7659.045898 -2504.781494   0.002441           0.002441   48.437744       48.437500
5 -7610.605713    0.010000 -7659.045654 -2453.218994   0.002441           0.002441   48.437500        0.000000
6 -7610.605713    0.010000 -7610.608154 -2453.218994   0.002441           0.002441    0.000000     -100.000000
high_util=False, low_loss=True, ramp_up=False, ramp_down=False, measured_loss_rate=0.
[07/13 21:22:45]  --------------------------------------------------------------------------------
[07/13 21:22:45]  Iteration: 201
[07/13 21:22:49]  Generator returned sat in 2.223191 secs.
[07/13 21:22:49]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:49]  Improved gap from 9/800 to 100
[07/13 21:22:50]  Improved number of small numbers from 53 to 80 out of a max of 80
[07/13 21:22:50]  Verifer returned sat in 0.196189 secs.
[07/13 21:22:50]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -7759.027588     0.072021 -7759.063721 -2504.781494     0.000000           0.000000    0.036133        0.018066
1 -7759.027588     0.017822 -7759.045654 -2504.781494     0.000000           0.000000    0.018066      -99.981934
2 -7659.027832   100.017822 -7659.045654 -2504.781494     0.000000           0.000000    0.017822      -99.982178
3 -7259.045654   400.000000 -7459.045654 -2504.781494     0.000000           0.000000  200.000000      200.000000
4 -7059.063721   200.000000 -7459.045654 -2504.781494   199.981934         199.981934  200.000000      100.000000
5 -6309.063721   750.000000 -7356.045654 -2504.781494   749.982178         749.982178  296.999756      199.999756
6 -4729.563721  1579.500000 -7259.045654 -2504.781494  2229.482178        2229.482178  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:50]  --------------------------------------------------------------------------------
[07/13 21:22:50]  Iteration: 202
[07/13 21:22:53]  Generator returned sat in 1.020405 secs.
[07/13 21:22:53]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:53]  Improved number of small numbers from 59 to 64 out of a max of 79
[07/13 21:22:53]  Verifer returned sat in 0.288527 secs.
[07/13 21:22:53]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -7659.028076     0.071777 -7766.045654 -2504.781738     0.000000           0.000000  107.017578      100.017578
1 -7659.028076     0.004395 -7659.045654 -2504.781738     0.000000           0.000000    0.017578        0.017578
2 -7659.028076     0.017578 -7659.032288 -2504.781738     0.000000           0.000000    0.004211      -99.982422
3 -7366.032288   293.000000 -7459.045654 -2504.781738     0.000000           0.000000   93.013367       93.013367
4 -7159.041199   300.000000 -7459.045654 -2504.781738     0.004456           0.004456  300.000000      200.000000
5 -6409.041199   750.000000 -7356.045654 -2504.781738   749.981934         749.981934  197.022522      100.022522
6 -4829.561249  1579.479950 -7259.045654 -2504.781738  2229.484375        2229.484375  200.000031      100.000031
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:53]  --------------------------------------------------------------------------------
[07/13 21:22:53]  Iteration: 203
[07/13 21:22:56]  Generator returned sat in 0.926637 secs.
[07/13 21:22:56]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:56]  Improved gap from 147/4096 to 100
[07/13 21:22:56]  Improved number of small numbers from 44 to 80 out of a max of 80
[07/13 21:22:56]  Verifer returned sat in 0.194057 secs.
[07/13 21:22:56]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -9299.038086     0.071533 -9499.037842 -2771.412598     0.000000           0.000000  199.999756      100.000000
1 -9299.038086   199.964111 -9399.038086 -2771.412598     0.000000           0.000000  100.000000        0.000000
2 -9249.002197   150.035889 -9249.037842 -2771.412598     0.000000           0.000000    0.035645      -49.964111
3 -9099.038086   149.999756 -9199.037842 -2771.412598     0.000000           0.000000   99.999756        0.000000
4 -8799.073975   299.999756 -9063.037842 -2771.412598    99.964111          99.964111  163.999756      100.000000
5 -7845.073975   954.000000 -8999.037842 -2771.412598   853.964111         853.964111  299.999756      200.000000
6 -6039.073975  1806.000000 -8899.038086 -2771.412598  2559.964111        2559.964111  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:22:57]  --------------------------------------------------------------------------------
[07/13 21:22:57]  Iteration: 204
[07/13 21:22:59]  Generator returned sat in 0.865571 secs.
[07/13 21:22:59]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:22:59]  Improved gap from 441781/12288 to 100
[07/13 21:23:00]  Improved number of small numbers from 47 to 56 out of a max of 80
[07/13 21:23:00]  Verifer returned sat in 0.531080 secs.
[07/13 21:23:00]  Counter example:
   arrival_0,t     cwnd_0,t  service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -9231.091553     0.071289 -9431.109660 -2771.412598     0.000000           0.000000  200.018107      100.018107
1 -9231.091553   200.000000 -9231.109660 -2771.412598     0.000000           0.000000    0.018107        0.018107
2 -9099.038086   132.071574 -9134.966471 -2771.412598     0.000000           0.000000   35.928385       32.071574
3 -9099.038086    35.928385 -9099.073853 -2771.412598     0.000000           0.000000    0.035767      -67.928426
4 -8731.091777   367.964193 -9008.395318 -2771.412598     0.017883           0.017883  277.285658      200.000000
5 -7845.073975   886.017802 -8931.109660 -2771.412598   853.963867         853.963867  232.071818      132.071818
6 -6210.262054  1634.811920 -8831.109619 -2771.412598  2420.847412        2420.847412  200.000153      100.000193
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:00]  --------------------------------------------------------------------------------
[07/13 21:23:00]  Iteration: 205
[07/13 21:23:03]  Generator returned sat in 0.919924 secs.
[07/13 21:23:03]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:23:03]  Improved gap from 73/4096 to 100
[07/13 21:23:04]  Improved number of small numbers from 43 to 59 out of a max of 80
[07/13 21:23:04]  Verifer returned sat in 0.493584 secs.
[07/13 21:23:04]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11245.394775     0.071045 -11245.394946 -2771.412598     0.000000           0.000000    0.000171        0.000171
1 -11145.394946   100.000000 -11245.394775 -2771.412598     0.000000           0.000000   99.999829        0.000000
2 -11145.359131   100.035645 -11145.394946 -2771.412598     0.000000           0.000000    0.035815      -99.964185
3 -10845.341479   300.035645 -11045.394946 -2771.412598     0.017822           0.017822  200.035645      100.035645
4 -10095.288013   750.053467 -10945.394775 -2771.412598   550.106934         550.106934  299.999829      200.000000
5  -8520.207813  1575.080200 -10845.394946 -2771.412598  2025.187256        2025.187256  299.999878      199.999878
6  -5707.587512  2812.620300 -10745.394775 -2771.412598  4737.807617        4737.807617  299.999646      199.999817
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:04]  --------------------------------------------------------------------------------
[07/13 21:23:04]  Iteration: 206
[07/13 21:23:07]  Generator returned sat in 1.237833 secs.
[07/13 21:23:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:23:07]  Improved number of small numbers from 50 to 79 out of a max of 79
[07/13 21:23:07]  Verifer returned sat in 0.188646 secs.
[07/13 21:23:07]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -10995.389160    0.071045 -11195.388916 -2771.412598   0.000000           0.000000  199.999756      199.999756
1 -10995.389160    0.004444 -11095.388916 -2771.412598   0.000000           0.000000   99.999756       99.999756
2 -10895.389160  199.999756 -11095.388916 -2771.412598   0.000000           0.000000  199.999756       99.999756
3 -10695.344482  400.000000 -10895.388916 -2771.412598   0.044434           0.044434  200.000000      200.000000
4 -10695.340088  200.000000 -10895.388916 -2771.412598   0.048828           0.048828  200.000000      100.000000
5 -10695.340088  100.000000 -10745.388916 -2771.412598   0.048828           0.048828   50.000000        0.000000
6 -10345.344482  350.000000 -10695.388916 -2771.412598  50.044434          50.044434  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:08]  --------------------------------------------------------------------------------
[07/13 21:23:08]  Iteration: 207
[07/13 21:23:11]  Generator returned sat in 1.421471 secs.
[07/13 21:23:11]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:23:11]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:23:11]  Verifer returned sat in 0.093300 secs.
[07/13 21:23:11]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -10995.389160    0.071045 -11295.388916 -2771.412598    0.000000           0.000000  299.999756      199.999756
1 -10995.389160    0.004444 -11195.388916 -2771.412598    0.000000           0.000000  199.999756       99.999756
2 -10895.389160  299.999756 -11095.388916 -2771.412598    0.000000           0.000000  199.999756       99.999756
3 -10695.344482  400.000000 -10895.388916 -2771.412598    0.044434           0.044434  200.000000      200.000000
4 -10695.340088  200.000000 -10895.388916 -2771.412598    0.048828           0.048828  200.000000      100.000000
5 -10695.340088  100.000000 -10795.388916 -2771.412598    0.048828           0.048828  100.000000        0.000000
6 -10345.344482  350.000000 -10695.388916 -2771.412598  100.044434         100.044434  250.000000      150.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:11]  --------------------------------------------------------------------------------
[07/13 21:23:11]  Iteration: 208
[07/13 21:23:17]  Generator returned sat in 4.156664 secs.
[07/13 21:23:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:23:17]  Improved gap from 1/800 to 100
[07/13 21:23:18]  Improved number of small numbers from 72 to 74 out of a max of 80
[07/13 21:23:18]  Verifer returned sat in 0.199132 secs.
[07/13 21:23:18]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11195.389404    0.070557 -11295.389160 -2771.412598    0.000000           0.000000   99.999756       99.999756
1 -11195.389404    0.001465 -11295.387939 -2771.412598    0.000000           0.000000   99.998535       -0.000244
2 -11095.389160  199.998779 -11195.389160 -2771.412598    0.000000           0.000000  100.000000        0.000000
3 -11095.389160    0.001250 -11095.389160 -2771.412598    0.000000           0.000000    0.000000     -100.000000
4 -10695.387285  400.001875 -10895.389404 -2771.412598    0.001875           0.001875  200.000244      200.000000
5 -10695.387285    0.010000 -10895.389160 -2771.412598    0.001875           0.001875  200.000000      100.000000
6 -10095.372285  600.015000 -10795.389160 -2771.412598  400.017090         400.017090  299.999785      199.999785
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:18]  --------------------------------------------------------------------------------
[07/13 21:23:18]  Iteration: 209
[07/13 21:23:23]  Generator returned sat in 2.953162 secs.
[07/13 21:23:23]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:23:23]  Improved gap from 0 to 100
[07/13 21:23:23]  Improved number of small numbers from 42 to 80 out of a max of 80
[07/13 21:23:23]  Verifer returned sat in 0.205929 secs.
[07/13 21:23:23]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12537.836670     0.070312 -12737.836426 -2870.344727        0.0                0.0  199.999756      199.999756
1 -12537.836670     0.035400 -12637.836426 -2870.344727        0.0                0.0   99.999756       99.999756
2 -12337.836426   300.000000 -12537.836426 -2870.344727        0.0                0.0  200.000000      200.000000
3 -12137.836426   200.000000 -12537.836426 -2870.344727      200.0              200.0  200.000000      100.000000
4 -11636.836426   501.000000 -12418.836426 -2870.344727      501.0              501.0  281.000000      200.000000
5 -10806.336426   830.500000 -12266.836426 -2870.344727     1231.5             1231.5  229.000000      200.000000
6  -9568.336426  1238.000000 -12237.836426 -2870.344727     2369.5             2369.5  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:23]  --------------------------------------------------------------------------------
[07/13 21:23:23]  Iteration: 210
[07/13 21:23:26]  Generator returned sat in 0.921724 secs.
[07/13 21:23:26]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:23:26]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:23:26]  Verifer returned sat in 0.096469 secs.
[07/13 21:23:26]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12537.836670     0.070312 -12737.836426 -2870.344727        0.0                0.0  199.999756      199.999756
1 -12537.836670     0.035400 -12637.836426 -2870.344727        0.0                0.0   99.999756       99.999756
2 -12339.336426   298.500000 -12537.836426 -2870.344727        0.0                0.0  198.500000      198.500000
3 -12139.336426   200.000000 -12537.836426 -2870.344727      198.5              198.5  200.000000      100.000000
4 -11637.836426   501.500000 -12418.836426 -2870.344727      500.0              500.0  281.000000      200.000000
5 -10806.336426   831.500000 -12266.836426 -2870.344727     1231.5             1231.5  229.000000      200.000000
6  -9566.836426  1239.500000 -12237.836426 -2870.344727     2371.0             2371.0  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:27]  --------------------------------------------------------------------------------
[07/13 21:23:27]  Iteration: 211
[07/13 21:23:30]  Generator returned sat in 1.185532 secs.
[07/13 21:23:30]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:23:30]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:23:30]  Verifer returned sat in 0.109063 secs.
[07/13 21:23:30]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12537.836670     0.070312 -12748.836426 -2870.344727      0.000              0.000  210.999756      199.999756
1 -12537.836670     0.035400 -12637.836426 -2870.344727      0.000              0.000   99.999756       99.999756
2 -12339.336426   298.500000 -12537.836426 -2870.344727      0.000              0.000  198.500000      198.500000
3 -12139.336426   200.000000 -12537.836426 -2870.344727    198.500            198.500  200.000000      100.000000
4 -11520.836426   618.500000 -12418.836426 -2870.344727    617.000            617.000  281.000000      200.000000
5 -10262.586426  1258.250000 -12266.836426 -2870.344727   1775.250           1775.250  229.000000      200.000000
6  -7966.711426  2295.875000 -12237.836426 -2870.344727   3971.125           3971.125  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:30]  --------------------------------------------------------------------------------
[07/13 21:23:30]  Iteration: 212
[07/13 21:23:34]  Generator returned sat in 2.240762 secs.
[07/13 21:23:34]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:23:35]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:23:35]  Verifer returned sat in 0.137596 secs.
[07/13 21:23:35]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12537.836914    0.070312 -12822.836426 -2870.344727        0.0                0.0  284.999512      199.999512
1 -12537.836914    0.035156 -12737.836426 -2870.344727        0.0                0.0  199.999512       99.999512
2 -12339.336426  398.500000 -12537.836426 -2870.344727        0.0                0.0  198.500000      198.500000
3 -12139.336426  200.000000 -12537.836426 -2870.344727      198.5              198.5  200.000000      100.000000
4 -11710.336426  429.000000 -12337.836426 -2870.344727      527.5              527.5  100.000000      100.000000
5 -11108.836426  601.500000 -12252.836426 -2870.344727     1029.0             1029.0  115.000000      100.000000
6 -10679.836426  429.000000 -12237.836426 -2870.344727     1258.0             1258.0  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:35]  --------------------------------------------------------------------------------
[07/13 21:23:35]  Iteration: 213
[07/13 21:23:39]  Generator returned sat in 2.550534 secs.
[07/13 21:23:39]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:23:39]  Improved gap from 287/16384 to 100
[07/13 21:23:40]  Improved number of small numbers from 37 to 52 out of a max of 80
[07/13 21:23:40]  Verifer returned sat in 0.481592 secs.
[07/13 21:23:40]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12855.965088    0.070068 -12855.965129 -2752.216268    0.000000           0.000000    0.000041        0.000041
1 -12755.965129  100.000000 -12821.298462 -2752.216268    0.000000           0.000000   65.333333        0.000000
2 -12555.965129  265.333333 -12755.930176 -2752.216268    0.000000           0.000000  199.965047      100.000000
3 -12555.965088  199.965088 -12655.965129 -2752.216268    0.000000           0.000000  100.000041        0.000041
4 -12353.965129  302.000000 -12555.965129 -2752.216268    0.000000           0.000000  202.000000      102.000000
5 -12155.930094  400.000000 -12455.965088 -2752.216268    0.035034           0.035034  299.999959      200.000000
6 -11555.430094  600.500000 -12355.965088 -2752.216268  600.534912         600.534912  200.000081      100.000122
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:40]  --------------------------------------------------------------------------------
[07/13 21:23:40]  Iteration: 214
[07/13 21:23:44]  Generator returned sat in 2.018916 secs.
[07/13 21:23:44]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:23:45]  Improved number of small numbers from 48 to 60 out of a max of 79
[07/13 21:23:45]  Verifer returned sat in 0.377810 secs.
[07/13 21:23:45]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12855.965088    0.069824 -12855.965332 -2752.216309    0.000000           0.000000    0.000244        0.000000
1 -12755.965332  100.000000 -12821.298462 -2752.216268    0.000000           0.000000   65.333130       -0.000203
2 -12555.965129  265.333333 -12755.930176 -2752.216268    0.000000           0.000000  199.965047      100.000000
3 -12555.965088  199.965088 -12655.365234 -2752.216268    0.000000           0.000000   99.400146        0.000041
4 -12353.965088  301.400146 -12555.365129 -2752.216268    0.000000           0.000000  201.400041      102.000041
5 -12155.930094  399.400000 -12455.965088 -2752.216268    0.035034           0.035034  299.999959      200.000000
6 -11556.330094  599.600000 -12355.965088 -2752.216268  599.635010         599.635010  199.999984      100.000024
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:45]  --------------------------------------------------------------------------------
[07/13 21:23:45]  Iteration: 215
[07/13 21:23:49]  Generator returned sat in 2.147661 secs.
[07/13 21:23:49]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:23:49]  Improved gap from 143/16384 to 100
[07/13 21:23:49]  Improved number of small numbers from 52 to 80 out of a max of 80
[07/13 21:23:49]  Verifer returned sat in 0.203895 secs.
[07/13 21:23:49]  Counter example:
    arrival_0,t    cwnd_0,t  service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12521.615234    0.069580 -12621.61499 -2986.566406        0.0                0.0   99.999756       99.999756
1 -12521.615234   99.999756 -12621.61499 -2986.566406        0.0                0.0   99.999756       -0.000244
2 -12521.580078  100.034912 -12521.61499 -2986.566406        0.0                0.0    0.034912      -99.965088
3 -12421.614990  100.000000 -12421.61499 -2986.566406        0.0                0.0    0.000000     -100.000000
4 -12120.614990  301.000000 -12321.61499 -2986.566406        1.0                1.0  200.000000      100.000000
5 -11668.614990  452.000000 -12221.61499 -2986.566406      253.0              253.0  300.000000      200.000000
6 -10990.114990  678.500000 -12121.61499 -2986.566406      831.5              831.5  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:49]  --------------------------------------------------------------------------------
[07/13 21:23:49]  Iteration: 216
[07/13 21:23:54]  Generator returned sat in 2.550739 secs.
[07/13 21:23:54]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:23:54]  Improved number of small numbers from 69 to 79 out of a max of 79
[07/13 21:23:54]  Verifer returned sat in 0.122114 secs.
[07/13 21:23:54]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12521.580078    0.069336 -12621.614990 -2986.56665    0.000000           0.000000  100.034912      100.034912
1 -12521.580078  100.034912 -12621.614990 -2986.56665    0.000000           0.000000  100.034912        0.034912
2 -12521.580078  100.034668 -12521.614990 -2986.56665    0.000000           0.000000    0.034912      -99.965088
3 -12421.614990  100.000000 -12421.614990 -2986.56665    0.000000           0.000000    0.000000     -100.000000
4 -12120.114990  301.500000 -12221.615234 -2986.56665    1.500000           1.500000  100.000244      100.000000
5 -11667.364990  452.750000 -12221.614990 -2986.56665  354.249756         354.249756  200.000244      100.000244
6 -10987.739990  679.625000 -12121.614990 -2986.56665  833.875000         833.875000  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:54]  --------------------------------------------------------------------------------
[07/13 21:23:54]  Iteration: 217
[07/13 21:23:59]  Generator returned sat in 2.295722 secs.
[07/13 21:23:59]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:23:59]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:23:59]  Verifer returned sat in 0.096813 secs.
[07/13 21:23:59]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12521.580078    0.069336 -12622.614990 -2986.56665    0.000000           0.000000  101.034912      100.034912
1 -12521.580078  101.034912 -12621.614990 -2986.56665    0.000000           0.000000  100.034912        0.034912
2 -12521.580078  100.034668 -12521.614990 -2986.56665    0.000000           0.000000    0.034912      -99.965088
3 -12421.614990  100.000000 -12421.614990 -2986.56665    0.000000           0.000000    0.000000     -100.000000
4 -12120.114990  301.500000 -12221.615234 -2986.56665    1.500000           1.500000  100.000244      100.000000
5 -11667.364990  452.750000 -12221.614990 -2986.56665  354.249756         354.249756  200.000244      100.000244
6 -10987.739990  679.625000 -12121.614990 -2986.56665  833.875000         833.875000  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:23:59]  --------------------------------------------------------------------------------
[07/13 21:23:59]  Iteration: 218
[07/13 21:24:05]  Generator returned sat in 3.772831 secs.
[07/13 21:24:05]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:24:05]  Improved number of small numbers from 56 to 79 out of a max of 79
[07/13 21:24:05]  Verifer returned sat in 0.133009 secs.
[07/13 21:24:05]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12521.580322    0.069092 -12721.114746 -2986.56665    0.000000           0.000000  199.534424      199.534424
1 -12521.580322  199.534424 -12721.114746 -2986.56665    0.000000           0.000000  199.534424       99.534424
2 -12521.580322  199.534424 -12521.614746 -2986.56665    0.000000           0.000000    0.034424       -0.465576
3 -12521.114746    0.500000 -12521.114746 -2986.56665    0.000000           0.000000    0.000000     -100.000000
4 -12219.614746  301.500000 -12321.114746 -2986.56665    1.499756           1.499756  100.000244      100.000244
5 -11766.864746  452.750000 -12221.615479 -2986.56665  354.249512         354.249512  100.501221      100.000488
6 -11087.239746  679.625000 -12121.615234 -2986.56665  833.875000         833.875000  200.500488      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:05]  --------------------------------------------------------------------------------
[07/13 21:24:05]  Iteration: 219
[07/13 21:24:09]  Generator returned sat in 1.101927 secs.
[07/13 21:24:09]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:24:09]  Improved gap from 0 to 100
[07/13 21:24:09]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:24:09]  Verifer returned sat in 0.125571 secs.
[07/13 21:24:09]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12521.580322     0.069092 -12721.114746 -2986.56665      0.000              0.000  199.534424      199.534424
1 -12521.580322   199.534424 -12721.114746 -2986.56665      0.000              0.000  199.534424       99.534424
2 -12421.114746   300.000000 -12521.114746 -2986.56665      0.000              0.000  100.000000      100.000000
3 -12421.114746   100.000000 -12421.114746 -2986.56665      0.000              0.000    0.000000        0.000000
4 -11869.614746   551.500000 -12321.114746 -2986.56665    251.500            251.500  200.000000      200.000000
5 -11041.864746   827.750000 -12221.114746 -2986.56665   1079.250           1079.250  100.000000      100.000000
6  -9799.739746  1242.125000 -12221.114746 -2986.56665   2121.375           2121.375  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:09]  --------------------------------------------------------------------------------
[07/13 21:24:09]  Iteration: 220
[07/13 21:24:12]  Generator returned sat in 1.143132 secs.
[07/13 21:24:12]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:24:12]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:24:12]  Verifer returned sat in 0.104647 secs.
[07/13 21:24:12]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12521.580322     0.068848 -12721.114990 -2986.56665       0.00               0.00  199.534668      199.534668
1 -12521.580322   199.500244 -12721.114990 -2986.56665       0.00               0.00  199.534668       99.534668
2 -12421.114990   300.000000 -12521.114990 -2986.56665       0.00               0.00  100.000000      100.000000
3 -12421.114990   100.000000 -12421.114990 -2986.56665       0.00               0.00    0.000000        0.000000
4 -11869.114990   552.000000 -12321.114990 -2986.56665     252.00             252.00  200.000000      200.000000
5 -11040.614990   828.500000 -12221.114990 -2986.56665    1080.50            1080.50  100.000000      100.000000
6  -9797.364990  1243.250000 -12221.114746 -2986.56665    2123.75            2123.75  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:13]  --------------------------------------------------------------------------------
[07/13 21:24:13]  Iteration: 221
[07/13 21:24:16]  Generator returned sat in 1.413429 secs.
[07/13 21:24:16]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:24:16]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:24:16]  Verifer returned sat in 0.109917 secs.
[07/13 21:24:16]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t    wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12521.115234    0.068604 -12821.115234 -2986.56665        0.0                0.0  300.000000           200.0
1 -12521.115234  199.500244 -12721.115234 -2986.56665        0.0                0.0  200.000000           100.0
2 -12421.115234  300.000000 -12621.115234 -2986.56665        0.0                0.0  200.000000           100.0
3 -12421.115234  200.000000 -12421.115234 -2986.56665        0.0                0.0    0.000000             0.0
4 -11619.115234  802.000000 -12321.115234 -2986.56665      502.0              502.0  200.000000           200.0
5 -10816.615234  802.500000 -12221.115234 -2986.56665     1204.5             1204.5  200.000000           200.0
6 -10013.615234  803.000000 -12221.114746 -2986.56665     2007.5             2007.5  199.999512           100.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:17]  --------------------------------------------------------------------------------
[07/13 21:24:17]  Iteration: 222
[07/13 21:24:20]  Generator returned sat in 1.037984 secs.
[07/13 21:24:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:24:20]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:24:20]  Verifer returned sat in 0.092693 secs.
[07/13 21:24:20]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12521.115234    0.068359 -12821.115234 -2986.566895        0.0                0.0  300.000000           200.0
1 -12521.115234  199.500000 -12721.115234 -2986.566895        0.0                0.0  200.000000           100.0
2 -12421.115234  300.000000 -12621.115234 -2986.566895        0.0                0.0  200.000000           100.0
3 -12421.115234  200.000000 -12421.115234 -2986.566895        0.0                0.0    0.000000             0.0
4 -11619.615234  801.500000 -12321.115234 -2986.566895      501.5              501.5  200.000000           200.0
5 -10817.615234  802.000000 -12221.115479 -2986.566895     1204.5             1204.5  199.000244           199.0
6 -10015.115234  802.500000 -12221.114990 -2986.566895     2006.0             2006.0  199.999756           100.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:20]  --------------------------------------------------------------------------------
[07/13 21:24:20]  Iteration: 223
[07/13 21:24:24]  Generator returned sat in 2.238254 secs.
[07/13 21:24:25]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:24:25]  Improved number of small numbers from 33 to 79 out of a max of 79
[07/13 21:24:25]  Verifer returned sat in 0.229246 secs.
[07/13 21:24:25]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12524.217285    0.067871 -12724.200439 -2986.567139    0.00000            0.00000  199.983154      199.982910
1 -12524.200439  200.000000 -12624.200439 -2986.567139    0.00000            0.00000  100.000000       99.999756
2 -12524.200439    0.017090 -12524.217529 -2986.566895    0.00000            0.00000    0.017090        0.000000
3 -12524.166260    0.051270 -12524.200439 -2986.566895    0.00000            0.00000    0.034180      -99.965820
4 -12222.632080  301.551270 -12424.200195 -2986.566895    0.01709            0.01709  201.551025      101.551270
5 -12222.632080    0.500000 -12317.200439 -2986.566895    0.01709            0.01709   94.551270        1.551270
6 -11910.123535  312.525635 -12224.200439 -2986.566895   94.55127           94.55127  219.525635      119.525635
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:25]  --------------------------------------------------------------------------------
[07/13 21:24:25]  Iteration: 224
[07/13 21:24:29]  Generator returned sat in 1.738553 secs.
[07/13 21:24:29]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:24:29]  Improved gap from 3186271/73728 to 100
[07/13 21:24:29]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:24:29]  Verifer returned sat in 0.153402 secs.
[07/13 21:24:29]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0 -13211.140381    0.067871 -13311.140381 -2986.566895    0.000000           0.000000  100.000         100.000
1 -13211.140381  100.000000 -13211.140381 -2986.566895    0.000000           0.000000    0.000           0.000
2 -13011.140381  200.000000 -13111.140381 -2986.566895    0.000000           0.000000  100.000         100.000
3 -12811.174316  200.000000 -13111.140381 -2986.566895   99.966064          99.966064  200.000         100.000
4 -12710.674316  300.500000 -13006.140381 -2986.566895   99.966064          99.966064  195.500         100.500
5 -12251.924316  458.750000 -12911.140381 -2986.566895  459.216064         459.216064  200.000         100.000
6 -11563.299316  688.625000 -12811.140381 -2986.566895  959.716064         959.716064  288.125         188.125
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:29]  --------------------------------------------------------------------------------
[07/13 21:24:29]  Iteration: 225
[07/13 21:24:33]  Generator returned sat in 1.388121 secs.
[07/13 21:24:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:24:33]  Improved number of small numbers from 77 to 77 out of a max of 79
[07/13 21:24:33]  Verifer returned sat in 0.122139 secs.
[07/13 21:24:33]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -13211.140625    0.067627 -13311.140625 -2986.567139    0.000000           0.000000  100.000000       99.999756
1 -13211.140625  100.000000 -13211.140625 -2986.567139    0.000000           0.000000    0.000000       -0.000244
2 -13011.140625  200.000000 -13111.140381 -2986.567139    0.000000           0.000000   99.999756       99.999756
3 -12810.507650  200.666667 -13111.140381 -2986.567139   99.966064          99.966064  200.666667      100.666667
4 -12709.674316  301.500000 -13006.140625 -2986.567139   99.966064          99.966064  196.500244      101.500000
5 -12250.924316  458.750000 -12911.140381 -2986.567139  460.216064         460.216064  200.000000      100.000000
6 -11562.299316  688.625000 -12811.140381 -2986.567139  960.716064         960.716064  288.125000      188.125000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:33]  --------------------------------------------------------------------------------
[07/13 21:24:33]  Iteration: 226
[07/13 21:24:37]  Generator returned sat in 1.158659 secs.
[07/13 21:24:37]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:24:37]  Improved gap from 277/16384 to 100
[07/13 21:24:37]  Improved number of small numbers from 31 to 80 out of a max of 80
[07/13 21:24:37]  Verifer returned sat in 0.256439 secs.
[07/13 21:24:37]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -13381.162354    0.067627 -13381.196045 -2916.528564     0.000000           0.000000    0.033691        0.016602
1 -13381.162354    0.017090 -13381.178955 -2916.528564     0.000000           0.000000    0.016602      -99.983398
2 -12981.179199  399.999756 -13181.178955 -2916.528564     0.000000           0.000000  199.999756      199.999756
3 -12981.162109  200.000000 -13181.178955 -2916.528564     0.016846           0.016846  200.000000      100.000000
4 -12680.662109  300.500000 -13081.178955 -2916.528564   200.516846         200.516846  200.000000      100.000000
5 -12229.412109  451.250000 -12981.178955 -2916.528564   451.767090         451.767090  299.999756      199.999756
6 -11552.037109  677.375000 -12881.178955 -2916.528564  1029.142090        1029.142090  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:37]  --------------------------------------------------------------------------------
[07/13 21:24:37]  Iteration: 227
[07/13 21:24:41]  Generator returned sat in 1.334679 secs.
[07/13 21:24:41]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:24:41]  Improved number of small numbers from 57 to 79 out of a max of 79
[07/13 21:24:41]  Verifer returned sat in 0.125736 secs.
[07/13 21:24:41]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -13181.179199     0.067383 -13381.179199 -2916.528809     0.000000           0.000000  200.000000      199.999756
1 -13181.179199     0.033936 -13381.178955 -2916.528809     0.000000           0.000000  199.999756       99.999756
2 -12981.179199   399.999756 -13181.178955 -2916.528809     0.000000           0.000000  199.999756      199.999756
3 -12981.145264   200.000000 -13081.179199 -2916.528809     0.033691           0.033691  100.000244      100.000000
4 -12430.645264   550.500000 -13061.178955 -2916.528809   450.533691         450.533691  180.000000      100.000000
5 -11169.145264  1261.500000 -12981.178955 -2916.528809  1512.033936        1512.033936  299.999756      199.999756
6  -8545.645264  2623.500000 -12881.178955 -2916.528809  4035.533691        4035.533691  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:41]  --------------------------------------------------------------------------------
[07/13 21:24:41]  Iteration: 228
[07/13 21:24:45]  Generator returned sat in 1.671113 secs.
[07/13 21:24:45]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:24:45]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:24:45]  Verifer returned sat in 0.093924 secs.
[07/13 21:24:45]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -13181.179199    0.067383 -13426.178955 -2916.528809    0.000000           0.000000  244.999756      199.999756
1 -13181.179199    0.033936 -13381.178955 -2916.528809    0.000000           0.000000  199.999756       99.999756
2 -12981.179199  399.999756 -13226.178955 -2916.528809    0.000000           0.000000  244.999756      199.999756
3 -12776.145264  345.000000 -13081.178955 -2916.528809  105.033691         105.033691  200.000000      200.000000
4 -12430.645264  345.500000 -13081.178955 -2916.528809  450.533691         450.533691  200.000000      100.000000
5 -12130.145264  300.500000 -12881.178955 -2916.528809  651.033691         651.033691  100.000000      100.000000
6 -11784.645264  345.500000 -12881.178955 -2916.528809  796.533691         796.533691  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=False, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:45]  --------------------------------------------------------------------------------
[07/13 21:24:45]  Iteration: 229
[07/13 21:24:50]  Generator returned sat in 2.793962 secs.
[07/13 21:24:50]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:24:50]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:24:50]  Verifer returned sat in 0.101681 secs.
[07/13 21:24:50]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -13181.179199    0.067383 -13426.179199 -2916.529053    0.000000           0.000000  245.000000      199.999756
1 -13181.179199    0.033691 -13381.178955 -2916.529053    0.000000           0.000000  199.999756       99.999756
2 -12981.179199  399.999756 -13226.179199 -2916.529053    0.000000           0.000000  245.000000      199.999756
3 -12776.145508  345.000000 -13081.179199 -2916.529053  105.033691         105.033691  200.000000      199.999756
4 -12430.645508  345.500000 -13081.178955 -2916.529053  450.533447         450.533447  200.000000      100.000000
5 -12084.645508  346.000000 -12881.179199 -2916.529053  696.533447         696.533447  100.000244      100.000000
6 -11738.145508  346.500000 -12881.178955 -2916.529053  843.033447         843.033447  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:24:51]  --------------------------------------------------------------------------------
[07/13 21:24:51]  Iteration: 230
[07/13 21:24:55]  Generator returned sat in 2.173899 secs.
[07/13 21:24:55]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:24:55]  Verifer returned unsat in 0.013979 secs.
[07/13 21:24:55]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:24:55]  --------------------------------------------------------------------------------
[07/13 21:24:55]  Iteration: 231
[07/13 21:25:00]  Generator returned sat in 2.316334 secs.
[07/13 21:25:00]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:00]  Improved gap from 102469/4096 to 48.4375
[07/13 21:25:00]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:25:00]  Verifer returned sat in 0.140881 secs.
[07/13 21:25:00]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12730.477295    0.067383 -12930.510986 -2916.529053        0.0                0.0  200.033691      100.033691
1 -12730.477295    0.033691 -12730.510986 -2916.529053        0.0                0.0    0.033691        0.033691
2 -12430.645752  299.865234 -12630.510986 -2916.529053        0.0                0.0  199.865234      199.865234
3 -12430.645752  199.865234 -12578.948486 -2916.529053        0.0                0.0  148.302734       99.865234
4 -12430.645752   99.932617 -12432.039795 -2916.529053        0.0                0.0    1.394043       -0.134766
5 -12382.073486   49.966309 -12430.510986 -2864.966553        0.0                0.0   48.437500        0.000000
6 -12382.073486   24.983154 -12382.073486 -2864.966553        0.0                0.0    0.000000     -100.000000
high_util=False, low_loss=True, ramp_up=False, ramp_down=True, measured_loss_rate=0.
[07/13 21:25:00]  --------------------------------------------------------------------------------
[07/13 21:25:00]  Iteration: 232
[07/13 21:25:04]  Generator returned sat in 1.396521 secs.
[07/13 21:25:04]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:04]  Verifer returned unsat in 0.018955 secs.
[07/13 21:25:04]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:04]  --------------------------------------------------------------------------------
[07/13 21:25:04]  Iteration: 233
[07/13 21:25:07]  Generator returned sat in 1.137629 secs.
[07/13 21:25:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:07]  Verifer returned unsat in 0.012745 secs.
[07/13 21:25:07]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:07]  --------------------------------------------------------------------------------
[07/13 21:25:07]  Iteration: 234
[07/13 21:25:11]  Generator returned sat in 1.357989 secs.
[07/13 21:25:11]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:11]  Improved gap from 0 to 100
[07/13 21:25:11]  Improved number of small numbers from 50 to 78 out of a max of 80
[07/13 21:25:11]  Verifer returned sat in 0.347107 secs.
[07/13 21:25:11]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12530.395752    0.067139 -12730.387451 -2916.529053    0.000000           0.000000  199.991699      199.991699
1 -12530.395752    0.033691 -12730.387207 -2916.529053    0.000000           0.000000  199.991455       99.991699
2 -12530.395752    0.008545 -12530.395752 -2916.529053    0.000000           0.000000    0.000000       -0.008301
3 -12530.387451    0.008301 -12530.387451 -2916.529053    0.000000           0.000000    0.000000     -100.000000
4 -12130.379150  400.008301 -12430.387207 -2916.529053    0.008545           0.008545  299.999512      199.999756
5 -12130.379150    0.500000 -12330.387329 -2916.529053    0.008545           0.008545  199.999634       99.999756
6 -11729.862305  400.516846 -12230.387451 -2916.529053  300.525146         300.525146  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:25:11]  --------------------------------------------------------------------------------
[07/13 21:25:11]  Iteration: 235
[07/13 21:25:15]  Generator returned sat in 1.323302 secs.
[07/13 21:25:15]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:15]  Improved gap from 1634427/65536 to 100
[07/13 21:25:15]  Improved number of small numbers from 34 to 80 out of a max of 80
[07/13 21:25:15]  Verifer returned sat in 0.214749 secs.
[07/13 21:25:15]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12730.825684    0.066895 -12730.859375 -2916.529297    0.000000           0.000000    0.033691        0.033447
1 -12730.825684    0.016602 -12730.825684 -2916.529297    0.000000           0.000000    0.000000      -99.966553
2 -12430.859375  299.966309 -12630.859131 -2916.529297    0.000000           0.000000  199.999756       99.999756
3 -12430.859375    0.016602 -12530.856445 -2916.529297    0.000000           0.000000   99.997070       -0.000244
4 -12030.845215  400.014160 -12330.859131 -2916.529297  100.014160         100.014160  199.999756      199.999756
5 -12030.845215    0.500000 -12330.859131 -2916.529297  100.014160         100.014160  199.999756       99.999756
6 -11430.595215  600.250000 -12230.859131 -2916.529297  500.263916         500.263916  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:25:15]  --------------------------------------------------------------------------------
[07/13 21:25:15]  Iteration: 236
[07/13 21:25:20]  Generator returned sat in 2.108502 secs.
[07/13 21:25:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:20]  Improved gap from 102397/1024 to 100
[07/13 21:25:20]  Improved number of small numbers from 58 to 80 out of a max of 80
[07/13 21:25:20]  Verifer returned sat in 0.175328 secs.
[07/13 21:25:20]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12730.855957    0.066895 -12730.859375 -2916.529541    0.000000           0.000000    0.003418        0.003418
1 -12730.855957    0.001953 -12730.855957 -2916.529541    0.000000           0.000000    0.000000      -99.996582
2 -12430.859375  299.996582 -12530.859619 -2916.529541    0.000000           0.000000  100.000244      100.000000
3 -12430.859375    0.001709 -12530.859375 -2916.529541    0.000000           0.000000  100.000000        0.000000
4 -12030.855957  400.003418 -12331.373535 -2916.529541  100.014160         100.014160  200.503418      199.989258
5 -12030.855957  200.501709 -12330.859375 -2916.529541  100.014160         100.014160  199.989258       99.989258
6 -11229.852051  801.003906 -12230.859375 -2916.529541  701.007568         701.007568  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:25:20]  --------------------------------------------------------------------------------
[07/13 21:25:20]  Iteration: 237
[07/13 21:25:24]  Generator returned sat in 1.246093 secs.
[07/13 21:25:24]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:24]  Improved number of small numbers from 72 to 75 out of a max of 79
[07/13 21:25:24]  Verifer returned sat in 0.177830 secs.
[07/13 21:25:24]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12730.855957    0.066650 -12730.859375 -2916.529785    0.000000           0.000000    0.003418        0.003418
1 -12730.855957    0.001709 -12730.855957 -2916.529541    0.000000           0.000000    0.000000      -99.996338
2 -12430.859375  299.996582 -12530.859619 -2916.529541    0.000000           0.000000  100.000244      100.000244
3 -12430.859375    0.002279 -12530.859375 -2916.529541    0.000000           0.000000  100.000000        0.000244
4 -12030.855957  400.003418 -12331.373535 -2916.529541  100.013916         100.013916  200.503662      199.989746
5 -12030.855957  200.501709 -12330.859375 -2916.529541  100.013916         100.013916  199.989502       99.989746
6 -11330.102905  700.753052 -12230.859375 -2916.529541  700.756348         700.756348  200.000122      100.000366
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:25:24]  --------------------------------------------------------------------------------
[07/13 21:25:24]  Iteration: 238
[07/13 21:25:28]  Generator returned sat in 1.272254 secs.
[07/13 21:25:28]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:28]  Improved gap from 409585/4096 to 100
[07/13 21:25:28]  Improved number of small numbers from 74 to 80 out of a max of 80
[07/13 21:25:28]  Verifer returned sat in 0.119169 secs.
[07/13 21:25:28]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12730.859619    0.066406 -12730.862305 -2916.529785    0.000000           0.000000    0.002686             0.0
1 -12730.859619    0.001221 -12730.859619 -2916.529785    0.000000           0.000000    0.000000          -100.0
2 -12430.859619  300.000000 -12530.859619 -2916.529785    0.000000           0.000000  100.000000           100.0
3 -12430.859619    0.007812 -12530.859375 -2916.529785    0.000000           0.000000   99.999756             0.0
4 -12030.845947  400.013672 -12430.859619 -2916.529785  100.013672         100.013672  300.000000           200.0
5 -12030.845947  200.506836 -12330.859375 -2916.529785  100.013672         100.013672  199.999756           100.0
6 -11430.338623  600.507324 -12230.859619 -2916.529785  600.520996         600.520996  200.000000           100.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:25:28]  --------------------------------------------------------------------------------
[07/13 21:25:28]  Iteration: 239
[07/13 21:25:32]  Generator returned sat in 1.606325 secs.
[07/13 21:25:32]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:32]  Improved number of small numbers from 77 to 79 out of a max of 79
[07/13 21:25:32]  Verifer returned sat in 0.136481 secs.
[07/13 21:25:32]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12730.859619    0.066406 -12830.859863 -2916.529785    0.000000           0.000000  100.000244        0.000244
1 -12730.859619    0.001221 -12730.859619 -2916.529785    0.000000           0.000000    0.000000      -99.999756
2 -12330.845947  400.013672 -12630.859863 -2916.529785  100.013672         100.013672  200.000244      100.000244
3 -12330.845947    0.000488 -12530.859863 -2916.529785  100.013672         100.013672  100.000244        0.000244
4 -12030.846191  300.000000 -12430.859619 -2916.529785  200.013672         200.013672  199.999756      100.000000
5 -12030.846191    0.500000 -12230.859863 -2916.529785  200.013672         200.013672    0.000000        0.000000
6 -11630.846191  400.000000 -12230.859619 -2916.529785  400.013672         400.013672  199.999756      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:25:32]  --------------------------------------------------------------------------------
[07/13 21:25:32]  Iteration: 240
[07/13 21:25:40]  Generator returned sat in 5.506501 secs.
[07/13 21:25:40]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:25:40]  Improved gap from 3268607/32768 to 100
[07/13 21:25:40]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:25:40]  Verifer returned sat in 0.129837 secs.
[07/13 21:25:40]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t  queue_t  bottle_queue_t
0 -12630.859863    0.066406 -12730.859863 -2916.529785    0.000000           0.000000   100.00           100.0
1 -12630.859863    0.033203 -12630.859863 -2916.529785    0.000000           0.000000     0.00             0.0
2 -12330.859863  300.000000 -12530.859863 -2916.529785    0.000000           0.000000   200.00           200.0
3 -12330.826660  200.000000 -12530.859863 -2916.529785    0.033203           0.033203   200.00           100.0
4 -12330.826660  100.000000 -12430.859863 -2916.529785    0.033203           0.033203   100.00             0.0
5 -11830.326660  500.500000 -12281.109863 -2916.529785  200.533203         200.533203   250.25           200.0
6 -11580.076660  250.250000 -12130.859863 -2916.529785  450.783203         450.783203   100.00           100.0
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:25:41]  --------------------------------------------------------------------------------
[07/13 21:25:41]  Iteration: 241
[07/13 21:25:48]  Generator returned sat in 5.068610 secs.
[07/13 21:25:48]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:48]  Improved number of small numbers from 53 to 79 out of a max of 79
[07/13 21:25:48]  Verifer returned sat in 0.151103 secs.
[07/13 21:25:48]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12630.860107    0.065918 -12630.893311 -2916.529785    0.000000           0.000000    0.033203        0.000000
1 -12630.860107    0.016357 -12630.860107 -2916.529785    0.000000           0.000000    0.000000     -100.000000
2 -12330.860107  300.000000 -12530.860107 -2916.529785    0.000000           0.000000  200.000000      100.000000
3 -12229.793945  301.049805 -12430.860107 -2916.529785    0.016357           0.016357  201.049805      101.049805
4 -12229.793945  201.033203 -12230.860107 -2916.529785    0.016357           0.016357    1.049805        1.049805
5 -11929.277344  300.516602 -12181.110352 -2916.529785    1.607666           1.607666  250.225342      199.975098
6 -11578.527588  350.749756 -12030.860352 -2916.529785  352.332520         352.332520  100.000244      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:25:48]  --------------------------------------------------------------------------------
[07/13 21:25:48]  Iteration: 242
[07/13 21:25:52]  Generator returned sat in 1.742006 secs.
[07/13 21:25:53]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:53]  Improved number of small numbers from 73 to 79 out of a max of 79
[07/13 21:25:53]  Verifer returned sat in 0.110322 secs.
[07/13 21:25:53]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12629.827148    0.065674 -12629.852051 -2917.562744    0.000000           0.000000    0.024902        0.000000
1 -12629.827148    0.004150 -12629.827148 -2917.562744    0.000000           0.000000    0.000000     -100.000000
2 -12330.860107  298.967041 -12429.827148 -2917.562744    0.000000           0.000000   98.967041       98.967041
3 -12229.793945  200.033203 -12429.827148 -2917.562744    0.000000           0.000000  200.033203      100.033203
4 -12229.793945  200.029053 -12229.827393 -2917.562744    0.000000           0.000000    0.033447        0.033203
5 -11929.779541  300.014404 -12181.110596 -2917.562744    1.607666           1.607666  249.723389      198.439941
6 -11628.765137  301.014404 -12030.860352 -2917.562744  301.062012         301.062012  101.033203      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:25:53]  --------------------------------------------------------------------------------
[07/13 21:25:53]  Iteration: 243
[07/13 21:25:57]  Generator returned sat in 1.380153 secs.
[07/13 21:25:57]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:25:57]  Improved number of small numbers from 72 to 79 out of a max of 79
[07/13 21:25:57]  Verifer returned sat in 0.115893 secs.
[07/13 21:25:57]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12629.827148    0.065430 -12629.852051 -2917.562744    0.000000           0.000000    0.024902        0.000244
1 -12629.827148    0.004150 -12629.827148 -2917.562744    0.000000           0.000000    0.000000      -99.999756
2 -12330.860352  298.966797 -12429.827393 -2917.562744    0.000000           0.000000   98.967041       98.967041
3 -12229.794189  200.033203 -12429.827148 -2917.562744    0.000000           0.000000  200.032959      100.033203
4 -12229.794189  200.029053 -12229.827393 -2917.562744    0.000000           0.000000    0.033203        0.033203
5 -11929.779785  300.014404 -12181.110596 -2917.562744    1.607422           1.607422  249.723389      198.440186
6 -11204.392578  725.387207 -12030.860352 -2917.562744  725.434570         725.434570  101.033203      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:25:57]  --------------------------------------------------------------------------------
[07/13 21:25:57]  Iteration: 244
[07/13 21:26:02]  Generator returned sat in 2.861951 secs.
[07/13 21:26:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:26:02]  Improved gap from 0 to 100
[07/13 21:26:02]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:26:02]  Verifer returned sat in 0.120962 secs.
[07/13 21:26:02]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12629.827393    0.065430 -12629.860107 -2917.562744    0.000000           0.000000    0.032715        0.000000
1 -12629.827393    0.016357 -12629.827393 -2917.562744    0.000000           0.000000    0.000000     -100.000000
2 -12229.827393  400.000000 -12429.827393 -2917.562744    0.000000           0.000000  200.000000      200.000000
3 -12229.827393   50.031250 -12429.827393 -2917.562744    0.000000           0.000000  200.000000      100.000000
4 -12229.827393  150.047607 -12329.827393 -2917.562744    0.000000           0.000000  100.000000        0.000000
5 -11929.779785  300.047607 -12181.110596 -2917.562744  100.000000         100.000000  151.330811      100.047607
6 -11628.732178  301.047607 -12030.860352 -2917.562744  301.095215         301.095215  101.032959      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:26:03]  --------------------------------------------------------------------------------
[07/13 21:26:03]  Iteration: 245
[07/13 21:26:07]  Generator returned sat in 2.382923 secs.
[07/13 21:26:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:26:08]  Improved number of small numbers from 77 to 79 out of a max of 79
[07/13 21:26:08]  Verifer returned sat in 0.104131 secs.
[07/13 21:26:08]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12529.827637    0.065186 -12629.827637 -2917.562744    0.000000           0.000000  100.000000      100.000000
1 -12529.827637    0.032471 -12529.827637 -2917.562744    0.000000           0.000000    0.000000        0.000000
2 -12229.827881  299.999756 -12429.827881 -2917.562744    0.000000           0.000000  200.000000      199.999756
3 -12229.827881   50.031250 -12429.827637 -2917.562744    0.000000           0.000000  199.999756       99.999756
4 -12229.827881  150.031250 -12296.515137 -2917.562744    0.000000           0.000000   66.687256       -0.000244
5 -11963.140381  266.687500 -12181.111084 -2917.562744   66.687256          66.687256  151.283447      100.000000
6 -11562.109131  401.031250 -12030.860840 -2917.562744  301.094727         301.094727  167.656982      166.623779
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:26:08]  --------------------------------------------------------------------------------
[07/13 21:26:08]  Iteration: 246
[07/13 21:26:17]  Generator returned sat in 7.199850 secs.
[07/13 21:26:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:26:18]  Improved number of small numbers from 68 to 73 out of a max of 79
[07/13 21:26:18]  Verifer returned sat in 0.201279 secs.
[07/13 21:26:18]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12524.515137    0.064941 -12596.515381 -2917.562988    0.000000           0.000000   72.000244       72.000000
1 -12524.515137    0.032471 -12524.515137 -2917.562988    0.000000           0.000000    0.000000      -28.000000
2 -12277.172852  247.342285 -12429.827881 -2917.562988    0.000000           0.000000  152.655029      119.342285
3 -12277.172852    0.008057 -12396.515137 -2917.562988    0.000000           0.000000  119.342285       19.342285
4 -12277.172852  100.016235 -12296.515137 -2917.562988    0.000000           0.000000   19.342285      -80.657715
5 -11963.140381  314.032471 -12181.111328 -2917.562988   33.374512          33.374512  184.596436      100.000244
6 -11491.091675  472.048706 -12030.861084 -2917.562988  305.423584         305.423584  234.345825      199.999878
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:26:18]  --------------------------------------------------------------------------------
[07/13 21:26:18]  Iteration: 247
[07/13 21:26:24]  Generator returned sat in 3.410113 secs.
[07/13 21:26:24]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:26:24]  Improved gap from 0 to 100
[07/13 21:26:24]  Improved number of small numbers from 26 to 60 out of a max of 80
[07/13 21:26:24]  Verifer returned sat in 0.668163 secs.
[07/13 21:26:24]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12631.126953    0.064697 -12631.159668 -2882.951172     0.000000           0.000000    0.032715        0.000244
1 -12631.126953    0.016113 -12631.127144 -2882.951172     0.000000           0.000000    0.000190      -99.999756
2 -12431.127144  200.000000 -12431.159424 -2882.951172     0.000000           0.000000    0.032280        0.000054
3 -12431.127144    0.016235 -12431.127197 -2882.951172     0.000000           0.000000    0.000054      -99.999946
4 -12031.054084  400.073059 -12331.127197 -2882.951172     0.073242           0.073242  299.999871      199.999871
5 -11429.944496  601.109589 -12231.127197 -2882.951172   501.182861         501.182861  299.999840      199.999840
6 -10527.280113  902.664383 -12131.126953 -2882.951172  1303.847168        1303.847168  299.999672      199.999916
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:26:25]  --------------------------------------------------------------------------------
[07/13 21:26:25]  Iteration: 248
[07/13 21:26:33]  Generator returned sat in 6.409657 secs.
[07/13 21:26:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:26:33]  Improved gap from 0 to 100
[07/13 21:26:34]  Improved number of small numbers from 46 to 80 out of a max of 80
[07/13 21:26:34]  Verifer returned sat in 0.161234 secs.
[07/13 21:26:34]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12331.159424    0.064697 -12431.159424 -2882.951416   0.000000           0.000000  100.000000      100.000000
1 -12331.159424    0.032227 -12431.159424 -2882.951416   0.000000           0.000000  100.000000        0.000000
2 -12331.159424    0.032471 -12331.159424 -2882.951416   0.000000           0.000000    0.000000     -100.000000
3 -12131.159668  199.999756 -12231.159424 -2882.951416   0.000000           0.000000   99.999756       -0.000244
4 -12031.159424  200.000000 -12131.159424 -2882.951416   0.000000           0.000000  100.000000        0.000000
5 -11731.191895  300.000000 -12031.159424 -2882.951416  99.967529          99.967529  200.000000      100.000000
6 -11630.159668  301.000000 -11931.159424 -2882.951416  99.999756          99.999756  201.000000      101.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:26:34]  --------------------------------------------------------------------------------
[07/13 21:26:34]  Iteration: 249
[07/13 21:26:38]  Generator returned sat in 1.479145 secs.
[07/13 21:26:38]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:26:38]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:26:38]  Verifer returned sat in 0.091217 secs.
[07/13 21:26:38]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12331.159424    0.064697 -12465.143066 -2882.951416   0.000000           0.000000  133.983643      100.000000
1 -12331.159424    0.032227 -12363.159424 -2882.951416   0.000000           0.000000   32.000000        0.000000
2 -12331.159424    0.032471 -12331.159424 -2882.951416   0.000000           0.000000    0.000000     -100.000000
3 -12131.159668  199.999756 -12231.159424 -2882.951416   0.000000           0.000000   99.999756       -0.000244
4 -11997.175781  233.983643 -12097.159424 -2882.951416   0.000000           0.000000   99.983643       33.983643
5 -11731.191895  266.000000 -12031.159424 -2882.951416  99.967529          99.967529  200.000000      100.000000
6 -11531.159668  400.000000 -11931.159424 -2882.951416  99.999756          99.999756  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:26:38]  --------------------------------------------------------------------------------
[07/13 21:26:38]  Iteration: 250
[07/13 21:26:42]  Generator returned sat in 2.003076 secs.
[07/13 21:26:43]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:26:43]  Improved gap from 0 to 100
[07/13 21:26:43]  Improved number of small numbers from 51 to 80 out of a max of 80
[07/13 21:26:43]  Verifer returned sat in 0.215370 secs.
[07/13 21:26:43]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t    wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12199.550781     0.064453 -12199.583008 -2882.95166     0.000000           0.000000    0.032227        0.032227
1 -12199.550781     0.015869 -12199.550781 -2882.95166     0.000000           0.000000    0.000000      -99.967773
2 -11999.583252   199.967529 -12099.583008 -2882.95166     0.000000           0.000000   99.999756       -0.000244
3 -11799.566895   300.000000 -11999.583008 -2882.95166     0.016113           0.016113  200.000000      100.000000
4 -11348.566895   451.000000 -11899.583008 -2882.95166   251.016113         251.016113  300.000000      200.000000
5 -10671.066895   677.500000 -11799.583008 -2882.95166   828.516113         828.516113  300.000000      200.000000
6  -9653.816895  1017.250000 -11699.583008 -2882.95166  1745.766113        1745.766113  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:26:43]  --------------------------------------------------------------------------------
[07/13 21:26:43]  Iteration: 251
[07/13 21:26:48]  Generator returned sat in 2.395326 secs.
[07/13 21:26:48]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:26:48]  Improved number of small numbers from 54 to 79 out of a max of 79
[07/13 21:26:48]  Verifer returned sat in 0.140380 secs.
[07/13 21:26:48]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12199.550781    0.064209 -12199.583008 -2882.951904    0.000000           0.000000    0.032227        0.032227
1 -12199.550781    0.015625 -12199.550781 -2882.951904    0.000000           0.000000    0.000000      -99.967773
2 -11999.583496  199.967285 -12099.583008 -2882.951904    0.000000           0.000000   99.999512       -0.000488
3 -11724.570801  375.004150 -11975.587158 -2882.951904    0.008057           0.008057  251.008301      175.004150
4 -11348.567139  376.004150 -11899.583008 -2882.951904  251.015869         251.015869  300.000000      200.000000
5 -10971.562988  377.004150 -11799.583008 -2882.951904  628.020020         628.020020  200.000000      100.000000
6 -10593.558838  378.004150 -11699.583008 -2882.951904  906.024170         906.024170  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:26:48]  --------------------------------------------------------------------------------
[07/13 21:26:48]  Iteration: 252
[07/13 21:26:54]  Generator returned sat in 3.285681 secs.
[07/13 21:26:54]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:26:54]  Improved gap from 0 to 100
[07/13 21:26:55]  Improved number of small numbers from 30 to 57 out of a max of 80
[07/13 21:26:55]  Verifer returned sat in 0.557818 secs.
[07/13 21:26:55]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12022.574951    0.064209 -12047.574951 -3107.943878    0.000000           0.000000   25.000000        0.000214
1 -12022.574951    0.031982 -12022.574951 -3107.943878    0.000000           0.000000    0.000000      -99.999786
2 -11822.575195  199.999756 -11822.607269 -3107.943878    0.000000           0.000000    0.032074       -0.000031
3 -11722.575165  100.032104 -11822.574951 -3107.943878    0.000000           0.000000   99.999786        0.000000
4 -11222.559113  500.016052 -11722.574951 -3107.943878  300.015869         300.015869  199.999969      100.000183
5 -11222.559113    1.000000 -11522.575165 -3107.943878  300.015869         300.015869    0.000183        0.000183
6 -10621.994904  600.564209 -11522.574951 -3107.943878  700.580078         700.580078  199.999969      100.000183
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:26:55]  --------------------------------------------------------------------------------
[07/13 21:26:55]  Iteration: 253
[07/13 21:27:01]  Generator returned sat in 4.289253 secs.
[07/13 21:27:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:27:02]  Verifer returned unsat in 0.015638 secs.
[07/13 21:27:02]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:27:02]  --------------------------------------------------------------------------------
[07/13 21:27:02]  Iteration: 254
[07/13 21:27:06]  Generator returned sat in 2.506278 secs.
[07/13 21:27:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:27:07]  Improved number of small numbers from 29 to 64 out of a max of 79
[07/13 21:27:07]  Verifer returned sat in 0.531049 secs.
[07/13 21:27:07]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11922.574951    0.063965 -12022.575165 -3107.944092    0.000000           0.000000  100.000214      100.000000
1 -11922.574951    0.016113 -11922.575195 -3107.944092    0.000000           0.000000    0.000244        0.000000
2 -11822.559082  100.016113 -11822.575165 -3107.944092    0.000000           0.000000    0.016083        0.015869
3 -11756.435411   66.139754 -11756.467515 -3107.944092    0.000000           0.000000    0.032104      -33.860459
4 -11491.118129  265.333333 -11722.574951 -3107.944092    0.016052           0.016052  231.440769      131.440769
5 -11322.542969  400.000000 -11622.574951 -3107.944092    0.031982           0.031982  300.000000      200.000000
6 -10720.542969  602.000000 -11522.574951 -3107.944092  502.031982         502.031982  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:27:07]  --------------------------------------------------------------------------------
[07/13 21:27:07]  Iteration: 255
[07/13 21:27:20]  Generator returned sat in 10.090892 secs.
[07/13 21:27:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:27:20]  Improved gap from 131/16384 to 100
[07/13 21:27:20]  Improved number of small numbers from 45 to 80 out of a max of 80
[07/13 21:27:20]  Verifer returned sat in 0.208171 secs.
[07/13 21:27:20]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11756.467529    0.063721 -11856.499512 -3074.551758    0.000000           0.000000  100.031982      100.031738
1 -11756.467529    0.031982 -11756.499512 -3074.551758    0.000000           0.000000    0.031982        0.031738
2 -11456.499512  300.000000 -11756.499268 -3074.551758    0.000000           0.000000  299.999756      199.999756
3 -11357.467285  399.000000 -11556.499268 -3074.551758    0.031982           0.031982  199.000000      199.000000
4 -11157.499512  200.000000 -11556.499268 -3074.551758  198.999756         198.999756  200.000000      100.000000
5 -11157.499512  100.500000 -11387.499268 -3074.551758  198.999756         198.999756   31.000000        0.000000
6 -10318.499512  839.000000 -11356.499268 -3074.551758  738.000000         738.000000  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:27:20]  --------------------------------------------------------------------------------
[07/13 21:27:20]  Iteration: 256
[07/13 21:27:24]  Generator returned sat in 1.632444 secs.
[07/13 21:27:25]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:27:25]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:27:25]  Verifer returned sat in 0.095487 secs.
[07/13 21:27:25]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11756.467529    0.063721 -11856.499512 -3074.551758    0.000000           0.000000  100.031982      100.031738
1 -11756.467529    0.031982 -11756.499512 -3074.551758    0.000000           0.000000    0.031982        0.031738
2 -11456.499512  300.000000 -11756.499268 -3074.551758    0.000000           0.000000  299.999756      199.999756
3 -11357.467285  398.000000 -11556.499268 -3074.551758    1.031982           1.031982  198.000000      198.000000
4 -11157.499512  200.000000 -11556.499268 -3074.551758  198.999756         198.999756  200.000000      100.000000
5 -11157.499512  101.000000 -11387.499268 -3074.551758  198.999756         198.999756   31.000000        0.000000
6 -10317.999512  839.500000 -11356.499268 -3074.551758  738.499756         738.499756  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:27:25]  --------------------------------------------------------------------------------
[07/13 21:27:25]  Iteration: 257
[07/13 21:27:29]  Generator returned sat in 1.719249 secs.
[07/13 21:27:29]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:27:29]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:27:29]  Verifer returned sat in 0.131568 secs.
[07/13 21:27:29]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11756.467529    0.063477 -11856.499756 -3074.552002    0.000000           0.000000  100.032227      100.031738
1 -11756.467529    0.031738 -11756.499512 -3074.552002    0.000000           0.000000    0.031982        0.031738
2 -11456.499512  300.000000 -11756.499268 -3074.552002    0.000000           0.000000  299.999756      199.999756
3 -11357.467285  397.000000 -11556.499268 -3074.552002    2.031982           2.031982  197.000000      197.000000
4 -11157.499756  200.000000 -11556.499268 -3074.552002  198.999512         198.999512  200.000000      100.000000
5 -11157.499756  101.500000 -11387.499268 -3074.552002  198.999512         198.999512   31.000000        0.000000
6 -10317.499756  840.000000 -11356.499268 -3074.552002  738.999512         738.999512  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:27:29]  --------------------------------------------------------------------------------
[07/13 21:27:29]  Iteration: 258
[07/13 21:27:33]  Generator returned sat in 1.523237 secs.
[07/13 21:27:34]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:27:34]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:27:34]  Verifer returned sat in 0.095061 secs.
[07/13 21:27:34]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11756.467529    0.063477 -11856.500000 -3074.552246    0.000000           0.000000  100.032471      100.031738
1 -11756.467529    0.031738 -11756.499756 -3074.552246    0.000000           0.000000    0.032227        0.031738
2 -11456.499756  300.000000 -11756.499268 -3074.552246    0.000000           0.000000  299.999512      199.999512
3 -11358.467529  396.000000 -11556.499268 -3074.552246    2.031738           2.031738  196.000000      196.000000
4 -11158.483398  200.000000 -11556.499268 -3074.552246  198.015869         198.015869  200.000000      100.000000
5 -11158.483398  102.000000 -11387.499268 -3074.552246  198.015869         198.015869   31.000000        0.000000
6 -10317.983398  840.500000 -11356.499268 -3074.552246  738.515869         738.515869  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:27:34]  --------------------------------------------------------------------------------
[07/13 21:27:34]  Iteration: 259
[07/13 21:27:40]  Generator returned sat in 3.533959 secs.
[07/13 21:27:40]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:27:40]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:27:40]  Verifer returned sat in 0.104872 secs.
[07/13 21:27:40]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11756.467773    0.063477 -11856.500244 -3074.552246    0.000000           0.000000  100.032471      100.031738
1 -11756.467773    0.031494 -11756.499756 -3074.552246    0.000000           0.000000    0.031982        0.031738
2 -11456.500000  299.999756 -11756.499268 -3074.552246    0.000000           0.000000  299.999268      199.999512
3 -11358.467529  396.000000 -11556.499512 -3074.552246    2.031738           2.031738  196.000244      196.000244
4 -11158.483643  200.000000 -11556.499512 -3074.552246  198.015869         198.015869  200.000000      100.000000
5 -11158.483643  102.000000 -11387.499268 -3074.552246  198.015869         198.015869   30.999756        0.000000
6 -10266.983643  891.500000 -11356.499268 -3074.552246  789.515869         789.515869  299.999756      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:27:40]  --------------------------------------------------------------------------------
[07/13 21:27:40]  Iteration: 260
[07/13 21:27:47]  Generator returned sat in 3.872864 secs.
[07/13 21:27:47]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:27:47]  Improved gap from 259/16384 to 100
[07/13 21:27:47]  Improved number of small numbers from 67 to 78 out of a max of 80
[07/13 21:27:47]  Verifer returned sat in 0.217445 secs.
[07/13 21:27:47]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11756.499756    0.063232 -11856.500000 -3074.552246     0.000000           0.000000  100.000244      100.000000
1 -11756.499756    0.031738 -11856.218018 -3074.552246     0.000000           0.000000   99.718262        0.000000
2 -11656.499756  199.718262 -11721.833089 -3074.552246     0.000000           0.000000   65.333333        0.000000
3 -11456.468262  265.333333 -11656.499756 -3074.552246     0.031494           0.031494  200.000000      100.000000
4 -11056.500000  400.000000 -11556.499756 -3074.552246   199.999756         199.999756  300.000000      200.000000
5 -10454.500000  602.000000 -11356.500000 -3074.552246   702.000000         702.000000  200.000000      199.999756
6  -9549.500000  905.000000 -11356.499756 -3074.552246  1506.999756        1506.999756  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:27:47]  --------------------------------------------------------------------------------
[07/13 21:27:47]  Iteration: 261
[07/13 21:27:52]  Generator returned sat in 2.087530 secs.
[07/13 21:27:52]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:27:52]  Improved number of small numbers from 46 to 79 out of a max of 79
[07/13 21:27:52]  Verifer returned sat in 0.144424 secs.
[07/13 21:27:52]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11756.500000    0.063232 -11921.833008 -3009.219238    0.000000           0.000000  165.333008      165.333008
1 -11756.500000    0.031494 -11856.218262 -3009.219238    0.000000           0.000000   99.718262       65.333008
2 -11721.817139  134.401123 -11721.833252 -3009.219238    0.000000           0.000000    0.016113        0.015869
3 -11721.817139    0.007812 -11721.833008 -3009.219238    0.000000           0.000000    0.015869      -99.984131
4 -11321.313232  400.503906 -11621.833008 -3009.219238    0.519775           0.519775  300.000000      200.000000
5 -10918.809326  402.503906 -11421.833252 -3009.219238  403.023682         403.023682  100.000244      100.000000
6 -10514.305420  404.503906 -11421.833008 -3009.219238  707.527588         707.527588  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:27:52]  --------------------------------------------------------------------------------
[07/13 21:27:52]  Iteration: 262
[07/13 21:27:57]  Generator returned sat in 2.413004 secs.
[07/13 21:27:57]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:27:57]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:27:57]  Verifer returned sat in 0.094436 secs.
[07/13 21:27:57]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11756.500000    0.063232 -11921.833008 -3009.219238    0.000000           0.000000  165.333008      165.333008
1 -11756.500000    0.031494 -11856.218262 -3009.219238    0.000000           0.000000   99.718262       65.333008
2 -11721.817139  134.401123 -11721.833252 -3009.219238    0.000000           0.000000    0.016113        0.015869
3 -11721.817139    0.001953 -11721.833008 -3009.219238    0.000000           0.000000    0.015869      -99.984131
4 -11321.313232  400.503906 -11621.833008 -3009.219238    0.519775           0.519775  300.000000      200.000000
5 -10918.809326  402.503906 -11421.833252 -3009.219238  403.023682         403.023682  100.000244      100.000000
6 -10514.305420  404.503906 -11421.833008 -3009.219238  707.527588         707.527588  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:27:58]  --------------------------------------------------------------------------------
[07/13 21:27:58]  Iteration: 263
[07/13 21:28:02]  Generator returned sat in 2.091598 secs.
[07/13 21:28:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:28:02]  Verifer returned unsat in 0.020435 secs.
[07/13 21:28:02]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:28:02]  --------------------------------------------------------------------------------
[07/13 21:28:02]  Iteration: 264
[07/13 21:30:03]  Generator returned sat in 1.506832 secs.
[07/13 21:30:03]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:30:03]  Improved gap from 96 to 100
[07/13 21:30:04]  Improved number of small numbers from 67 to 80 out of a max of 80
[07/13 21:30:04]  Verifer returned sat in 0.151596 secs.
[07/13 21:30:04]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11921.833008    0.062988 -11921.833252 -3009.219238   0.000000           0.000000    0.000244        0.000244
1 -11821.833252  100.000000 -11821.848877 -3009.219238   0.000000           0.000000    0.015625        0.000000
2 -11771.567383   50.281494 -11818.192383 -3009.219238   0.000000           0.000000   46.625000      -49.734131
3 -11719.567383   98.625000 -11719.583252 -3009.219238   0.000000           0.000000    0.015869      -97.734131
4 -11521.833252  197.750000 -11621.833008 -3009.219238   0.000000           0.000000   99.999756        0.000000
5 -11225.817139  396.000000 -11421.833252 -3009.219238   0.015869           0.015869  196.000244      196.000244
6 -11221.801758  200.000000 -11421.833008 -3009.219238   0.031494           0.031494  199.999756      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:30:04]  --------------------------------------------------------------------------------
[07/13 21:30:04]  Iteration: 265
[07/13 21:30:09]  Generator returned sat in 2.388200 secs.
[07/13 21:30:09]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:30:09]  Verifer returned unsat in 0.016448 secs.
[07/13 21:30:09]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:30:09]  --------------------------------------------------------------------------------
[07/13 21:30:09]  Iteration: 266
[07/13 21:30:14]  Generator returned sat in 2.683767 secs.
[07/13 21:30:14]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:30:14]  Improved gap from 129/4096 to 100
[07/13 21:30:14]  Improved number of small numbers from 71 to 80 out of a max of 80
[07/13 21:30:14]  Verifer returned sat in 0.127507 secs.
[07/13 21:30:14]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -11921.833252    0.062744 -12121.833252 -3009.219482    0.000000           0.000000  200.000000      200.000000
1 -11821.833496  299.999756 -12021.833252 -3009.219482    0.000000           0.000000  199.999756      199.999756
2 -11722.135254  299.697998 -11921.833496 -3009.219482    0.000000           0.000000  199.698242      199.697998
3 -11722.135254  132.777778 -11921.833252 -3009.219482    0.000000           0.000000  199.697998       99.697998
4 -11722.135254  199.666667 -11821.833252 -3009.219482    0.000000           0.000000   99.697998       -0.302002
5 -11422.166504  300.000000 -11623.833252 -3009.219482   99.666748          99.666748  102.000000      100.000000
6 -11120.198242  302.000000 -11621.833252 -3009.219482  201.635010         201.635010  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:30:14]  --------------------------------------------------------------------------------
[07/13 21:30:14]  Iteration: 267
[07/13 21:30:19]  Generator returned sat in 2.121536 secs.
[07/13 21:30:19]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:30:19]  Verifer returned unsat in 0.017125 secs.
[07/13 21:30:19]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:30:19]  --------------------------------------------------------------------------------
[07/13 21:30:19]  Iteration: 268
[07/13 21:30:23]  Generator returned sat in 1.564461 secs.
[07/13 21:30:23]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:30:23]  Improved gap from 257/16384 to 100
[07/13 21:30:24]  Improved number of small numbers from 39 to 80 out of a max of 80
[07/13 21:30:24]  Verifer returned sat in 0.200123 secs.
[07/13 21:30:24]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12529.817627    0.062500 -12729.817383 -3009.219727    0.000000           0.000000  199.999756      199.999756
1 -12429.817383  300.000000 -12729.817383 -3009.219727    0.000000           0.000000  300.000000      200.000000
2 -12329.817627  399.999756 -12629.817383 -3009.219727    0.000000           0.000000  299.999756      199.999756
3 -12329.801758  300.000000 -12529.817383 -3009.219727    0.015625           0.015625  200.000000      100.000000
4 -12227.786133  302.000000 -12333.817383 -3009.219727    0.031250           0.031250  106.000000      102.000000
5 -11923.801758  304.000000 -12235.817627 -3009.219727  106.015625         106.015625  206.000244      200.000000
6 -11823.801758  306.000000 -12229.817383 -3009.219727  106.015869         106.015869  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:30:24]  --------------------------------------------------------------------------------
[07/13 21:30:24]  Iteration: 269
[07/13 21:30:32]  Generator returned sat in 6.168344 secs.
[07/13 21:30:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:30:33]  Improved gap from 1/64 to 100
[07/13 21:30:33]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:30:33]  Verifer returned sat in 0.183532 secs.
[07/13 21:30:33]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12529.817627     0.062500 -12729.817627 -3009.219727     0.000000           0.000000  200.000000      200.000000
1 -12529.817627   200.000000 -12729.817627 -3009.219727     0.000000           0.000000  200.000000      100.000000
2 -12529.817627   200.000000 -12629.817627 -3009.219727     0.000000           0.000000  100.000000        0.000000
3 -12529.786377   100.031250 -12529.817627 -3009.219727     0.000000           0.000000    0.031250      -99.968750
4 -12177.786377   352.015625 -12429.817627 -3009.219727     0.015625           0.015625  252.015625      152.015625
5 -11322.755127   855.031250 -12282.817627 -3009.219727   707.062500         707.062500  253.000000      200.000000
6  -9438.192627  1884.562500 -12229.817627 -3009.219727  2591.625000        2591.625000  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:30:33]  --------------------------------------------------------------------------------
[07/13 21:30:33]  Iteration: 270
[07/13 21:30:38]  Generator returned sat in 2.064507 secs.
[07/13 21:30:38]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:30:38]  Improved number of small numbers from 59 to 79 out of a max of 79
[07/13 21:30:38]  Verifer returned sat in 0.143123 secs.
[07/13 21:30:38]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12529.818115     0.062256 -12729.817871 -3009.219971     0.000000           0.000000  199.999756      199.999756
1 -12529.818115   199.999512 -12729.817871 -3009.219971     0.000000           0.000000  199.999756       99.999756
2 -12529.818115   199.999512 -12579.833496 -3009.219971     0.000000           0.000000   50.015381       -0.000244
3 -12529.817871    50.015625 -12529.817871 -3009.219971     0.000000           0.000000    0.000000     -100.000000
4 -12177.802246   352.015625 -12429.786621 -3009.219971     0.000244           0.000244  251.984131      152.015381
5 -11322.755371   855.046875 -12282.817871 -3009.219971   707.062500         707.062500  253.000000      200.000000
6  -9463.153809  1859.601562 -12229.817871 -3009.219971  2566.663818        2566.663818  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:30:38]  --------------------------------------------------------------------------------
[07/13 21:30:38]  Iteration: 271
[07/13 21:30:42]  Generator returned sat in 1.552848 secs.
[07/13 21:30:42]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:30:42]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:30:42]  Verifer returned sat in 0.115679 secs.
[07/13 21:30:42]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12529.818115     0.062256 -12729.817871 -3009.219971     0.000000           0.000000  199.999756      199.999756
1 -12529.818115   199.999512 -12729.817871 -3009.219971     0.000000           0.000000  199.999756       99.999756
2 -12529.818115   199.999512 -12554.825684 -3009.219971     0.000000           0.000000   25.007568       -0.000244
3 -12529.817871    25.007812 -12529.817871 -3009.219971     0.000000           0.000000    0.000000     -100.000000
4 -12177.802246   352.015625 -12429.786621 -3009.219971     0.000244           0.000244  251.984131      152.015381
5 -11322.755371   855.046875 -12282.817871 -3009.219971   707.062500         707.062500  253.000000      200.000000
6  -9475.657715  1847.097656 -12229.817871 -3009.219971  2554.160156        2554.160156  200.000000      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:30:43]  --------------------------------------------------------------------------------
[07/13 21:30:43]  Iteration: 272
[07/13 21:30:48]  Generator returned sat in 2.723141 secs.
[07/13 21:30:48]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:30:48]  Improved number of small numbers from 77 to 77 out of a max of 79
[07/13 21:30:48]  Verifer returned sat in 0.120438 secs.
[07/13 21:30:48]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12529.818359     0.062012 -12731.151449 -3009.219971     0.000000           0.000000  201.333089      199.999756
1 -12529.818359   199.999512 -12729.818115 -3009.219971     0.000000           0.000000  199.999756       99.999756
2 -12529.818359   199.999512 -12554.825928 -3009.219971     0.000000           0.000000   25.007568       -0.000244
3 -12529.818115    25.007812 -12529.818115 -3009.219971     0.000000           0.000000    0.000000     -100.000000
4 -12177.802490   352.015625 -12429.786865 -3009.219971     0.000244           0.000244  251.984131      152.015381
5 -11322.755615   855.046875 -12282.818115 -3009.219971   707.062500         707.062500  253.000000      200.000000
6  -9475.657959  1847.097656 -12229.817871 -3009.219971  2554.159912        2554.159912  200.000000      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:30:48]  --------------------------------------------------------------------------------
[07/13 21:30:48]  Iteration: 273
[07/13 21:30:52]  Generator returned sat in 1.542109 secs.
[07/13 21:30:53]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:30:53]  Improved gap from 0 to 100
[07/13 21:30:53]  Improved number of small numbers from 49 to 80 out of a max of 80
[07/13 21:30:53]  Verifer returned sat in 0.249761 secs.
[07/13 21:30:53]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12196.452881     0.061523 -12196.484131 -3009.220215        0.0                0.0    0.031250        0.031250
1 -12196.452881     0.015625 -12196.484131 -3009.220215        0.0                0.0    0.031250      -99.968750
2 -11996.484131   200.000000 -12096.483887 -3009.220215        0.0                0.0   99.999756        0.000000
3 -11996.483887   100.000000 -11996.484131 -3009.220215        0.0                0.0    0.000244      -99.999756
4 -11596.484131   400.000000 -11896.484131 -3009.220215        0.0                0.0  300.000000      200.000000
5 -10746.484131   850.000000 -11796.483887 -3009.220215      750.0              750.0  299.999756      200.000000
6  -8895.484131  1851.000000 -11696.483887 -3009.220215     2601.0             2601.0  199.999756      100.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:30:53]  --------------------------------------------------------------------------------
[07/13 21:30:53]  Iteration: 274
[07/13 21:30:57]  Generator returned sat in 1.815204 secs.
[07/13 21:30:58]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:30:58]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:30:58]  Verifer returned sat in 0.106900 secs.
[07/13 21:30:58]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12196.453369     0.061523 -12196.484131 -3009.220215        0.0                0.0    0.030762        0.030762
1 -12196.453369     0.015381 -12196.484131 -3009.220215        0.0                0.0    0.030762      -99.969238
2 -11996.468750   200.015381 -12095.718750 -3009.220215        0.0                0.0   99.250000        0.015381
3 -11996.468750    99.250000 -11996.484131 -3009.220215        0.0                0.0    0.015381      -99.984619
4 -11596.734131   399.750000 -11896.484131 -3009.220215        0.0                0.0  299.750000      199.750000
5 -10746.484131   850.250000 -11796.483887 -3009.220215      750.0              750.0  299.999756      200.000000
6  -8895.366699  1851.117432 -11696.483887 -3009.220215     2601.0             2601.0  200.117188      100.117432
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:30:58]  --------------------------------------------------------------------------------
[07/13 21:30:58]  Iteration: 275
[07/13 21:31:02]  Generator returned sat in 1.566461 secs.
[07/13 21:31:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:31:02]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:31:02]  Verifer returned sat in 0.101858 secs.
[07/13 21:31:02]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12196.453613     0.061279 -12196.484131 -3009.220459        0.0                0.0    0.030518        0.030518
1 -12196.453613     0.015137 -12196.484131 -3009.220459        0.0                0.0    0.030518      -99.969482
2 -11996.468750   200.015381 -12095.718994 -3009.220459        0.0                0.0   99.250244        0.015381
3 -11996.468750    97.750000 -11996.484131 -3009.220459        0.0                0.0    0.015381      -99.984619
4 -11597.234131   399.250000 -11896.484131 -3009.220459        0.0                0.0  299.250000      199.250000
5 -10746.484131   850.750000 -11796.484131 -3009.220459      750.0              750.0  300.000000      200.000000
6  -8894.366699  1852.117432 -11696.484131 -3009.220459     2601.0             2601.0  201.117432      101.117432
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:31:03]  --------------------------------------------------------------------------------
[07/13 21:31:03]  Iteration: 276
[07/13 21:31:07]  Generator returned sat in 1.625792 secs.
[07/13 21:31:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:31:07]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:31:07]  Verifer returned sat in 0.092461 secs.
[07/13 21:31:07]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12196.453857     0.061279 -12196.817708 -3009.220459        0.0                0.0    0.363851        0.030518
1 -12196.453857     0.014893 -12196.484375 -3009.220459        0.0                0.0    0.030518      -99.969482
2 -11996.468994   200.015381 -12095.718994 -3009.220459        0.0                0.0   99.250000        0.015381
3 -11996.468994    97.750000 -11996.484375 -3009.220459        0.0                0.0    0.015381      -99.984619
4 -11597.234375   399.250000 -11896.151042 -3009.220459        0.0                0.0  298.916667      199.250000
5 -10746.484375   850.750000 -11796.484131 -3009.220459      750.0              750.0  299.999756      200.000000
6  -8894.366943  1852.117432 -11696.484131 -3009.220459     2601.0             2601.0  201.117188      101.117432
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:31:07]  --------------------------------------------------------------------------------
[07/13 21:31:07]  Iteration: 277
[07/13 21:31:12]  Generator returned sat in 2.483827 secs.
[07/13 21:31:13]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:31:13]  Improved number of small numbers from 65 to 77 out of a max of 79
[07/13 21:31:13]  Verifer returned sat in 0.191636 secs.
[07/13 21:31:13]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12147.453613     0.061035 -12180.406087 -3058.220947     0.000000           0.000000   32.952474        0.030762
1 -12147.453613     0.030518 -12147.484375 -3058.220947     0.000000           0.000000    0.030762      -99.969238
2 -11947.453857   200.030518 -12046.719238 -3058.220947     0.000000           0.000000   99.265381        0.030518
3 -11947.453857    99.234863 -11947.484375 -3058.220947     0.000000           0.000000    0.030518      -99.969482
4 -11547.484375   400.000000 -11747.484375 -3058.220947     0.000000           0.000000  200.000000      200.000000
5 -10746.484375   801.000000 -11747.484375 -3058.220947   701.000000         701.000000  300.000000      200.000000
6  -8993.866943  1752.617432 -11647.484375 -3058.220947  2453.617188        2453.617188  200.000244      100.000244
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:31:13]  --------------------------------------------------------------------------------
[07/13 21:31:13]  Iteration: 278
[07/13 21:31:17]  Generator returned sat in 1.624537 secs.
[07/13 21:31:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:31:18]  Improved number of small numbers from 26 to 38 out of a max of 79
[07/13 21:31:18]  Verifer returned sat in 0.599393 secs.
[07/13 21:31:18]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12148.478760    0.060791 -12191.920522 -3214.771417    0.000000           0.000000   43.441762       43.441762
1 -12148.478760    0.007568 -12191.920522 -3158.213318    0.000000           0.000000   43.441762       -0.000139
2 -12148.470991   43.449531 -12148.478621 -3058.220947    0.000000           0.000000    0.007629        0.000000
3 -12148.463362    0.015259 -12148.470991 -2958.228760    0.000000           0.000000    0.007629       -0.000183
4 -12081.789066   66.681925 -12081.804325 -2924.902873    0.000000           0.000000    0.015259        0.000000
5 -11881.781436  200.015259 -12081.789066 -2924.902873    0.007629           0.007629  200.000000      100.000000
6 -11447.406141  434.375295 -11981.789062 -2924.902873  234.383057         234.383057  299.999865      199.999868
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:31:18]  --------------------------------------------------------------------------------
[07/13 21:31:18]  Iteration: 279
[07/13 21:31:28]  Generator returned sat in 7.513939 secs.
[07/13 21:31:28]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:31:28]  Improved gap from 125/16384 to 100
[07/13 21:31:29]  Improved number of small numbers from 24 to 51 out of a max of 80
[07/13 21:31:29]  Verifer returned sat in 0.547878 secs.
[07/13 21:31:29]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12281.789307     0.060791 -12481.789066 -2924.902873     0.000000           0.000000  199.999759      199.999759
1 -12281.789307     0.015381 -12441.789062 -2924.902873     0.000000           0.000000  159.999756       99.999759
2 -12081.789307   359.999756 -12281.789307 -2924.902873     0.000000           0.000000  200.000000      199.999759
3 -12081.789307     0.015198 -12281.789066 -2924.902873     0.000000           0.000000  199.999759       99.999759
4 -11980.751071   301.022797 -12181.789062 -2924.902873     0.015198           0.015198  201.022793      101.022797
5 -11247.705478   733.045593 -11996.789307 -2924.902873   534.083740         534.083740  215.000088      199.999847
6  -9638.114292  1609.591187 -11981.789062 -2924.902873  2043.674805        2043.674805  299.999966      199.999969
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:31:29]  --------------------------------------------------------------------------------
[07/13 21:31:29]  Iteration: 280
[07/13 21:31:42]  Generator returned sat in 10.340889 secs.
[07/13 21:31:42]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:31:42]  Verifer returned unsat in 0.010097 secs.
[07/13 21:31:42]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:31:42]  --------------------------------------------------------------------------------
[07/13 21:31:42]  Iteration: 281
[07/13 21:31:47]  Generator returned sat in 1.806354 secs.
[07/13 21:31:47]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:31:47]  Verifer returned unsat in 0.009336 secs.
[07/13 21:31:47]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:31:47]  --------------------------------------------------------------------------------
[07/13 21:31:47]  Iteration: 282
[07/13 21:31:52]  Generator returned sat in 2.228942 secs.
[07/13 21:31:52]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:31:52]  Improved number of small numbers from 38 to 79 out of a max of 79
[07/13 21:31:52]  Verifer returned sat in 0.145125 secs.
[07/13 21:31:52]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12281.789551    0.060547 -12431.562256 -2924.902832   0.000000           0.000000  149.772705      149.772705
1 -12281.789551    0.015137 -12331.562256 -2924.902832   0.000000           0.000000   49.772705       49.772705
2 -12081.789551  249.772705 -12231.562256 -2924.902832   0.000000           0.000000  149.772705      149.772705
3 -12081.789551   99.750000 -12131.562256 -2924.902832   0.000000           0.000000   49.772705       49.772705
4 -11931.547119  200.000000 -12032.077393 -2924.902832   0.015137           0.015137  100.515137      100.000000
5 -11931.547119  100.500000 -11931.592529 -2924.902832   0.015137           0.015137    0.030273        0.000000
6 -11730.062256  201.500000 -11931.562256 -2924.902832   0.030273           0.030273  201.469727      101.469727
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:31:52]  --------------------------------------------------------------------------------
[07/13 21:31:52]  Iteration: 283
[07/13 21:31:57]  Generator returned sat in 2.046892 secs.
[07/13 21:31:57]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:31:57]  Verifer returned unsat in 0.012275 secs.
[07/13 21:31:57]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:31:57]  --------------------------------------------------------------------------------
[07/13 21:31:57]  Iteration: 284
[07/13 21:32:02]  Generator returned sat in 1.856918 secs.
[07/13 21:32:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:02]  Verifer returned unsat in 0.007951 secs.
[07/13 21:32:02]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:02]  --------------------------------------------------------------------------------
[07/13 21:32:02]  Iteration: 285
[07/13 21:32:06]  Generator returned sat in 1.939531 secs.
[07/13 21:32:06]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:06]  Improved gap from 31/2048 to 100
[07/13 21:32:07]  Improved number of small numbers from 51 to 80 out of a max of 80
[07/13 21:32:07]  Verifer returned sat in 0.215826 secs.
[07/13 21:32:07]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12350.916504    0.060547 -12450.916504 -2924.903076    0.000000           0.000000  100.000000      100.000000
1 -12350.916504    0.030029 -12450.916504 -2924.903076    0.000000           0.000000  100.000000        0.000000
2 -12317.219482  133.697021 -12350.916504 -2924.903076    0.000000           0.000000   33.697021      -66.302979
3 -11950.886230  400.000000 -12150.916748 -2924.903076    0.030273           0.030273  200.000244      200.000000
4 -11750.416748  200.500000 -12150.916504 -2924.903076  200.000000         200.000000  200.499756      100.499756
5 -11750.416748  100.750000 -12050.916504 -2924.903076  200.000000         200.000000  100.499756        0.499756
6 -10998.791748  751.625000 -11950.916504 -2924.903076  652.125000         652.125000  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:32:07]  --------------------------------------------------------------------------------
[07/13 21:32:07]  Iteration: 286
[07/13 21:32:11]  Generator returned sat in 2.017135 secs.
[07/13 21:32:12]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:12]  Verifer returned unsat in 0.019550 secs.
[07/13 21:32:12]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:12]  --------------------------------------------------------------------------------
[07/13 21:32:12]  Iteration: 287
[07/13 21:32:24]  Generator returned sat in 9.724974 secs.
[07/13 21:32:24]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:24]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:32:24]  Verifer returned sat in 0.114234 secs.
[07/13 21:32:24]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12601.886230    0.060547 -12601.916504 -2773.903076    0.000000           0.000000    0.030273        0.030273
1 -12601.886230    0.015137 -12601.916504 -2773.903076    0.000000           0.000000    0.030273      -99.969727
2 -12201.916504  400.000000 -12500.886230 -2773.903076    0.000000           0.000000  298.969727      200.000000
3 -12201.901367  298.969727 -12302.416504 -2773.903076    0.015137           0.015137  100.500000      100.000000
4 -11901.416504  300.500000 -12301.916504 -2773.903076  100.500000         100.500000  300.000000      200.000000
5 -11900.401367  301.000000 -12200.386230 -2773.903076  100.515137         100.515137  199.469727      101.000000
6 -11798.355957  301.500000 -12101.916504 -2773.903076  100.530273         100.530273  203.030273      103.030273
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:32:25]  --------------------------------------------------------------------------------
[07/13 21:32:25]  Iteration: 288
[07/13 21:32:29]  Generator returned sat in 2.242388 secs.
[07/13 21:32:30]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:30]  Improved gap from 247/32768 to 100
[07/13 21:32:30]  Improved number of small numbers from 39 to 80 out of a max of 80
[07/13 21:32:30]  Verifer returned sat in 0.210147 secs.
[07/13 21:32:30]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -12601.901367    0.060059 -12701.901367 -2773.903564    0.000000           0.000000  100.000000       99.999756
1 -12601.901367    0.015137 -12701.901123 -2773.903564    0.000000           0.000000   99.999756       -0.000244
2 -12501.901367  199.999756 -12601.901123 -2773.903564    0.000000           0.000000   99.999756       -0.000244
3 -12203.886230  398.000000 -12401.901123 -2773.903564    0.014893           0.014893  198.000000      198.000000
4 -12201.871094  200.000000 -12401.901123 -2773.903564    0.030029           0.030029  200.000000      100.000000
5 -12201.871094  101.000000 -12301.901123 -2773.903564    0.030029           0.030029  100.000000        0.000000
6 -11449.871094  752.000000 -12201.901123 -2773.903564  452.030273         452.030273  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:32:30]  --------------------------------------------------------------------------------
[07/13 21:32:30]  Iteration: 289
[07/13 21:32:35]  Generator returned sat in 2.541044 secs.
[07/13 21:32:35]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:35]  Verifer returned unsat in 0.020556 secs.
[07/13 21:32:35]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:35]  --------------------------------------------------------------------------------
[07/13 21:32:35]  Iteration: 290
[07/13 21:32:40]  Generator returned sat in 1.836876 secs.
[07/13 21:32:40]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:40]  Verifer returned unsat in 0.015787 secs.
[07/13 21:32:40]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:40]  --------------------------------------------------------------------------------
[07/13 21:32:40]  Iteration: 291
[07/13 21:32:45]  Generator returned sat in 1.924069 secs.
[07/13 21:32:45]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:45]  Verifer returned unsat in 0.008592 secs.
[07/13 21:32:45]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:45]  --------------------------------------------------------------------------------
[07/13 21:32:45]  Iteration: 292
[07/13 21:32:49]  Generator returned sat in 1.875067 secs.
[07/13 21:32:49]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:49]  Verifer returned unsat in 0.012440 secs.
[07/13 21:32:49]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:49]  --------------------------------------------------------------------------------
[07/13 21:32:49]  Iteration: 293
[07/13 21:32:55]  Generator returned sat in 2.724748 secs.
[07/13 21:32:55]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:55]  Verifer returned unsat in 0.009984 secs.
[07/13 21:32:55]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:32:55]  --------------------------------------------------------------------------------
[07/13 21:32:55]  Iteration: 294
[07/13 21:32:59]  Generator returned sat in 1.709419 secs.
[07/13 21:33:00]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:33:00]  Improved gap from 123/16384 to 100
[07/13 21:33:00]  Improved number of small numbers from 44 to 80 out of a max of 80
[07/13 21:33:00]  Verifer returned sat in 0.229784 secs.
[07/13 21:33:00]  Counter example:
    arrival_0,t     cwnd_0,t   service_0,t     wasted_t    losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -15317.794434     0.060059 -15417.794434 -2873.913818     0.000000           0.000000  100.000000      100.000000
1 -15317.794434    99.999756 -15417.794434 -2873.913818     0.000000           0.000000  100.000000        0.000000
2 -15017.794678   399.999756 -15217.794434 -2873.913818     0.000000           0.000000  199.999756      199.999756
3 -15017.764404   200.000000 -15217.794434 -2873.913818     0.030029           0.030029  200.000000      100.000000
4 -14516.764404   501.000000 -15117.794434 -2873.913818   301.030029         301.030029  300.000000      200.000000
5 -13363.764404  1153.000000 -15011.794434 -2873.913818  1354.030029        1354.030029  294.000000      200.000000
6 -10953.764404  2410.000000 -14917.794434 -2873.913818  3664.030029        3664.030029  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:33:00]  --------------------------------------------------------------------------------
[07/13 21:33:00]  Iteration: 295
[07/13 21:33:21]  Generator returned sat in 17.963734 secs.
[07/13 21:33:21]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:33:21]  Improved number of small numbers from 43 to 79 out of a max of 79
[07/13 21:33:21]  Verifer returned sat in 0.158017 secs.
[07/13 21:33:21]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t    wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -15726.721436    0.059814 -15826.751465 -2773.86377    0.000000           0.000000  100.030029      100.030029
1 -15726.721436    0.029785 -15726.751465 -2773.86377    0.000000           0.000000    0.030029        0.030029
2 -15426.751465  300.000000 -15626.751465 -2773.86377    0.000000           0.000000  200.000000      200.000000
3 -15426.721436  200.000000 -15626.751465 -2773.86377    0.030029           0.030029  200.000000      100.000000
4 -15426.721436  101.500000 -15526.751465 -2773.86377    0.030029           0.030029  100.000000        0.000000
5 -14873.971436  552.750000 -15326.751465 -2773.86377  252.780029         252.780029  200.000000      200.000000
6 -14599.126465  277.875000 -15326.751465 -2773.86377  449.750000         449.750000  277.875000      177.875000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:33:21]  --------------------------------------------------------------------------------
[07/13 21:33:21]  Iteration: 296
[07/13 21:33:28]  Generator returned sat in 4.400134 secs.
[07/13 21:33:29]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:33:29]  Verifer returned unsat in 0.016775 secs.
[07/13 21:33:29]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:33:29]  --------------------------------------------------------------------------------
[07/13 21:33:29]  Iteration: 297
[07/13 21:33:57]  Generator returned sat in 25.336165 secs.
[07/13 21:33:57]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:33:57]  Improved gap from 245/8192 to 48.4375
[07/13 21:33:57]  Improved number of small numbers from 47 to 67 out of a max of 80
[07/13 21:33:57]  Verifer returned sat in 0.404075 secs.
[07/13 21:33:57]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -15725.218994    0.059570 -16025.218750 -2836.043213        0.0                0.0  299.999756      199.999878
1 -15725.218994    0.030029 -15925.218750 -2836.043213        0.0                0.0  199.999756       99.999878
2 -15525.218994  399.999756 -15725.218994 -2836.043213        0.0                0.0  200.000000      199.999878
3 -15525.218994  187.880371 -15725.218750 -2836.043213        0.0                0.0  199.999756       99.999878
4 -15525.218994   95.940186 -15526.751465 -2836.043213        0.0                0.0    1.532471       -0.000122
5 -15476.781372   49.970093 -15525.218872 -2784.480713        0.0                0.0   48.437500        0.000000
6 -15476.781372   26.985046 -15476.781372 -2784.480713        0.0                0.0    0.000000     -100.000000
high_util=False, low_loss=True, ramp_up=False, ramp_down=True, measured_loss_rate=0.
[07/13 21:33:58]  --------------------------------------------------------------------------------
[07/13 21:33:58]  Iteration: 298
[07/13 21:34:03]  Generator returned sat in 2.688503 secs.
[07/13 21:34:03]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:03]  Verifer returned unsat in 0.020082 secs.
[07/13 21:34:03]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:03]  --------------------------------------------------------------------------------
[07/13 21:34:03]  Iteration: 299
[07/13 21:34:08]  Generator returned sat in 1.973372 secs.
[07/13 21:34:08]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:08]  Verifer returned unsat in 0.011962 secs.
[07/13 21:34:08]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:08]  --------------------------------------------------------------------------------
[07/13 21:34:08]  Iteration: 300
[07/13 21:34:13]  Generator returned sat in 2.097844 secs.
[07/13 21:34:13]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:13]  Verifer returned unsat in 0.009943 secs.
[07/13 21:34:13]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:13]  --------------------------------------------------------------------------------
[07/13 21:34:13]  Iteration: 301
[07/13 21:34:18]  Generator returned sat in 2.085000 secs.
[07/13 21:34:18]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:18]  Verifer returned unsat in 0.013926 secs.
[07/13 21:34:18]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:18]  --------------------------------------------------------------------------------
[07/13 21:34:18]  Iteration: 302
[07/13 21:34:23]  Generator returned sat in 2.041568 secs.
[07/13 21:34:23]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:23]  Verifer returned unsat in 0.009156 secs.
[07/13 21:34:23]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:23]  --------------------------------------------------------------------------------
[07/13 21:34:23]  Iteration: 303
[07/13 21:34:28]  Generator returned sat in 2.023523 secs.
[07/13 21:34:28]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:28]  Verifer returned unsat in 0.009120 secs.
[07/13 21:34:28]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:28]  --------------------------------------------------------------------------------
[07/13 21:34:28]  Iteration: 304
[07/13 21:34:33]  Generator returned sat in 2.110086 secs.
[07/13 21:34:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:33]  Verifer returned unsat in 0.011350 secs.
[07/13 21:34:33]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:33]  --------------------------------------------------------------------------------
[07/13 21:34:33]  Iteration: 305
[07/13 21:34:38]  Generator returned sat in 2.267041 secs.
[07/13 21:34:38]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:38]  Verifer returned unsat in 0.007574 secs.
[07/13 21:34:38]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:38]  --------------------------------------------------------------------------------
[07/13 21:34:38]  Iteration: 306
[07/13 21:34:43]  Generator returned sat in 2.053663 secs.
[07/13 21:34:43]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:43]  Verifer returned unsat in 0.008153 secs.
[07/13 21:34:43]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:43]  --------------------------------------------------------------------------------
[07/13 21:34:43]  Iteration: 307
[07/13 21:34:49]  Generator returned sat in 2.567110 secs.
[07/13 21:34:49]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:49]  Verifer returned unsat in 0.008781 secs.
[07/13 21:34:49]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:49]  --------------------------------------------------------------------------------
[07/13 21:34:49]  Iteration: 308
[07/13 21:34:54]  Generator returned sat in 2.419135 secs.
[07/13 21:34:55]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:55]  Verifer returned unsat in 0.009015 secs.
[07/13 21:34:55]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:34:55]  --------------------------------------------------------------------------------
[07/13 21:34:55]  Iteration: 309
[07/13 21:34:59]  Generator returned sat in 2.224196 secs.
[07/13 21:35:00]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:00]  Verifer returned unsat in 0.011261 secs.
[07/13 21:35:00]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:00]  --------------------------------------------------------------------------------
[07/13 21:35:00]  Iteration: 310
[07/13 21:35:04]  Generator returned sat in 2.011986 secs.
[07/13 21:35:04]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:05]  Verifer returned unsat in 0.011252 secs.
[07/13 21:35:05]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:05]  --------------------------------------------------------------------------------
[07/13 21:35:05]  Iteration: 311
[07/13 21:35:09]  Generator returned sat in 2.135810 secs.
[07/13 21:35:09]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:10]  Verifer returned unsat in 0.006966 secs.
[07/13 21:35:10]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:10]  --------------------------------------------------------------------------------
[07/13 21:35:10]  Iteration: 312
[07/13 21:35:14]  Generator returned sat in 2.016358 secs.
[07/13 21:35:14]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:14]  Verifer returned unsat in 0.009425 secs.
[07/13 21:35:14]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:14]  --------------------------------------------------------------------------------
[07/13 21:35:14]  Iteration: 313
[07/13 21:35:19]  Generator returned sat in 1.936012 secs.
[07/13 21:35:19]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:19]  Verifer returned unsat in 0.006442 secs.
[07/13 21:35:19]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:19]  --------------------------------------------------------------------------------
[07/13 21:35:19]  Iteration: 314
[07/13 21:35:27]  Generator returned sat in 4.954210 secs.
[07/13 21:35:27]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:27]  Verifer returned unsat in 0.008010 secs.
[07/13 21:35:27]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:27]  --------------------------------------------------------------------------------
[07/13 21:35:27]  Iteration: 315
[07/13 21:35:32]  Generator returned sat in 2.039550 secs.
[07/13 21:35:32]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:32]  Verifer returned unsat in 0.009112 secs.
[07/13 21:35:32]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:32]  --------------------------------------------------------------------------------
[07/13 21:35:32]  Iteration: 316
[07/13 21:35:37]  Generator returned sat in 2.062743 secs.
[07/13 21:35:37]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:37]  Verifer returned unsat in 0.010526 secs.
[07/13 21:35:37]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:37]  --------------------------------------------------------------------------------
[07/13 21:35:37]  Iteration: 317
[07/13 21:35:42]  Generator returned sat in 1.937770 secs.
[07/13 21:35:42]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:42]  Verifer returned unsat in 0.012466 secs.
[07/13 21:35:42]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:42]  --------------------------------------------------------------------------------
[07/13 21:35:42]  Iteration: 318
[07/13 21:35:47]  Generator returned sat in 1.993312 secs.
[07/13 21:35:47]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:47]  Verifer returned unsat in 0.011656 secs.
[07/13 21:35:47]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:47]  --------------------------------------------------------------------------------
[07/13 21:35:47]  Iteration: 319
[07/13 21:35:52]  Generator returned sat in 1.903602 secs.
[07/13 21:35:52]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:52]  Verifer returned unsat in 0.009794 secs.
[07/13 21:35:52]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:52]  --------------------------------------------------------------------------------
[07/13 21:35:52]  Iteration: 320
[07/13 21:35:57]  Generator returned sat in 2.204900 secs.
[07/13 21:35:57]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:57]  Verifer returned unsat in 0.007432 secs.
[07/13 21:35:57]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:35:57]  --------------------------------------------------------------------------------
[07/13 21:35:57]  Iteration: 321
[07/13 21:36:02]  Generator returned sat in 1.930447 secs.
[07/13 21:36:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:36:02]  Verifer returned unsat in 0.007763 secs.
[07/13 21:36:02]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:36:02]  --------------------------------------------------------------------------------
[07/13 21:36:02]  Iteration: 322
[07/13 21:36:07]  Generator returned sat in 1.953645 secs.
[07/13 21:36:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:36:07]  Verifer returned unsat in 0.005937 secs.
[07/13 21:36:07]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:36:07]  --------------------------------------------------------------------------------
[07/13 21:36:07]  Iteration: 323
[07/13 21:36:17]  Generator returned sat in 8.016893 secs.
[07/13 21:36:18]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:36:18]  Improved gap from 61/4096 to 100
[07/13 21:36:18]  Improved number of small numbers from 44 to 80 out of a max of 80
[07/13 21:36:18]  Verifer returned sat in 0.187113 secs.
[07/13 21:36:18]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -15684.413818    0.059326 -15784.413818 -3113.285889    0.000000           0.000000  100.000000       99.999756
1 -15684.413818    0.029785 -15784.413574 -3113.285889    0.000000           0.000000   99.999756       -0.000244
2 -15584.413818  199.999756 -15684.413574 -3113.285889    0.000000           0.000000   99.999756       -0.000244
3 -15186.443604  398.000000 -15484.413574 -3113.285889   99.969971          99.969971  198.000000      198.000000
4 -14986.473389  200.000000 -15484.413574 -3113.285889  297.940186         297.940186  200.000000      100.000000
5 -14986.473389  101.000000 -15384.413574 -3113.285889  297.940186         297.940186  100.000000        0.000000
6 -14232.973389  753.500000 -15284.413574 -3113.285889  751.440430         751.440430  299.999756      199.999756
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:36:18]  --------------------------------------------------------------------------------
[07/13 21:36:18]  Iteration: 324
[07/13 21:36:24]  Generator returned sat in 3.733946 secs.
[07/13 21:36:25]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:36:25]  Improved number of small numbers from 79 to 79 out of a max of 79
[07/13 21:36:25]  Verifer returned sat in 0.138583 secs.
[07/13 21:36:25]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -15684.413818    0.059326 -15784.413818 -3113.285889    0.000000           0.000000  100.000000       99.999756
1 -15684.413818    0.029785 -15784.413574 -3113.285889    0.000000           0.000000   99.999756       -0.000244
2 -15582.428711  201.984863 -15684.413574 -3113.285889    0.000000           0.000000  101.984863        1.984863
3 -15186.443604  396.000000 -15484.413574 -3113.285889  101.969971         101.969971  196.000000      196.000000
4 -14986.473389  200.000000 -15484.413574 -3113.285889  297.940186         297.940186  200.000000      100.000000
5 -14986.473389  102.000000 -15384.413574 -3113.285889  297.940186         297.940186  100.000000        0.000000
6 -14231.473389  755.000000 -15284.413574 -3113.285889  752.940186         752.940186  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:36:25]  --------------------------------------------------------------------------------
[07/13 21:36:25]  Iteration: 325
[07/13 21:36:30]  Generator returned sat in 2.087261 secs.
[07/13 21:36:30]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:36:30]  Improved gap from 397311/4096 to 100
[07/13 21:36:30]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:36:30]  Verifer returned sat in 0.126667 secs.
[07/13 21:36:30]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -15687.413818    0.059082 -15787.413818 -3110.285889    0.000000           0.000000  100.000000      100.000000
1 -15687.413818    3.059082 -15787.413818 -3110.285889    0.000000           0.000000  100.000000        0.000000
2 -15582.428955  204.984863 -15687.413818 -3110.285889    0.000000           0.000000  104.984863        4.984863
3 -15186.443848  399.000000 -15487.413818 -3110.285889  101.969971         101.969971  199.000000      199.000000
4 -14986.473633  201.000000 -15484.413818 -3110.285889  299.940186         299.940186  198.000000      101.000000
5 -14986.473633  102.000000 -15384.413818 -3110.285889  299.940186         299.940186   98.000000        1.000000
6 -14225.473633  761.000000 -15287.413818 -3110.285889  761.940186         761.940186  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:36:30]  --------------------------------------------------------------------------------
[07/13 21:36:30]  Iteration: 326
[07/13 21:36:43]  Generator returned sat in 9.828960 secs.
[07/13 21:36:43]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:36:43]  Improved gap from 1/1600 to 100
[07/13 21:36:43]  Improved number of small numbers from 70 to 78 out of a max of 80
[07/13 21:36:43]  Verifer returned sat in 0.220782 secs.
[07/13 21:36:43]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -15784.411377    0.058838 -15784.413818 -3113.286133       0.00               0.00    0.002441        0.002441
1 -15784.411377    0.001221 -15784.412354 -3113.286133       0.00               0.00    0.000977      -99.997559
2 -15684.412598   99.999756 -15684.413818 -3113.286133       0.00               0.00    0.001221      -99.998779
3 -15584.413818  100.000000 -15584.413818 -3113.286133       0.00               0.00    0.000000     -100.000000
4 -14984.413818  600.000000 -15484.413818 -3113.286133     200.00             200.00  300.000000      200.000000
5 -14984.413818    0.010000 -15384.413818 -3113.286133     200.00             200.00  200.000000      100.000000
6 -14384.393818  600.020000 -15184.414062 -3113.286133     600.02             600.02  200.000244      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:36:44]  --------------------------------------------------------------------------------
[07/13 21:36:44]  Iteration: 327
[07/13 21:36:51]  Generator returned sat in 4.632179 secs.
[07/13 21:36:51]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:36:51]  Verifer returned unsat in 0.011590 secs.
[07/13 21:36:51]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:36:51]  --------------------------------------------------------------------------------
[07/13 21:36:51]  Iteration: 328
[07/13 21:36:56]  Generator returned sat in 2.317101 secs.
[07/13 21:36:56]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:36:56]  Verifer returned unsat in 0.008871 secs.
[07/13 21:36:56]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:36:56]  --------------------------------------------------------------------------------
[07/13 21:36:56]  Iteration: 329
[07/13 21:37:02]  Generator returned sat in 2.506590 secs.
[07/13 21:37:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:37:02]  Verifer returned unsat in 0.010875 secs.
[07/13 21:37:02]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:37:02]  --------------------------------------------------------------------------------
[07/13 21:37:02]  Iteration: 330
[07/13 21:37:07]  Generator returned sat in 2.300868 secs.
[07/13 21:37:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:37:07]  Verifer returned unsat in 0.013457 secs.
[07/13 21:37:07]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:37:07]  --------------------------------------------------------------------------------
[07/13 21:37:07]  Iteration: 331
[07/13 21:37:12]  Generator returned sat in 1.865313 secs.
[07/13 21:37:12]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:37:12]  Verifer returned unsat in 0.011851 secs.
[07/13 21:37:12]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:37:12]  --------------------------------------------------------------------------------
[07/13 21:37:12]  Iteration: 332
[07/13 21:37:28]  Generator returned sat in 13.376292 secs.
[07/13 21:37:28]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:37:28]  Verifer returned unsat in 0.006895 secs.
[07/13 21:37:28]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:37:28]  --------------------------------------------------------------------------------
[07/13 21:37:28]  Iteration: 333
[07/13 21:37:43]  Generator returned sat in 11.996274 secs.
[07/13 21:37:43]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:37:43]  Improved number of small numbers from 35 to 79 out of a max of 79
[07/13 21:37:43]  Verifer returned sat in 0.202102 secs.
[07/13 21:37:43]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -15534.149170    0.058594 -15634.148926 -3013.286133    0.000000           0.000000   99.999756       99.999756
1 -15534.149170    0.014648 -15634.148926 -3013.286133    0.000000           0.000000   99.999756       -0.000244
2 -15234.148926  400.000000 -15434.148926 -3013.286133    0.000000           0.000000  200.000000      200.000000
3 -15234.148926    0.014648 -15434.148926 -3013.286133    0.000000           0.000000  200.000000      100.000000
4 -14833.619629  400.529297 -15234.413818 -3013.286133  200.544189         200.544189  200.250000      199.985107
5 -14833.604980  200.264648 -15228.148926 -3013.286133  200.544189         200.544189  193.999756       99.999756
6 -14020.575684  813.029297 -15134.148926 -3013.286133  813.573730         813.573730  299.999512      199.999512
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:37:44]  --------------------------------------------------------------------------------
[07/13 21:37:44]  Iteration: 334
[07/13 21:37:50]  Generator returned sat in 3.359975 secs.
[07/13 21:37:50]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:37:50]  Verifer returned unsat in 0.010818 secs.
[07/13 21:37:50]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:37:50]  --------------------------------------------------------------------------------
[07/13 21:37:50]  Iteration: 335
[07/13 21:37:55]  Generator returned sat in 2.062168 secs.
[07/13 21:37:55]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:37:55]  Verifer returned unsat in 0.009759 secs.
[07/13 21:37:55]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:37:55]  --------------------------------------------------------------------------------
[07/13 21:37:55]  Iteration: 336
[07/13 21:38:00]  Generator returned sat in 1.984632 secs.
[07/13 21:38:00]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:00]  Verifer returned unsat in 0.008131 secs.
[07/13 21:38:00]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:00]  --------------------------------------------------------------------------------
[07/13 21:38:00]  Iteration: 337
[07/13 21:38:05]  Generator returned sat in 2.549654 secs.
[07/13 21:38:06]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:06]  Verifer returned unsat in 0.011335 secs.
[07/13 21:38:06]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:06]  --------------------------------------------------------------------------------
[07/13 21:38:06]  Iteration: 338
[07/13 21:38:11]  Generator returned sat in 2.625512 secs.
[07/13 21:38:11]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:11]  Verifer returned unsat in 0.009974 secs.
[07/13 21:38:11]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:11]  --------------------------------------------------------------------------------
[07/13 21:38:11]  Iteration: 339
[07/13 21:38:16]  Generator returned sat in 2.476703 secs.
[07/13 21:38:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:17]  Verifer returned unsat in 0.009603 secs.
[07/13 21:38:17]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:17]  --------------------------------------------------------------------------------
[07/13 21:38:17]  Iteration: 340
[07/13 21:38:22]  Generator returned sat in 2.664349 secs.
[07/13 21:38:22]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:22]  Verifer returned unsat in 0.009756 secs.
[07/13 21:38:22]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:22]  --------------------------------------------------------------------------------
[07/13 21:38:22]  Iteration: 341
[07/13 21:38:27]  Generator returned sat in 2.060708 secs.
[07/13 21:38:27]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:27]  Verifer returned unsat in 0.016906 secs.
[07/13 21:38:27]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:27]  --------------------------------------------------------------------------------
[07/13 21:38:27]  Iteration: 342
[07/13 21:38:32]  Generator returned sat in 1.970103 secs.
[07/13 21:38:32]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:32]  Verifer returned unsat in 0.008843 secs.
[07/13 21:38:32]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:32]  --------------------------------------------------------------------------------
[07/13 21:38:32]  Iteration: 343
[07/13 21:38:37]  Generator returned sat in 2.052723 secs.
[07/13 21:38:37]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:37]  Verifer returned unsat in 0.017109 secs.
[07/13 21:38:37]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:38:37]  --------------------------------------------------------------------------------
[07/13 21:38:37]  Iteration: 344
[07/13 21:38:43]  Generator returned sat in 2.473236 secs.
[07/13 21:38:43]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:38:43]  Verifer returned unsat in 0.008916 secs.
[07/13 21:38:43]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:38:43]  --------------------------------------------------------------------------------
[07/13 21:38:43]  Iteration: 345
[07/13 21:38:48]  Generator returned sat in 2.239899 secs.
[07/13 21:38:48]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:38:48]  Verifer returned unsat in 0.009442 secs.
[07/13 21:38:48]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:38:48]  --------------------------------------------------------------------------------
[07/13 21:38:48]  Iteration: 346
[07/13 21:38:53]  Generator returned sat in 2.143011 secs.
[07/13 21:38:53]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:38:53]  Verifer returned unsat in 0.007895 secs.
[07/13 21:38:53]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:38:53]  --------------------------------------------------------------------------------
[07/13 21:38:53]  Iteration: 347
[07/13 21:38:59]  Generator returned sat in 3.032322 secs.
[07/13 21:38:59]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:38:59]  Improved gap from 0 to 48.4375
[07/13 21:38:59]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:38:59]  Verifer returned sat in 0.146186 secs.
[07/13 21:38:59]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -15078.502686    0.058594 -15278.502686 -3065.848389        0.0                0.0  200.000000      200.000000
1 -15078.502686    0.029297 -15178.502686 -3065.848389        0.0                0.0  100.000000      100.000000
2 -14880.006592  298.496094 -15078.502686 -3065.848389        0.0                0.0  198.496094      198.496094
3 -14880.006592  190.882812 -14978.502686 -3065.848389        0.0                0.0   98.496094       98.496094
4 -14880.006592   96.941406 -14880.035889 -3065.848389        0.0                0.0    0.029297       -1.503906
5 -14830.065186   49.970703 -14878.502686 -3014.285889        0.0                0.0   48.437500        0.000000
6 -14830.065186   26.485352 -14830.065186 -3014.285889        0.0                0.0    0.000000     -100.000000
high_util=False, low_loss=True, ramp_up=False, ramp_down=True, measured_loss_rate=0.
[07/13 21:39:00]  --------------------------------------------------------------------------------
[07/13 21:39:00]  Iteration: 348
[07/13 21:39:05]  Generator returned sat in 2.371251 secs.
[07/13 21:39:05]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:05]  Improved gap from 392825/8192 to 48.4375
[07/13 21:39:05]  Improved number of small numbers from 80 to 80 out of a max of 80
[07/13 21:39:05]  Verifer returned sat in 0.159768 secs.
[07/13 21:39:05]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t  losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -15100.925537    0.058594 -15300.925537 -3064.285889        0.0                0.0  200.000000           200.0
1 -15100.925537    0.029297 -15200.925537 -3064.285889        0.0                0.0  100.000000           100.0
2 -14900.925537  300.000000 -15195.917725 -3064.285889        0.0                0.0  294.992188           200.0
3 -14900.925537  193.882812 -15000.925537 -3064.285889        0.0                0.0  100.000000           100.0
4 -14900.925537   97.941406 -14900.954834 -3064.285889        0.0                0.0    0.029297             0.0
5 -14850.984131   49.970703 -14899.421631 -3014.227295        0.0                0.0   48.437500             0.0
6 -14850.984131   25.985352 -14850.984131 -3014.227295        0.0                0.0    0.000000          -100.0
high_util=False, low_loss=True, ramp_up=False, ramp_down=True, measured_loss_rate=0.
[07/13 21:39:06]  --------------------------------------------------------------------------------
[07/13 21:39:06]  Iteration: 349
[07/13 21:39:12]  Generator returned sat in 2.928346 secs.
[07/13 21:39:12]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:12]  Verifer returned unsat in 0.010766 secs.
[07/13 21:39:12]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:12]  --------------------------------------------------------------------------------
[07/13 21:39:12]  Iteration: 350
[07/13 21:39:17]  Generator returned sat in 2.367640 secs.
[07/13 21:39:17]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:17]  Verifer returned unsat in 0.012159 secs.
[07/13 21:39:17]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:17]  --------------------------------------------------------------------------------
[07/13 21:39:17]  Iteration: 351
[07/13 21:39:22]  Generator returned sat in 2.092537 secs.
[07/13 21:39:22]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:22]  Verifer returned unsat in 0.021593 secs.
[07/13 21:39:22]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:22]  --------------------------------------------------------------------------------
[07/13 21:39:22]  Iteration: 352
[07/13 21:39:28]  Generator returned sat in 2.335105 secs.
[07/13 21:39:28]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:28]  Verifer returned unsat in 0.011448 secs.
[07/13 21:39:28]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:28]  --------------------------------------------------------------------------------
[07/13 21:39:28]  Iteration: 353
[07/13 21:39:33]  Generator returned sat in 2.103472 secs.
[07/13 21:39:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:33]  Verifer returned unsat in 0.013077 secs.
[07/13 21:39:33]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:33]  --------------------------------------------------------------------------------
[07/13 21:39:33]  Iteration: 354
[07/13 21:39:38]  Generator returned sat in 2.128197 secs.
[07/13 21:39:38]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:38]  Verifer returned unsat in 0.010524 secs.
[07/13 21:39:38]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:39]  --------------------------------------------------------------------------------
[07/13 21:39:39]  Iteration: 355
[07/13 21:39:45]  Generator returned sat in 3.576906 secs.
[07/13 21:39:45]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:45]  Verifer returned unsat in 0.007672 secs.
[07/13 21:39:45]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:45]  --------------------------------------------------------------------------------
[07/13 21:39:45]  Iteration: 356
[07/13 21:39:50]  Generator returned sat in 2.085962 secs.
[07/13 21:39:50]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:50]  Verifer returned unsat in 0.009223 secs.
[07/13 21:39:50]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:50]  --------------------------------------------------------------------------------
[07/13 21:39:50]  Iteration: 357
[07/13 21:39:55]  Generator returned sat in 2.229910 secs.
[07/13 21:39:55]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:55]  Verifer returned unsat in 0.012485 secs.
[07/13 21:39:55]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:39:55]  --------------------------------------------------------------------------------
[07/13 21:39:55]  Iteration: 358
[07/13 21:40:01]  Generator returned sat in 2.382355 secs.
[07/13 21:40:01]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:01]  Verifer returned unsat in 0.009915 secs.
[07/13 21:40:01]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:01]  --------------------------------------------------------------------------------
[07/13 21:40:01]  Iteration: 359
[07/13 21:40:08]  Generator returned sat in 3.820065 secs.
[07/13 21:40:08]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:08]  Verifer returned unsat in 0.010753 secs.
[07/13 21:40:08]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:08]  --------------------------------------------------------------------------------
[07/13 21:40:08]  Iteration: 360
[07/13 21:40:13]  Generator returned sat in 2.082837 secs.
[07/13 21:40:13]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:13]  Verifer returned unsat in 0.008701 secs.
[07/13 21:40:13]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:13]  --------------------------------------------------------------------------------
[07/13 21:40:13]  Iteration: 361
[07/13 21:40:19]  Generator returned sat in 3.291982 secs.
[07/13 21:40:19]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:19]  Verifer returned unsat in 0.007198 secs.
[07/13 21:40:19]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:19]  --------------------------------------------------------------------------------
[07/13 21:40:19]  Iteration: 362
[07/13 21:40:24]  Generator returned sat in 2.037705 secs.
[07/13 21:40:24]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:24]  Verifer returned unsat in 0.006820 secs.
[07/13 21:40:24]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:24]  --------------------------------------------------------------------------------
[07/13 21:40:24]  Iteration: 363
[07/13 21:40:29]  Generator returned sat in 2.097293 secs.
[07/13 21:40:29]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:29]  Verifer returned unsat in 0.009559 secs.
[07/13 21:40:29]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:29]  --------------------------------------------------------------------------------
[07/13 21:40:29]  Iteration: 364
[07/13 21:40:34]  Generator returned sat in 2.007278 secs.
[07/13 21:40:34]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:34]  Verifer returned unsat in 0.008834 secs.
[07/13 21:40:34]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:34]  --------------------------------------------------------------------------------
[07/13 21:40:34]  Iteration: 365
[07/13 21:40:39]  Generator returned sat in 2.199340 secs.
[07/13 21:40:39]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:39]  Improved gap from 239/16384 to 100
[07/13 21:40:40]  Improved number of small numbers from 33 to 80 out of a max of 80
[07/13 21:40:40]  Verifer returned sat in 0.254596 secs.
[07/13 21:40:40]  Counter example:
    arrival_0,t    cwnd_0,t   service_0,t     wasted_t   losts_0,t  loss_detected_0,t     queue_t  bottle_queue_t
0 -14689.218994    0.058350 -14789.248535 -3314.266113    0.000000           0.000000  100.029541      100.029297
1 -14689.218994    0.029053 -14689.248535 -3314.266113    0.000000           0.000000    0.029541        0.029297
2 -14389.248535  300.000000 -14589.248291 -3314.266113    0.000000           0.000000  199.999756      199.999756
3 -14389.219238  200.000000 -14489.277344 -3314.266113    0.029053           0.029053  100.029053      100.000000
4 -14389.219238  100.000000 -14475.748535 -3314.266113    0.029053           0.029053   86.500244        0.000000
5 -13761.219238  628.000000 -14303.248291 -3314.266113  428.029053         428.029053  114.000000      100.000000
6 -13561.190186  314.000000 -14289.248291 -3314.266113  428.058105         428.058105  300.000000      200.000000
high_util=True, low_loss=False, ramp_up=True, ramp_down=False, measured_loss_rate=1.
[07/13 21:40:40]  --------------------------------------------------------------------------------
[07/13 21:40:40]  Iteration: 366
[07/13 21:40:46]  Generator returned sat in 3.413825 secs.
[07/13 21:40:46]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:46]  Verifer returned unsat in 0.019064 secs.
[07/13 21:40:46]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:46]  --------------------------------------------------------------------------------
[07/13 21:40:46]  Iteration: 367
[07/13 21:40:51]  Generator returned sat in 2.161203 secs.
[07/13 21:40:52]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:52]  Verifer returned unsat in 0.013604 secs.
[07/13 21:40:52]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:52]  --------------------------------------------------------------------------------
[07/13 21:40:52]  Iteration: 368
[07/13 21:40:58]  Generator returned sat in 3.897377 secs.
[07/13 21:40:58]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:58]  Verifer returned unsat in 0.012948 secs.
[07/13 21:40:58]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:40:58]  --------------------------------------------------------------------------------
[07/13 21:40:58]  Iteration: 369
[07/13 21:41:03]  Generator returned sat in 2.056902 secs.
[07/13 21:41:03]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:41:03]  Verifer returned unsat in 0.006679 secs.
[07/13 21:41:03]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:41:04]  --------------------------------------------------------------------------------
[07/13 21:41:04]  Iteration: 370
[07/13 21:41:08]  Generator returned sat in 2.094255 secs.
[07/13 21:41:09]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:41:09]  Verifer returned unsat in 0.010184 secs.
[07/13 21:41:09]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:41:09]  --------------------------------------------------------------------------------
[07/13 21:41:09]  Iteration: 371
[07/13 21:41:14]  Generator returned sat in 2.109690 secs.
[07/13 21:41:14]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:41:14]  Verifer returned unsat in 0.005742 secs.
[07/13 21:41:14]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:41:14]  --------------------------------------------------------------------------------
[07/13 21:41:14]  Iteration: 372
[07/13 21:41:19]  Generator returned sat in 2.678016 secs.
[07/13 21:41:20]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:41:20]  Verifer returned unsat in 0.010054 secs.
[07/13 21:41:20]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:41:20]  --------------------------------------------------------------------------------
[07/13 21:41:20]  Iteration: 373
[07/13 21:41:28]  Generator returned sat in 5.571684 secs.
[07/13 21:41:28]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:28]  Verifer returned unsat in 0.007384 secs.
[07/13 21:41:28]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:28]  --------------------------------------------------------------------------------
[07/13 21:41:28]  Iteration: 374
[07/13 21:41:33]  Generator returned sat in 2.089175 secs.
[07/13 21:41:33]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:33]  Verifer returned unsat in 0.008049 secs.
[07/13 21:41:33]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:33]  --------------------------------------------------------------------------------
[07/13 21:41:33]  Iteration: 375
[07/13 21:41:38]  Generator returned sat in 1.935766 secs.
[07/13 21:41:38]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:38]  Verifer returned unsat in 0.011615 secs.
[07/13 21:41:38]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:38]  --------------------------------------------------------------------------------
[07/13 21:41:38]  Iteration: 376
[07/13 21:41:43]  Generator returned sat in 2.006892 secs.
[07/13 21:41:43]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:43]  Verifer returned unsat in 0.007846 secs.
[07/13 21:41:43]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:43]  --------------------------------------------------------------------------------
[07/13 21:41:43]  Iteration: 377
[07/13 21:41:48]  Generator returned sat in 1.922723 secs.
[07/13 21:41:48]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:48]  Verifer returned unsat in 0.008684 secs.
[07/13 21:41:48]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:48]  --------------------------------------------------------------------------------
[07/13 21:41:48]  Iteration: 378
[07/13 21:41:53]  Generator returned sat in 1.856499 secs.
[07/13 21:41:53]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:53]  Verifer returned unsat in 0.009141 secs.
[07/13 21:41:53]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:53]  --------------------------------------------------------------------------------
[07/13 21:41:53]  Iteration: 379
[07/13 21:41:58]  Generator returned sat in 2.020713 secs.
[07/13 21:41:58]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:58]  Verifer returned unsat in 0.009737 secs.
[07/13 21:41:58]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:41:58]  --------------------------------------------------------------------------------
[07/13 21:41:58]  Iteration: 380
[07/13 21:42:03]  Generator returned sat in 1.921265 secs.
[07/13 21:42:03]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:03]  Verifer returned unsat in 0.006723 secs.
[07/13 21:42:03]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:03]  --------------------------------------------------------------------------------
[07/13 21:42:03]  Iteration: 381
[07/13 21:42:08]  Generator returned sat in 1.853748 secs.
[07/13 21:42:08]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:08]  Verifer returned unsat in 0.012068 secs.
[07/13 21:42:08]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:08]  --------------------------------------------------------------------------------
[07/13 21:42:08]  Iteration: 382
[07/13 21:42:13]  Generator returned sat in 1.967508 secs.
[07/13 21:42:13]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:13]  Verifer returned unsat in 0.006543 secs.
[07/13 21:42:13]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:13]  --------------------------------------------------------------------------------
[07/13 21:42:13]  Iteration: 383
[07/13 21:42:18]  Generator returned sat in 2.120814 secs.
[07/13 21:42:18]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:18]  Verifer returned unsat in 0.007812 secs.
[07/13 21:42:18]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:18]  --------------------------------------------------------------------------------
[07/13 21:42:18]  Iteration: 384
[07/13 21:42:23]  Generator returned sat in 1.969668 secs.
[07/13 21:42:23]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:23]  Verifer returned unsat in 0.008224 secs.
[07/13 21:42:23]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:23]  --------------------------------------------------------------------------------
[07/13 21:42:23]  Iteration: 385
[07/13 21:42:28]  Generator returned sat in 2.167908 secs.
[07/13 21:42:28]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:28]  Verifer returned unsat in 0.010432 secs.
[07/13 21:42:28]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:28]  --------------------------------------------------------------------------------
[07/13 21:42:28]  Iteration: 386
[07/13 21:42:36]  Generator returned sat in 4.664941 secs.
[07/13 21:42:36]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:36]  Verifer returned unsat in 0.008374 secs.
[07/13 21:42:36]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:36]  --------------------------------------------------------------------------------
[07/13 21:42:36]  Iteration: 387
[07/13 21:42:41]  Generator returned sat in 1.971678 secs.
[07/13 21:42:41]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:41]  Verifer returned unsat in 0.007796 secs.
[07/13 21:42:41]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:41]  --------------------------------------------------------------------------------
[07/13 21:42:41]  Iteration: 388
[07/13 21:42:47]  Generator returned sat in 2.744003 secs.
[07/13 21:42:47]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:47]  Verifer returned unsat in 0.007407 secs.
[07/13 21:42:47]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:47]  --------------------------------------------------------------------------------
[07/13 21:42:47]  Iteration: 389
[07/13 21:42:52]  Generator returned sat in 1.927276 secs.
[07/13 21:42:52]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:52]  Verifer returned unsat in 0.006560 secs.
[07/13 21:42:52]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:52]  --------------------------------------------------------------------------------
[07/13 21:42:52]  Iteration: 390
[07/13 21:42:57]  Generator returned sat in 2.005605 secs.
[07/13 21:42:57]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:57]  Verifer returned unsat in 0.013483 secs.
[07/13 21:42:57]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:42:57]  --------------------------------------------------------------------------------
[07/13 21:42:57]  Iteration: 391
[07/13 21:43:02]  Generator returned sat in 1.812612 secs.
[07/13 21:43:02]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:02]  Verifer returned unsat in 0.011543 secs.
[07/13 21:43:02]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:02]  --------------------------------------------------------------------------------
[07/13 21:43:02]  Iteration: 392
[07/13 21:43:06]  Generator returned sat in 1.848439 secs.
[07/13 21:43:07]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:07]  Verifer returned unsat in 0.012160 secs.
[07/13 21:43:07]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:07]  --------------------------------------------------------------------------------
[07/13 21:43:07]  Iteration: 393
[07/13 21:43:11]  Generator returned sat in 1.717618 secs.
[07/13 21:43:11]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:11]  Verifer returned unsat in 0.010170 secs.
[07/13 21:43:11]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:11]  --------------------------------------------------------------------------------
[07/13 21:43:11]  Iteration: 394
[07/13 21:43:16]  Generator returned sat in 1.899948 secs.
[07/13 21:43:16]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:16]  Verifer returned unsat in 0.007604 secs.
[07/13 21:43:16]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:16]  --------------------------------------------------------------------------------
[07/13 21:43:16]  Iteration: 395
[07/13 21:43:21]  Generator returned sat in 1.811250 secs.
[07/13 21:43:21]  Candidate solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:21]  Verifer returned unsat in 0.007499 secs.
[07/13 21:43:21]  Proved solution:
if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:21]  --------------------------------------------------------------------------------
[07/13 21:43:21]  Iteration: 396
[07/13 21:43:24]  Generator returned unsat in 0.000631 secs.
[07/13 21:43:24]  No more solutions found
[07/13 21:43:24]  Final solutions:
[07/13 21:43:24]  0: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  1: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  2: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  3: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  4: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  5: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  6: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  7: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  8: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  9: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  10: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  11: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  12: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  13: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  14: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  15: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  16: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  17: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  18: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  19: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  20: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  21: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  22: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  23: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  24: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  25: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  26: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  27: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  28: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  29: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  30: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  31: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  32: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  33: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  34: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  35: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  36: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  37: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  38: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  39: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  40: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  41: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  42: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  43: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  44: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  45: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  46: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  47: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  48: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  49: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  50: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  51: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  52: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  53: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  54: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  55: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  56: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  57: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  58: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  59: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  60: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  61: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  62: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  63: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  64: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  65: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  66: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  67: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  68: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  69: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  70: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  71: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  72: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  73: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  74: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  75: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  76: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  77: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  78: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  79: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  80: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  81: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  82: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  83: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  84: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  85: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  86: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  87: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  88: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  89: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  90: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  91: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  92: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  93: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  94: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  95: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  96: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  97: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  98: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  99: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  100: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  101: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  102: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  103: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  104: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  105: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  106: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  107: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  108: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1)
[07/13 21:43:24]  109: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  110: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 3/2)
[07/13 21:43:24]  111: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  112: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
[07/13 21:43:24]  113: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 2)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 1/2)
[07/13 21:43:24]  114: if(Ld_f[0][t-c.R] > Ld_f[0][t-c.R-1]):
        c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
        c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
[07/13 21:43:24]  Took 1638.330794 secs.
