[08/24 14:53:28]  --------------------------------------------------------------------------------
[08/24 14:53:28]  Iteration: 1 (0 solution, 0 counterexamples)
[08/24 14:53:28]  Generator returned sat in 0.004728 secs.
[08/24 14:53:28]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:29]  Improved gap from 0.0 to 100
[08/24 14:53:29]  Improved number of small numbers from 114 to 114 out of a max of 114
[08/24 14:53:29]  Verifer returned sat in 0.955604 secs.
[08/24 14:53:29]  Counter example: 
[93m   tot_arrival_t  tot_service_t  wasted_t  arrival_0,t   cwnd_0,t  service_0,t  losts_0,t   queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0       224.8425       124.7675 -124.8675     224.8425    100.100     124.7675      0.000   100.075          99.975     2.0         124.7675            -1.0            -1     False
1       224.8425       124.8675 -124.8675     224.8425    100.075     124.8675      0.000    99.975          -0.025     2.0         224.8425             0.0         False     False
2       224.9175       224.8675 -124.8675     224.9175    100.050     224.8675      0.000     0.050         -99.950     1.0         224.9175             0.0         False     False
3       324.8925       324.8675 -124.8675     324.8925    100.025     324.8675      0.000     0.025         -99.975     1.0         324.8925             0.0         False     False
4       925.1175       483.7675 -124.8675     925.1175    600.250     483.7675      0.000   441.350         400.250     1.0         324.8925             0.0         False     False
5      2402.0675       624.8675 -124.8675    2402.0675   1918.300     624.8675      0.000  1777.200        1777.200     2.0         324.8925             0.0         False     False
6      5261.4675       684.8675 -124.8675    5261.4675   4636.600     684.8675   2759.375  1817.225        1777.225     3.0         324.8925             0.0         False     False
7     13437.4425       824.8675 -124.8675   13437.4425   9993.200     824.8675  10835.350  1777.225        1777.225     4.0         324.8925             0.0         False      True
8     32328.8175       924.8675 -124.8675   32328.8175  20668.600     924.8675  29626.725  1777.225        1777.225     5.0         324.8925             0.0         False      True
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=True, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=False, total_losses=3, buffer=71089/40.[0m
[08/24 14:53:30]  --------------------------------------------------------------------------------
[08/24 14:53:30]  Iteration: 2 (0 solution, 1 counterexamples)
[08/24 14:53:30]  Generator returned sat in 0.014927 secs.
[08/24 14:53:30]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:32]  Improved gap from 0.025 to 100
[08/24 14:53:32]  Improved number of small numbers from 114 to 114 out of a max of 114
[08/24 14:53:32]  Verifer returned sat in 2.188391 secs.
[08/24 14:53:32]  Counter example: 
[93m   tot_arrival_t  tot_service_t  wasted_t  arrival_0,t  cwnd_0,t  service_0,t  losts_0,t  queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0      1174.5925      1174.3925 -825.4425    1174.5925     150.0    1174.3925        0.0      0.2             0.2     2.0        1174.3925            -1.0            -1     False
1      1174.5925      1174.3925 -825.4425    1174.5925       0.1    1174.3925        0.0      0.2           -99.8     2.0        1174.5925             0.0         False     False
2      1374.3925      1274.3925 -825.4425    1374.3925     200.0    1274.3925        0.0    100.0             0.0     1.0        1174.5925             0.0         False     False
3      1374.3925      1374.3925 -825.4425    1374.3925      99.9    1374.3925        0.0      0.0          -100.0     2.0        1374.3925             0.0         False     False
4      1574.3925      1474.3925 -825.4425    1574.3925     200.0    1474.3925        0.0    100.0             0.0     1.0        1374.3925             0.0         False     False
5      1774.3925      1674.3925 -825.4425    1774.3925     300.0    1674.3925       99.8      0.2             0.2     1.0        1374.3925             0.0         False     False
6      2724.1925      1737.5925 -825.4425    2724.1925     950.0    1737.5925      949.6     37.0             0.2     1.0        1374.3925             0.0         False      True
7      3888.5925      1774.6925 -825.4425    3888.5925    1201.4    1774.6925     2014.0     99.9             0.2     1.0        1374.3925             0.0         False      True
8      4989.9925      1874.6925 -825.4425    4989.9925    1201.3    1874.6925     3015.4     99.9             0.2     1.0        1974.5925             0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss=False, ramp_up_cwnd=True, ramp_down_bq=False, ramp_down_q=True, ramp_down_cwnd=False, total_losses=4, buffer=1/5.[0m
[08/24 14:53:33]  --------------------------------------------------------------------------------
[08/24 14:53:33]  Iteration: 3 (0 solution, 2 counterexamples)
[08/24 14:53:33]  Generator returned sat in 0.129768 secs.
[08/24 14:53:33]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:34]  Improved number of small numbers from 67 to 75 out of a max of 113
[08/24 14:53:34]  Verifer returned sat in 1.156333 secs.
[08/24 14:53:34]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t   arrival_0,t      cwnd_0,t   service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0   10548.374023   10473.174196 -825.442627  10548.374023    150.000000  10473.174196        0.0   75.199827       75.199827     2.0     10473.174196            -1.0            -1     False
1   10548.374023   10473.174196 -825.442627  10548.374023      0.100098  10473.174196        0.0   75.199827      -24.800173     2.0     10548.374023             0.0         False     False
2   10673.074196   10648.674196 -825.442627  10673.074196    199.900000  10648.674196        0.0   24.400000       -0.100000     1.0     10548.374023             0.0         False     False
3   10848.474196   10673.174196 -825.442627  10848.474196    199.800000  10673.174196        0.1  175.200000       75.200000     1.0     10848.374196             0.0         False     False
4   11472.874196   10848.474196 -825.442627  11472.874196    799.600000  10848.474196      524.5   99.900000       75.200000     1.0     10848.374196             0.0         False      True
5   13722.774196   10948.474196 -825.442627  13722.774196   2349.800000  10948.474196     2674.4   99.900000       75.200000     1.0     10848.374196             0.0         False      True
6   18922.074196   11048.474196 -825.442627  18922.074196   5299.200000  11048.474196     7773.7   99.900000       75.200000     1.0     10848.374196             0.0         False      True
7   30171.174196   11148.474196 -825.442627  30171.174196  11349.000000  11148.474196    18922.8   99.900000       75.200000     1.0     10848.374196             0.0         False      True
8   53369.274196   11248.474121 -825.442627  53369.274196  23298.000000  11248.474121    42020.9   99.900075       75.200000     1.0     10848.374196             0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss=False, ramp_up_cwnd=True, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=False, total_losses=5, buffer=376/5.[0m
[08/24 14:53:35]  --------------------------------------------------------------------------------
[08/24 14:53:35]  Iteration: 4 (0 solution, 3 counterexamples)
[08/24 14:53:35]  Generator returned sat in 0.218179 secs.
[08/24 14:53:35]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:35]  Improved number of small numbers from 67 to 113 out of a max of 113
[08/24 14:53:35]  Verifer returned sat in 0.329144 secs.
[08/24 14:53:35]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t   arrival_0,t     cwnd_0,t   service_0,t    losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0   12422.874268   10448.474121 -825.442627  12422.874268     0.200000  10448.474121  1774.399902  200.000244      200.000000     2.0     10448.474121            -1.0            -1      True
1   12422.874268   10448.574219 -825.442627  12422.874268     0.099854  10448.574219  1774.399902  199.900146      100.000000     2.0     10648.474365             0.0         False      True
2   12622.774170   10648.474365 -825.442627  12622.774170   399.800049  10648.474365  1774.399902  199.899902      199.899902     3.0     10648.474365             0.0         False      True
3   12722.874023   10648.474365 -825.442627  12722.874023   299.999756  10648.474365  1774.399902  299.999756      199.999756     3.0     10948.474121             0.0         False      True
4   13422.874268   10848.374268 -825.442627  13422.874268  1000.000000  10848.374268  2374.399902  200.100098      200.000000     3.0     10948.474121             0.0         False      True
5   13722.774170   10848.474365 -825.442627  13722.774170   500.000000  10848.474365  2574.299805  300.000000      200.000000     3.0     11148.474365             0.0         False      True
6   13722.774170   11048.474365 -825.442627  13722.774170   250.000000  11048.474365  2574.299805  100.000000      100.000000     3.0     11148.474365             0.0         False      True
7   14922.774170   11148.474365 -825.442627  14922.774170  1300.000000  11148.474365  3574.299805  200.000000      200.000000     3.0     11148.474365             0.0         False      True
8   15372.774170   11148.574219 -825.442627  15372.774170   650.000000  11148.574219  3924.299805  299.900146      200.000000     2.0     11448.474365             0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss=False, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=4, buffer=200.[0m
[08/24 14:53:36]  --------------------------------------------------------------------------------
[08/24 14:53:36]  Iteration: 5 (0 solution, 4 counterexamples)
[08/24 14:53:37]  Generator returned sat in 0.537503 secs.
[08/24 14:53:37]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:37]  Improved gap from 0.0003125 to 0
[08/24 14:53:38]  Improved number of small numbers from 52 to 96 out of a max of 114
[08/24 14:53:38]  Verifer returned sat in 1.531471 secs.
[08/24 14:53:38]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t   arrival_0,t    cwnd_0,t   service_0,t    losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0   13922.772705   11348.472900 -825.444336  13922.772705   99.998535  11348.472900  2574.299561    0.000244        0.000244     2.0     11348.472900            -1.0            -1       -1
1   14022.770508   11348.473389 -825.442627  14022.770508   99.998047  11348.473389  2574.299561   99.997559       -0.000244     1.0     11448.470947             1.0         False    False
2   14122.771240   11448.471191 -825.442627  14122.771240  199.998291  11448.471191  2574.299561  100.000488        0.000488     1.0     11448.470947             0.0         False    False
3   14222.770752   11548.472412 -825.442627  14222.770752  200.000000  11548.472412  2574.299561   99.998779        0.000000     1.0     11448.470947             0.0         False    False
4   14322.771484   11748.462490 -825.442627  14322.771484  199.999512  11748.462490  2574.299805    0.009189        0.000488     1.0     11748.471680             0.0         False    False
5   14322.772295   11748.472178 -725.444092  14322.772295    0.010000  11748.472178  2574.299805    0.000313       -0.000166     1.0     11748.472490             0.0         False     True
6   14322.781982   11748.481865 -625.453857  14322.781982    0.010000  11748.481865  2574.299805    0.000313       -0.000244     1.0     11748.472490             0.0         False     True
7   14322.791670   11748.482490 -525.463379  14322.791670    0.010000  11748.482490  2574.299805    0.009375       -0.000078     1.0     11748.472490             0.0         False     True
8   14322.792295   11748.491943 -525.463379  14322.792295    0.010000  11748.491943  2574.299805    0.000547      -99.999453     1.0     11748.472490             0.0         False     True
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=True, ramp_down_cwnd=True, total_losses=1, buffer=1/2048.[0m
[08/24 14:53:39]  --------------------------------------------------------------------------------
[08/24 14:53:39]  Iteration: 6 (0 solution, 5 counterexamples)
[08/24 14:53:39]  Generator returned sat in 0.020777 secs.
[08/24 14:53:39]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:39]  Improved gap from 0.0 to 23.4375
[08/24 14:53:40]  Improved number of small numbers from 60 to 69 out of a max of 114
[08/24 14:53:40]  Verifer returned sat in 1.401777 secs.
[08/24 14:53:40]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t   arrival_0,t   cwnd_0,t   service_0,t    losts_0,t    queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0   14137.295654   11463.295693 -940.267129  14137.295654   0.100098  11463.295693  2574.299805  99.700156       99.700156     9.0     11463.295693            -1.0            -1       -1
1   14137.495498   11563.095693 -940.267129  14137.495498  99.900000  11563.095693  2574.299805   0.100000       -0.100000     1.0     11463.295693             1.0         False     True
2   14161.132998   11563.295693 -863.904541  14161.132998  23.737500  11563.295693  2574.299805  23.537500       -0.099912     1.0     11586.833193             0.0         False     True
3   14161.332998   11586.933193 -787.342285  14161.332998  23.737500  11586.933193  2574.299805   0.100000      -23.337656     1.0     11586.833193             0.0         False     True
4   14223.051748   11620.333193 -725.723389  14223.051748  61.818750  11620.333193  2574.299805  28.418750       -0.000010     1.0     11586.833193             0.0         False     True
5   14223.251748   11648.851943 -649.260879  14223.251748  28.618750  11648.851943  2574.299805   0.100000      -23.337500     1.0     11648.951943             0.0         False     True
6   14265.929873   11672.289443 -572.698379  14265.929873  42.778125  11672.289443  2574.299805  19.340625       -4.096875     1.0     11648.951943             0.0         False     True
7   14289.267373   11695.726943 -496.204590  14289.267373  42.678125  11695.726943  2574.299805  19.240625       -4.265586     1.0     11714.967568             0.0         False     True
8   14307.723623   11719.233398 -496.204590  14307.723623  37.696875  11719.233398  2574.299805  14.190420      -85.809336     1.0     11733.423818             0.0         False     True
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=True, ramp_down_cwnd=True, total_losses=0, buffer=102093/1024.[0m
[08/24 14:53:41]  --------------------------------------------------------------------------------
[08/24 14:53:41]  Iteration: 7 (0 solution, 6 counterexamples)
[08/24 14:53:41]  Generator returned sat in 0.237794 secs.
[08/24 14:53:41]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][5]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:42]  Improved gap from 0.0008333333333333334 to 100
[08/24 14:53:42]  Improved number of small numbers from 45 to 114 out of a max of 114
[08/24 14:53:42]  Verifer returned sat in 0.520811 secs.
[08/24 14:53:42]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t   arrival_0,t    cwnd_0,t   service_0,t    losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0   13661.308105   10987.032959  136.145508  13661.308105    0.025000  10987.032959  2574.299805   99.975342       -0.024658     2.0     10987.032959            -1.0            -1       -1
1   13661.357910   11087.032959  136.145508  13661.357910  100.025146  11087.032959  2574.299805    0.025146      -99.974854     1.0     10987.032959             0.0         False     True
2   13761.357910   11187.032959  136.145508  13761.357910  100.025146  11187.032959  2574.299805    0.025146      -99.974854     1.0     10987.032959             0.0         False     True
3   14161.357910   11387.032959  136.145508  14161.357910  400.025146  11387.032959  2674.299805  100.025146      100.025146     1.0     10987.032959             0.0         False     True
4   14461.332764   11487.008057  136.145508  14461.332764  400.000000  11487.008057  2874.274658  100.050049      100.025146     2.0     11587.058105             0.0         False     True
5   14761.257812   11487.058105  136.145508  14761.257812  399.975098  11487.058105  3074.199707  200.000000      100.025146     3.0     11687.058105             0.0         False     True
6   14861.282959   11687.032959  136.145508  14861.282959  300.025146  11687.032959  3074.224854  100.025146      100.025146     2.0     11787.058105             0.0         False     True
7   15061.257812   11786.983154  136.145508  15061.257812  300.000000  11786.983154  3174.199707  100.074951      100.025146     2.0     11887.058105             0.0         False     True
8   15261.157959   11887.032959  136.145508  15261.157959  299.975098  11887.032959  3274.099854  100.025146      100.025146     2.0     11987.058105             0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss=False, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=True, ramp_down_cwnd=True, total_losses=5, buffer=409703/4096.[0m
[08/24 14:53:43]  --------------------------------------------------------------------------------
[08/24 14:53:43]  Iteration: 8 (0 solution, 7 counterexamples)
[08/24 14:53:43]  Generator returned sat in 0.159701 secs.
[08/24 14:53:43]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:44]  Improved number of small numbers from 46 to 50 out of a max of 113
[08/24 14:53:44]  Verifer returned sat in 1.283748 secs.
[08/24 14:53:44]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t   arrival_0,t     cwnd_0,t  service_0,t     losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    4956.562500    4856.587549  136.145264   4956.562500     0.025146  4856.587549      0.024951   99.950000       99.949756     2.0      4856.587549            -1.0            -1       -1
1    4956.612500    4956.562598  136.145264   4956.612500   100.000000  4956.562598      0.024951    0.024951       -0.000244     1.0      4856.587549             0.0         False     True
2    5056.587549    5056.537646  136.145508   5056.587549   100.000000  5056.537646      0.024951    0.024951       -0.024951     1.0      4856.587549             0.0         False     True
3   11459.759473    5056.587549  136.145508  11459.759473  6403.196875  5056.587549   6203.146777  200.025146      100.025146     1.0      4856.587549             0.0         False     True
4   14461.332764    5256.562646  136.145508  14461.332764  3201.598437  5256.562646   9104.720068  100.050049      100.025146     2.0      5356.612695             0.0         False     True
5   15962.081934    5256.612695  136.145508  15962.081934  1600.799219  5256.612695  10505.469238  200.000000      100.025146     3.0      5456.612695             0.0         False     True
6   16562.481543    5456.587549  136.145508  16562.481543   800.399609  5456.587549  11005.868848  100.025146      100.025146     2.0      5556.612695             1.0         False     True
7   16862.656201    5556.537744  136.145508  16862.656201   400.199805  5556.537744  11206.043506  100.074951      100.025146     2.0      5656.612695             0.0         False     True
8   16962.681152    5656.587402  136.145508  16962.681152   200.099902  5656.587402  11206.068457  100.025293      100.025146     2.0      5756.612695             0.0         False     True
fefficient=True, bounded_queue=True, bounded_loss=False, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=True, ramp_down_cwnd=True, total_losses=5, buffer=409703/4096.[0m
[08/24 14:53:45]  --------------------------------------------------------------------------------
[08/24 14:53:45]  Iteration: 9 (0 solution, 8 counterexamples)
[08/24 14:53:45]  Generator returned sat in 0.380152 secs.
[08/24 14:53:45]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:46]  Improved gap from 0.1 to 100
[08/24 14:53:47]  Improved number of small numbers from 48 to 74 out of a max of 114
[08/24 14:53:47]  Verifer returned sat in 1.169748 secs.
[08/24 14:53:47]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    5056.537598    4956.612695  136.145508  5056.537598  199.900000  4956.612695    0.024902   99.900000       -0.100000     1.0      4956.612695            -1.0            -1     False
1    5156.537598    5056.612793  136.145508  5156.537598  199.900000  5056.612793    0.024902   99.899902       -0.100000     1.0      4956.612695             0.0         False     False
2    5256.637451    5156.612793  136.145508  5256.637451  199.999756  5156.612793    0.024902   99.999756       -0.000146     1.0      4956.612695             0.0         False     False
3    5756.837646    5352.927510  136.145508  5756.837646  600.199951  5352.927510    0.124951  403.785185      400.100000     1.0      4956.612695             0.0         False     False
4    5756.837646    5456.612549  136.145508  5756.837646  198.157407  5456.612549    0.124951  300.100146      300.100000     2.0      5756.712695             0.0         False      True
5    5756.837646    5556.612695  136.145508  5756.837646  297.236111  5556.612695    0.124951  200.100000      200.100000     3.0      5756.712695             1.0         False     False
6    6002.591813    5656.612695  136.145508  6002.591813  445.854167  5656.612695    0.124951  345.854167      345.854167     4.0      5756.712695             1.0         False     False
7    6325.518896    5756.612549  136.145508  6325.518896  668.781250  5756.612549  168.806201  400.100146      400.100000     5.0      5756.712695             1.0         False     False
8    6325.518896    5756.612793  136.145508  6325.518896  150.000000  5756.612793  168.806201  400.099902      300.100000     6.0      6156.712695             1.0         False      True
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=1, buffer=4001/10.[0m
[08/24 14:53:47]  --------------------------------------------------------------------------------
[08/24 14:53:47]  Iteration: 10 (0 solution, 9 counterexamples)
[08/24 14:53:48]  Generator returned sat in 0.076932 secs.
[08/24 14:53:48]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:49]  Improved number of small numbers from 73 to 73 out of a max of 113
[08/24 14:53:49]  Verifer returned sat in 0.868142 secs.
[08/24 14:53:49]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    5056.537598    4956.612695  136.145508  5056.537598  199.900000  4956.612695    0.024902   99.900000       -0.100000     2.0      4956.612695            -1.0            -1     False
1    5156.537598    5056.612793  136.145508  5156.537598  199.900000  5056.612793    0.024902   99.899902       -0.100000     1.0      4956.612695             0.0         False     False
2    5456.637451    5156.612793  136.145508  5456.637451  399.999756  5156.612793    0.024902  299.999756      199.999854     1.0      4956.612695             0.0         False     False
3    5756.837646    5352.927510  136.145508  5756.837646  600.199951  5352.927510    0.124951  403.785185      400.100000     2.0      4956.612695             0.0         False     False
4    5756.837646    5456.612549  136.145508  5756.837646  198.157407  5456.612549    0.124951  300.100146      300.100000     3.0      5756.712695             0.0         False      True
5    5756.837646    5556.612695  136.145508  5756.837646  297.236111  5556.612695    0.124951  200.100000      200.100000     3.0      5756.712695             1.0         False     False
6    6002.591813    5656.612695  136.145508  6002.591813  445.854167  5656.612695    0.124951  345.854167      345.854167     4.0      5756.712695             1.0         False     False
7    6325.518896    5756.612549  136.145508  6325.518896  668.781250  5756.612549  168.806201  400.100146      400.100000     5.0      5756.712695             1.0         False     False
8    6325.518896    5756.612793  136.145508  6325.518896  150.000000  5756.612793  168.806201  400.099902      300.100000     6.0      6156.712695             1.0         False      True
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=1, buffer=4001/10.[0m
[08/24 14:53:49]  --------------------------------------------------------------------------------
[08/24 14:53:49]  Iteration: 11 (0 solution, 10 counterexamples)
[08/24 14:53:50]  Generator returned sat in 0.083046 secs.
[08/24 14:53:50]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:50]  Improved gap from 0.0004166666666666667 to 100
[08/24 14:53:50]  Improved number of small numbers from 81 to 96 out of a max of 114
[08/24 14:53:50]  Verifer returned sat in 0.867908 secs.
[08/24 14:53:50]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    4957.012451    4756.912842  136.145508  4957.012451    0.099854  4756.912842       0.00  200.099609      100.099756     2.0      4756.912842            -1.0            -1      True
1    4957.012451    4956.912695  136.145508  4957.012451    0.100000  4956.912695       0.00    0.099756        0.099756     2.0      4756.912842             0.0         False      True
2    5057.012695    4957.112695  136.145508  5057.012695  100.100000  4957.112695       0.00   99.900000        0.100000     1.0      4756.912842             0.0         False      True
3    5057.012695    5056.912842  136.145508  5057.012695    0.100098  5056.912842       0.00    0.099854      -99.900000     2.0      5057.012695             0.0         False      True
4    5356.912842    5156.912695  136.145508  5356.912842  300.000000  5156.912695       0.00  200.000146      100.000146     1.0      5057.012695             0.0         False      True
5    5356.912842    5256.912695  136.145508  5356.912842  200.000000  5256.912695       0.00  100.000146        0.000146     2.0      5356.912842             0.0         False      True
6    5556.712695    5356.912695  136.145508  5556.712695  299.800000  5356.912695       0.00  199.800000       99.800000     3.0      5356.912842             0.0         False      True
7    5806.612695    5556.912695  136.145508  5806.612695  449.700000  5556.912695       0.00  249.700000      249.700000     1.0      5356.912842             1.0         False     False
8    6231.462695    5557.012695  136.145508  6231.462695  674.550000  5557.012695     274.35  400.100000      300.200000     2.0      5356.912842             0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=True, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=False, total_losses=1, buffer=1501/5.[0m
[08/24 14:53:51]  --------------------------------------------------------------------------------
[08/24 14:53:51]  Iteration: 12 (0 solution, 11 counterexamples)
[08/24 14:53:52]  Generator returned sat in 0.411761 secs.
[08/24 14:53:52]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:52]  Improved gap from 25.1 to 100
[08/24 14:53:52]  Improved number of small numbers from 76 to 114 out of a max of 114
[08/24 14:53:52]  Verifer returned sat in 0.516375 secs.
[08/24 14:53:52]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    4856.962646    4707.012695  136.145508  4856.962646  149.950195  4707.012695    0.000000  149.949951       49.949951     2.0      4707.012695            -1.0            -1      True
1    4856.962646    4807.012695  136.145508  4856.962646  149.900146  4807.012695    0.000000   49.949951      -50.050049     2.0      4856.962646             0.0         False      True
2    4956.862793    4956.812744  136.145508  4956.862793  149.850098  4956.812744    0.000000    0.050049      -50.149902     1.0      4956.862793             0.0         False      True
3    5106.612793    5007.012695  136.145508  5106.612793  149.800049  5007.012695    0.000000   99.600098       -0.399902     1.0      5106.612793             0.0         False      True
4    5306.612793    5207.012695  136.145508  5306.612793  299.600098  5207.012695   49.650146   49.949951       49.949951     1.0      5106.612793             0.0         False      True
5    5456.662842    5207.062744  136.145508  5456.662842  200.000000  5207.062744   99.700195  149.899902       49.949951     2.0      5356.962646             0.0         False      True
6    5456.662842    5356.912598  136.145508  5456.662842  125.125000  5356.912598   99.700195    0.050049      -50.050049     2.0      5356.962646             0.0         False      True
7    5706.862793    5507.012695  136.145508  5706.862793  250.250000  5507.012695  149.900146   49.949951       49.949951     1.0      5356.962646             0.0         False      True
8    5806.912842    5557.012695  136.145508  5806.912842  150.000000  5557.012695  149.950195   99.949951       49.949951     1.0      5656.962646             0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss=False, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=4, buffer=204595/4096.[0m
[08/24 14:53:53]  --------------------------------------------------------------------------------
[08/24 14:53:53]  Iteration: 13 (0 solution, 12 counterexamples)
[08/24 14:53:54]  Generator returned sat in 0.296122 secs.
[08/24 14:53:54]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:54]  Improved gap from 49.8875 to 100
[08/24 14:53:54]  Improved number of small numbers from 68 to 114 out of a max of 114
[08/24 14:53:54]  Verifer returned sat in 0.449193 secs.
[08/24 14:53:54]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    4907.074951    4806.875244  136.145264  4907.074951  100.200000  4806.875244    0.000000  100.199707        0.199707     2.0      4806.875244            -1.0            -1     False
1    4907.074951    4907.000244  136.145264  4907.074951  100.124756  4907.000244    0.000000    0.074707      -99.800293     2.0      4907.074951             0.0         False     False
2    5007.050049    5006.975342  136.145264  5007.050049  100.049805  5006.975342    0.000000    0.074707      -99.825195     1.0      5007.050049             0.0         False     False
3    5106.950195    5106.875244  136.145264  5106.950195   99.974854  5106.875244    0.000000    0.074951      -99.925049     1.0      5106.950195             0.0         False     False
4    5406.875244    5240.433350  136.145264  5406.875244  300.000000  5240.433350   99.800049   66.641846        0.199951     1.0      5106.950195             0.0         False     False
5    5506.949951    5406.875244  136.145264  5506.949951  166.716553  5406.875244   99.874756    0.199951        0.199951     1.0      5407.075195             0.0         False      True
6    5706.699951    5506.875244  136.145264  5706.699951  199.949951  5506.875244  199.624756    0.199951        0.199951     1.0      5407.075195             0.0         False      True
7    5906.500000    5606.875244  136.145264  5906.500000  200.000000  5606.875244  299.424805    0.199951        0.199951     1.0      5407.075195             0.0         False      True
8    6089.520996    5607.075195  136.145264  6089.520996  183.220947  5607.075195  382.445801  100.000000        0.199951     2.0      5707.075195             0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss=False, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=5, buffer=819/4096.[0m
[08/24 14:53:55]  --------------------------------------------------------------------------------
[08/24 14:53:55]  Iteration: 14 (0 solution, 13 counterexamples)
[08/24 14:53:55]  Generator returned sat in 0.200426 secs.
[08/24 14:53:55]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:56]  Improved number of small numbers from 61 to 113 out of a max of 113
[08/24 14:53:56]  Verifer returned sat in 0.314497 secs.
[08/24 14:53:56]  Counter example: 
[93m   tot_arrival_t  tot_service_t   wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    4573.366211    4351.141357 -413.85498  4573.366211  222.225000  4351.141357   0.000000  222.224854      166.662598     2.0      4351.141357            -1.0            -1      True
1    4573.366211    4506.703613 -413.85498  4573.366211  222.223633  4506.703613   0.000000   66.662598       66.662598     2.0      4573.366211             0.0         False      True
2    4706.699951    4573.367432 -413.85498  4706.699951  199.996338  4573.367432   0.000000  133.332520       99.996338     1.0      4706.699951             0.0         False      True
3    4706.702637    4706.701172 -413.85498  4706.702637  133.335205  4706.701172   0.000000    0.001465       -0.000977     1.0      4706.702637             0.0         False      True
4    5306.708496    4706.703613 -413.85498  5306.708496  600.007324  4706.703613   0.000000  600.004883      500.004883     1.0      4706.702637             0.0         False      True
5    5306.708496    4906.703613 -413.85498  5306.708496  600.003662  4906.703613   0.000000  400.004883      400.004883     2.0      5306.708496             0.0         False      True
6    5706.709717    5006.703613 -413.85498  5706.709717  800.006104  5006.703613   0.001221  700.004883      700.004883     3.0      5306.708496             0.0         False      True
7    5706.709717    5106.703613 -413.85498  5706.709717    0.010000  5106.703613   0.001221  600.004883      600.004883     4.0      5706.708496             1.0         False      True
8    5706.709717    5206.703613 -413.85498  5706.709717  200.000000  5206.703613   0.001221  500.004883      500.004883     5.0      5706.708496             1.0         False     False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=True, ramp_down_cwnd=True, total_losses=1, buffer=716805/1024.[0m
[08/24 14:53:56]  --------------------------------------------------------------------------------
[08/24 14:53:56]  Iteration: 15 (0 solution, 14 counterexamples)
[08/24 14:53:57]  Generator returned sat in 0.531147 secs.
[08/24 14:53:57]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:53:58]  Improved number of small numbers from 70 to 113 out of a max of 113
[08/24 14:53:58]  Verifer returned sat in 0.356269 secs.
[08/24 14:53:58]  Counter example: 
[93m   tot_arrival_t  tot_service_t   wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    4673.372070    4573.370850 -413.85498  4673.372070    0.001250  4573.370850   0.001465   99.999756       99.999756     1.0      4573.370850            -1.0            -1       -1
1    4673.372070    4573.370850 -413.85498  4673.372070    0.001465  4573.370850   0.001465   99.999756       -0.000244     1.0      4573.370850             0.0         False     True
2    4773.372070    4673.372070 -413.85498  4773.372070  199.999756  4673.372070   0.001465   99.998535       -0.000244     1.0      4573.370850             0.0         False     True
3    4873.372314    4840.039551 -413.85498  4873.372314  199.998779  4840.039551   0.001465   33.331299        0.000000     1.0      4873.370850             0.0         False     True
4    5306.708496    4906.705811 -413.85498  5306.708496  466.667480  4906.705811   0.001465  400.001221      333.336182     1.0      4873.370850             0.0         False     True
5    5706.709717    5073.370850 -413.85498  5706.709717  800.002441  5073.370850   0.002686  633.336182      633.336182     2.0      4873.370850             0.0         False     True
6    5706.709717    5173.370850 -413.85498  5706.709717    0.010000  5173.370850   0.002686  533.336182      533.336182     3.0      5706.707031             1.0          True     True
7    5706.709717    5273.370850 -413.85498  5706.709717    0.010000  5273.370850   0.002686  433.336182      433.336182     4.0      5706.707031             1.0         False    False
8    5706.709717    5373.370850 -413.85498  5706.709717    0.010000  5373.370850   0.002686  333.336182      333.336182     4.0      5706.707031             1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=True, ramp_down_cwnd=True, total_losses=1, buffer=2594145/4096.[0m
[08/24 14:53:58]  --------------------------------------------------------------------------------
[08/24 14:53:58]  Iteration: 16 (0 solution, 15 counterexamples)
[08/24 14:53:59]  Generator returned sat in 0.143353 secs.
[08/24 14:53:59]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:00]  Improved gap from 0.00125 to 9.375
[08/24 14:54:01]  Improved number of small numbers from 70 to 86 out of a max of 114
[08/24 14:54:01]  Verifer returned sat in 1.706503 secs.
[08/24 14:54:01]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t  cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    4702.389404    4593.014648 -504.479980  4702.389404     0.050  4593.014648        0.0  109.374756        9.374854     2.0      4593.014648            -1.0            -1     False
1    4702.389404    4693.014551 -413.854980  4702.389404     0.050  4693.014551        0.0    9.374854       -0.000146     2.0      4593.014648             0.0         False     False
2    5040.139551    4702.439697 -413.854980  5040.139551   347.125  4702.439697        0.0  337.699854      237.750000     1.0      4593.014648             0.0         False     False
3    5040.139551    4889.289551 -413.854980  5040.139551   301.600  4889.289551        0.0  150.850000      137.750000     2.0      5040.139551             0.0         False     False
4    5040.139551    4960.039307 -413.854980  5040.139551   150.800  4960.039307        0.0   80.100244       37.750000     3.0      5040.139551             0.0         False     False
5    5040.139551    5002.389648 -351.604980  5040.139551    75.400  5002.389648        0.0   37.749902        0.000000     4.0      5040.139551             0.0         False     False
6    5040.139551    5040.139551 -260.979980  5040.139551    37.700  5040.139551        0.0    0.000000       -9.375000     5.0      5040.139551             1.0         False     False
7    5058.989551    5049.514648 -170.454980  5058.989551    18.850  5049.514648        0.0    9.474902        0.000000     1.0      5058.989551             1.0         False     False
8    5058.989551    5058.989551 -170.454834  5058.989551     9.425  5058.989551        0.0    0.000000      -99.999854     2.0      5058.989551             0.0         False     False
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=True, ramp_down_cwnd=True, total_losses=0, buffer=974029/4096.[0m
[08/24 14:54:01]  --------------------------------------------------------------------------------
[08/24 14:54:01]  Iteration: 17 (0 solution, 16 counterexamples)
[08/24 14:54:02]  Generator returned sat in 0.144798 secs.
[08/24 14:54:02]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:02]  Improved number of small numbers from 88 to 113 out of a max of 113
[08/24 14:54:02]  Verifer returned sat in 0.294667 secs.
[08/24 14:54:02]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    4602.386963    4502.389160 -313.854980  4602.386963  100.002686  4502.389160   0.000000   99.997803       99.997559     2.0      4502.389160            -1.0            -1     False
1    4602.389160    4502.389404 -313.854736  4602.389160  100.000000  4502.389404   0.000000   99.999756        0.000000     2.0      4602.389160             0.0         False     False
2    4802.391846    4702.389160 -313.854736  4802.391846  300.002441  4702.389160   0.000000  100.002686      100.002686     1.0      4602.389160             0.0         False     False
3    5002.389160    4727.381836 -313.854736  5002.389160  300.000000  4727.381836   0.000000  275.007324      200.000000     2.0      5002.389160             0.0         False     False
4    5177.381836    4902.389160 -313.854736  5177.381836  450.000000  4902.389160   0.000000  274.992676      274.992676     2.0      5002.389160             0.0         False     False
5    5577.389160    4902.392090 -313.854736  5577.389160  675.000000  4902.392090   0.002441  674.994629      574.997559     3.0      5002.389160             0.0         False     False
6    5577.389160    5002.389160 -313.854736  5577.389160    0.010000  5002.389160   0.002441  574.997559      474.997559     4.0      5577.386719             0.0         False      True
7    5577.389160    5177.384277 -313.854736  5577.389160    0.015000  5177.384277   0.002441  400.002441      374.997559     3.0      5577.386719             1.0         False     False
8    5577.389160    5302.389160 -313.854736  5577.389160    0.022500  5302.389160   0.002441  274.997559      274.997559     4.0      5577.386719             0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=1, buffer=1177595/2048.[0m
[08/24 14:54:03]  --------------------------------------------------------------------------------
[08/24 14:54:03]  Iteration: 18 (0 solution, 17 counterexamples)
[08/24 14:54:04]  Generator returned sat in 0.258492 secs.
[08/24 14:54:04]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:04]  Improved gap from 0.0 to 0
[08/24 14:54:05]  Improved number of small numbers from 65 to 79 out of a max of 114
[08/24 14:54:05]  Verifer returned sat in 0.917098 secs.
[08/24 14:54:05]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    4602.362305    4402.362493 -313.854980  4602.362305  300.003174  4402.362493   0.000000  199.999811       99.999811     2.0      4402.362493            -1.0            -1     False
1    4702.364160    4502.362549 -313.854980  4702.364160  300.001667  4502.362549   0.001667  199.999945      100.000000     3.0      4702.362493             0.0         False     False
2    4702.364160    4602.362493 -313.854980  4702.364160  199.998535  4602.362493   0.001667  100.000000        0.000000     2.0      4702.362493             0.0         False      True
3    4902.362493    4702.364258 -313.854980  4902.362493  299.998333  4702.364258   0.001667  199.996569       99.998333     1.0      4702.362493             0.0         False      True
4    4902.362493    4902.349365 -313.853314  4902.362493    0.010000  4902.349365   0.001667    0.011462        0.000000     2.0      4902.360827             0.0         False      True
5    4902.362493    4902.360827 -213.861572  4902.362493    0.010000  4902.360827   0.001667    0.000000       -0.008258     3.0      4902.360827             0.0         False      True
6    4902.372493    4902.369160 -113.863525  4902.372493    0.010000  4902.369160   0.001667    0.001667       -0.000212     1.0      4902.360827             0.0         False      True
7    4902.380827    4902.377493  -13.871826  4902.380827    0.010000  4902.377493   0.001667    0.001667       -0.000179     1.0      4902.360827             0.0         False      True
8    4902.389160    4902.387451  -13.871826  4902.389160    0.010000  4902.387451   0.001667    0.000042      -99.991846     1.0      4902.360827             0.0         False      True
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=True, ramp_down_cwnd=False, total_losses=0, buffer=100.[0m
[08/24 14:54:05]  --------------------------------------------------------------------------------
[08/24 14:54:05]  Iteration: 19 (0 solution, 18 counterexamples)
[08/24 14:54:06]  Generator returned sat in 0.326919 secs.
[08/24 14:54:06]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:06]  Improved gap from 0.0 to 100
[08/24 14:54:07]  Improved number of small numbers from 59 to 67 out of a max of 114
[08/24 14:54:07]  Verifer returned sat in 1.206964 secs.
[08/24 14:54:07]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t     cwnd_0,t  service_0,t    losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    4502.359375    4402.360202 -213.853314  4502.359375     0.000625  4402.360202     0.000000   99.999173       99.998548     2.0      4402.360202            -1.0            -1      True
1    4502.360202    4402.360827 -213.853314  4502.360202   100.000000  4402.360827     0.000000   99.999375       -0.000625     2.0      4402.360202             0.0         False      True
2    4602.360202    4502.360827 -213.853314  4602.360202   199.999375  4502.360827     0.000000   99.999375       -0.000625     1.0      4402.360202             0.0         False      True
3    4602.361452    4602.360827 -213.853314  4602.361452   100.000625  4602.360827     0.000000    0.000625      -99.999375     1.0      4602.361452             0.0         False      True
4    5202.363327    4702.360827 -213.853314  5202.363327   600.002500  4702.360827     0.000000  500.002500      400.002500     1.0      4602.361452             0.0         False      True
5    6502.365827    4902.360596 -213.853314  6502.365827  1800.005000  4902.360596  1100.002500  500.002731      500.002500     2.0      4602.361452             0.0         False      True
6    6502.365827    4935.688535 -213.853314  6502.365827     0.010000  4935.688535  1100.002500  466.674792      400.002500     3.0      5402.363327             0.0         False      True
7    6702.366452    5002.360840 -213.853314  6702.366452   666.675417  5002.360840  1100.003125  600.002487      500.002500     4.0      5402.363327             0.0         False      True
8    6702.366452    5202.360596 -213.853314  6702.366452     0.010000  5202.360596  1100.003125  400.002731      400.002500     5.0      5602.363327             1.0         False      True
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=True, ramp_down_cwnd=True, total_losses=2, buffer=200001/400.[0m
[08/24 14:54:08]  --------------------------------------------------------------------------------
[08/24 14:54:08]  Iteration: 20 (0 solution, 19 counterexamples)
[08/24 14:54:10]  Generator returned sat in 1.466805 secs.
[08/24 14:54:10]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:11]  Improved gap from 0.001 to 23.4375
[08/24 14:54:12]  Improved number of small numbers from 59 to 66 out of a max of 114
[08/24 14:54:12]  Verifer returned sat in 1.866016 secs.
[08/24 14:54:12]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    4403.344482    4403.343327 -213.834564  4403.344482    0.001465  4403.343327    0.00000   0.001156      -99.998844     2.0      4403.343327            -1.0            -1       -1
1    4603.355827    4603.343327 -213.834564  4603.355827  200.012500  4603.343327    0.00125   0.011250        0.011250     1.0      4403.343327             1.0         False    False
2    4703.357077    4703.343327 -213.834564  4703.357077  100.012500  4703.343327    0.00250   0.011250        0.011250     1.0      4703.354577             0.0         False     True
3    4703.357077    4703.353327 -141.523314  4703.357077    0.011250  4703.353327    0.00250   0.001250      -27.677500     2.0      4703.354577             0.0         False     True
4    4853.360827    4831.032077 -141.523314  4853.360827  150.005000  4831.032077   22.31750   0.011250        0.011250     1.0      4703.354577             1.0         False    False
5    4853.360827    4831.033327  -64.962064  4853.360827    0.010000  4831.033327   22.31750   0.010000      -23.427500     2.0      4831.043327             0.0         False     True
6    4917.195827    4854.470827   -5.369629  4917.195827   63.845000  4854.470827   22.31750  40.407500       -0.000065     1.0      4831.043327             1.0         False    False
7    4952.347077    4906.593327   59.477783  4952.347077   75.558750  4906.593327   22.31750  23.436250       -0.001403     1.0      4831.043327             0.0         False    False
8    4966.691452    4930.031006   59.478027  4966.691452   37.780625  4930.031006   22.31750  14.342946      -85.656784     1.0      4944.373952             0.0         False    False
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=False, ramp_down_cwnd=True, total_losses=1, buffer=9/800.[0m
[08/24 14:54:12]  --------------------------------------------------------------------------------
[08/24 14:54:12]  Iteration: 21 (0 solution, 20 counterexamples)
[08/24 14:54:15]  Generator returned sat in 1.466840 secs.
[08/24 14:54:15]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:15]  Improved gap from 0.0008333333333333334 to 0
[08/24 14:54:16]  Improved number of small numbers from 69 to 102 out of a max of 114
[08/24 14:54:16]  Verifer returned sat in 1.057176 secs.
[08/24 14:54:16]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    4454.373779    4255.388916 -242.539062  4454.373779    0.001709  4255.388916    0.000000  198.984863       98.984863     2.0      4255.388916            -1.0            -1     False
1    4554.375488    4455.383789 -242.539062  4554.375488  298.986572  4455.383789    0.001709   98.989990       98.984863     1.0      4255.388916             0.0         False     False
2    4554.375488    4455.388916 -241.523926  4554.375488   98.988525  4455.388916    0.001709   98.984863        0.000000     2.0      4554.373779             0.0         False      True
3    4554.377197    4554.373779 -141.525635  4554.377197   98.986572  4554.373779    0.001709    0.001709        0.000000     3.0      4554.375488             0.0         False      True
4    4853.360352    4654.375488 -141.525635  4853.360352  298.984863  4654.375488  100.000000   98.984863       98.984863     1.0      4554.375488             1.0         False     False
5    4853.360352    4753.358929 -140.512207  4853.360352    0.010000  4753.358929  100.000000    0.001423       -0.001709     2.0      4753.360352             0.0         False      True
6    4853.368929    4753.362262  -40.520508  4853.368929    0.010000  4753.362262  100.000000    0.006667       -0.001432     1.0      4753.360352             0.0         False      True
7    4853.372262    4753.370596   59.477539  4853.372262    0.010000  4753.370596  100.000000    0.001667       -0.000052     1.0      4753.360352             0.0         False      True
8    4853.380596    4753.373779   59.477539  4853.380596    0.010000  4753.373779  100.000000    0.006816      -99.991719     1.0      4753.360352             0.0         False      True
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=True, ramp_down_cwnd=True, total_losses=1, buffer=202721/2048.[0m
[08/24 14:54:16]  --------------------------------------------------------------------------------
[08/24 14:54:16]  Iteration: 22 (0 solution, 21 counterexamples)
[08/24 14:54:17]  Generator returned sat in 0.186984 secs.
[08/24 14:54:17]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:18]  Improved gap from 0.0 to 31.25
[08/24 14:54:19]  Improved number of small numbers from 59 to 114 out of a max of 114
[08/24 14:54:19]  Verifer returned sat in 1.489791 secs.
[08/24 14:54:19]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    5426.513916    5426.511230 -977.985107  5426.513916    0.002500  5426.511230   0.000000    0.002686      -62.492188     3.0      5426.511230            -1.0            -1       -1
1    5620.253906    5489.006592 -977.985107  5620.253906  193.742676  5489.006592   0.000000  131.247314       31.247803     1.0      5426.511230             1.0         False    False
2    5651.506348    5620.256348 -940.485352  5651.506348  162.499756  5620.256348   0.000000   31.250000        0.000000     1.0      5651.506348             0.0         False    False
3    5782.753906    5751.506348 -940.485352  5782.753906  162.497559  5751.506348   0.000000   31.247559       31.247559     1.0      5782.753906             0.0         False    False
4    5914.003906    5849.386230 -940.485352  5914.003906  162.497559  5849.386230  31.247559   33.370117       31.250000     1.0      5782.753906             0.0         False    False
5    5914.003906    5851.506348 -871.735352  5914.003906    0.010000  5851.506348  31.247559   31.250000        0.000000     2.0      5882.756348             0.0         False     True
6    5914.003906    5882.756348 -802.985352  5914.003906    0.010000  5882.756348  31.247559    0.000000      -31.250000     3.0      5882.756348             0.0         False     True
7    5979.628906    5915.384766 -737.360352  5979.628906   65.625000  5915.384766  31.247559   32.996582        0.000000     1.0      5882.756348             1.0         False    False
8    5979.631592    5948.383789 -737.360107  5979.631592   32.999268  5948.383789  31.247559    0.000244      -99.997070     1.0      5948.384033             0.0         False    False
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=True, ramp_down_cwnd=True, total_losses=1, buffer=125/4.[0m
[08/24 14:54:19]  --------------------------------------------------------------------------------
[08/24 14:54:19]  Iteration: 23 (0 solution, 22 counterexamples)
[08/24 14:54:20]  Generator returned sat in 0.366521 secs.
[08/24 14:54:20]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:22]  Improved gap from 0.001220703125 to 100
[08/24 14:54:23]  Improved number of small numbers from 105 to 105 out of a max of 114
[08/24 14:54:23]  Verifer returned sat in 2.579873 secs.
[08/24 14:54:23]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t  cwnd_0,t  service_0,t  losts_0,t  queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    4784.553906    4714.003906 -411.135352  4784.553906    300.60  4714.003906        0.0    70.55           -0.10     4.0      4714.003906            -1.0            -1       -1
1    5014.503906    4784.653906 -411.135352  5014.503906    300.50  4784.653906        0.0   229.85          129.85     1.0      5014.503906             1.0         False    False
2    5014.503906    4884.653906 -411.135352  5014.503906    229.75  4884.653906        0.0   129.85           29.85     2.0      5014.503906             0.0         False    False
3    5384.553906    5014.503906 -411.135352  5384.553906    499.90  5014.503906        0.0   370.05          299.90     3.0      5014.503906             0.0         False    False
4    5414.703906    5184.653906 -411.135352  5414.703906    400.20  5184.653906        0.0   230.05          230.05     2.0      5414.703906             1.0         False    False
5    5584.753906    5184.653906 -411.135352  5584.753906    400.10  5184.653906        0.0   400.10          300.10     2.0      5584.753906             0.0         False    False
6    5584.753906    5384.653906 -411.135352  5584.753906    350.05  5384.653906        0.0   200.10          200.10     3.0      5584.753906             0.0         False    False
7    5744.753906    5484.653906 -411.135352  5744.753906    360.10  5484.653906        0.0   260.10          260.10     3.0      5584.753906             1.0         False    False
8    5814.703906    5484.653906 -411.135352  5814.703906    330.05  5484.653906        0.0   330.05          230.05     3.0      5814.703906             1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=0, buffer=1501/5.[0m
[08/24 14:54:24]  --------------------------------------------------------------------------------
[08/24 14:54:24]  Iteration: 24 (0 solution, 23 counterexamples)
[08/24 14:54:25]  Generator returned sat in 0.739664 secs.
[08/24 14:54:25]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:25]  Improved gap from 0.0 to 100
[08/24 14:54:26]  Improved number of small numbers from 89 to 91 out of a max of 114
[08/24 14:54:26]  Verifer returned sat in 0.767176 secs.
[08/24 14:54:26]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    4884.654053    4784.654053 -411.135742  4884.654053  199.999756  4784.654053     0.0025   99.997500       -0.002500     1.0      4784.654053            -1.0            -1       -1
1    4984.656553    4884.654053 -411.135742  4984.656553  200.000000  4884.654053     0.0025  100.000000        0.000000     1.0      4784.654053             0.0         False     True
2    5084.654053    5005.642726 -411.135742  5084.654053  199.997500  5005.642726     0.0025   79.008827       -0.002500     1.0      5084.651553             0.0         False     True
3    5084.659053    5084.654053 -411.135742  5084.659053   79.013827  5084.654053     0.0025    0.002500      -99.997500     1.0      5084.656553             0.0         False     True
4    5203.177293    5184.654053 -411.135742  5203.177293  118.520741  5184.654053     0.0025   18.520741      -81.479259     1.0      5084.656553             0.0         False     True
5    5362.437664    5284.654053 -411.135742  5362.437664  177.781111  5284.654053     0.0025   77.781111      -22.218889     1.0      5084.656553             0.0         False     True
6    5551.328219    5484.654053 -411.135742  5551.328219  266.671667  5484.654053     0.0025   66.671667       66.671667     1.0      5084.656553             0.0         False     True
7    5884.664053    5484.656738 -411.135742  5884.664053  400.007500  5484.656738     0.0050  400.002314      300.005000     2.0      5084.656553             0.0         False     True
8    5884.664053    5684.653809 -411.135742  5884.664053    0.010000  5684.653809     0.0050  200.005244      200.005000     2.0      5884.659053             1.0          True     True
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=1, buffer=60001/200.[0m
[08/24 14:54:26]  --------------------------------------------------------------------------------
[08/24 14:54:26]  Iteration: 25 (0 solution, 24 counterexamples)
[08/24 14:54:28]  Generator returned sat in 1.253633 secs.
[08/24 14:54:28]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:29]  Improved gap from 0.000625 to 100
[08/24 14:54:29]  Improved number of small numbers from 71 to 114 out of a max of 114
[08/24 14:54:29]  Verifer returned sat in 0.708045 secs.
[08/24 14:54:29]  Counter example: 
[93m   tot_arrival_t  tot_service_t   wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    4784.903809    4784.753906 -311.23584  4784.903809    0.050000  4784.753906   0.000000    0.149902        0.149902     1.0      4784.753906            -1.0            -1     False
1    4884.703857    4784.753906 -311.23584  4884.703857   99.949951  4784.753906   0.000000   99.949951       -0.050049     1.0      4784.753906             0.0         False     False
2    4984.954102    4884.753906 -311.23584  4984.954102  200.200195  4884.753906   0.050049  100.150146        0.150146     1.0      4784.753906             0.0         False     False
3    5084.753906    4984.904053 -311.23584  5084.753906  199.949951  4984.904053   0.050049   99.799805       -0.050049     2.0      5084.703857             0.0         False      True
4    5184.904053    5085.053955 -311.23584  5184.904053  199.949951  5085.053955   0.050049   99.800049        0.100098     1.0      5084.703857             1.0         False     False
5    5285.053955    5218.220703 -311.23584  5285.053955  199.949951  5218.220703   0.149902   66.683350        0.150146     1.0      5084.703857             0.0         False     False
6    5385.104004    5318.270752 -311.23584  5385.104004  166.733398  5318.270752   0.199951   66.633301        0.150146     1.0      5384.904053             0.0         False      True
7    5485.154053    5418.320557 -311.23584  5485.154053  166.683350  5418.320557   0.250000   66.583496        0.150146     1.0      5484.904053             0.0         False      True
8    5585.203857    5584.753906 -311.23584  5585.203857  166.633301  5584.753906   0.299805    0.150146        0.150146     1.0      5584.904053             0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss=False, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=True, ramp_down_cwnd=True, total_losses=4, buffer=615/4096.[0m
[08/24 14:54:30]  --------------------------------------------------------------------------------
[08/24 14:54:30]  Iteration: 26 (0 solution, 25 counterexamples)
[08/24 14:54:31]  Generator returned sat in 0.370228 secs.
[08/24 14:54:31]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:31]  Improved number of small numbers from 63 to 113 out of a max of 113
[08/24 14:54:31]  Verifer returned sat in 0.335327 secs.
[08/24 14:54:31]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    4784.905029    4784.902588 -311.384521  4784.905029  199.997314  4784.902588   0.001221    0.001221        0.001221     1.0      4784.902588            -1.0            -1       -1
1    4984.901123    4784.902588 -311.384521  4984.901123  199.997314  4784.902588   0.001221  199.997314       99.997314     1.0      4784.902588             0.0         False     True
2    4984.903564    4984.901123 -311.384521  4984.903564  199.999756  4984.901123   0.001221    0.001221       -0.000244     1.0      4784.902588             0.0         False     True
3    5084.902344    5084.900146 -311.384521  5084.902344  100.000000  5084.900146   0.001221    0.000977       -0.001465     1.0      5084.901123             0.0         False     True
4    5534.898926    5084.902588 -311.384521  5534.898926  449.997559  5084.902588   0.001221  449.995117      349.995117     1.0      5084.901123             0.0         False     True
5    6059.900146    5184.903809 -311.384521  6059.900146  974.996338  5184.903809   0.001221  874.995117      774.996338     2.0      5084.901123             0.0         False     True
6    6159.901367    5384.902344 -311.384521  6159.901367  974.996338  5384.902344   0.002441  774.996582      774.996338     3.0      5084.901123             1.0          True    False
7    6159.901367    5484.902344 -311.384521  6159.901367    0.010000  5484.902344   0.002441  674.996582      674.996338     4.0      6159.898926             1.0          True     True
8    6159.901367    5534.898682 -311.384521  6159.901367    0.010000  5534.898682   0.002441  625.000244      574.996338     4.0      6159.898926             1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=1, buffer=3174385/4096.[0m
[08/24 14:54:32]  --------------------------------------------------------------------------------
[08/24 14:54:32]  Iteration: 27 (0 solution, 26 counterexamples)
[08/24 14:54:33]  Generator returned sat in 0.580408 secs.
[08/24 14:54:33]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:34]  Improved number of small numbers from 100 to 113 out of a max of 113
[08/24 14:54:34]  Verifer returned sat in 0.207210 secs.
[08/24 14:54:34]  Counter example: 
[93m   tot_arrival_t  tot_service_t    wasted_t  arrival_0,t     cwnd_0,t  service_0,t    losts_0,t      queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    4884.901855    4684.901123 -211.383057  4884.901855     0.000244  4684.901123     0.000977   199.999756      199.999756     1.0      4684.901123            -1.0            -1       -1
1    4884.901855    4684.901123 -211.383057  4884.901855   199.999512  4684.901123     0.000977   199.999756       99.999756     1.0      4684.901123             0.0         False     True
2    5084.901855    4884.901123 -211.383057  5084.901855   399.999756  4884.901123     0.000977   199.999756      199.999756     1.0      4684.901123             0.0         False     True
3    5084.902100    4884.901123 -211.383057  5084.902100   200.000000  4884.901123     0.000977   200.000000      100.000000     1.0      5084.901123             0.0         False     True
4    5584.902100    5084.901123 -211.383057  5584.902100   700.000000  5084.901123     0.000977   500.000000      500.000000     2.0      5084.901123             0.0         False     True
5    6934.902100    5084.901123 -211.383057  6934.902100  1850.000000  5084.901123     0.000977  1850.000000     1750.000000     2.0      5084.901123             0.0         False     True
6    8259.902100    5184.901123 -211.383057  8259.902100  3175.000000  5184.901123  1225.000977  1850.000000     1750.000000     3.0      5084.901123             0.0         False     True
7    8259.902100    5284.901123 -211.383057  8259.902100     0.010000  5284.901123  1225.000977  1750.000000     1650.000000     4.0      7034.901123             1.0          True     True
8    8259.902100    5484.901123 -211.383057  8259.902100     0.010000  5484.901123  1225.000977  1550.000000     1550.000000     5.0      7034.901123             1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=1, buffer=1750.[0m
[08/24 14:54:34]  --------------------------------------------------------------------------------
[08/24 14:54:34]  Iteration: 28 (0 solution, 27 counterexamples)
[08/24 14:54:36]  Generator returned sat in 0.823617 secs.
[08/24 14:54:36]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:36]  Improved gap from 0.00125 to 100
[08/24 14:54:37]  Improved number of small numbers from 60 to 114 out of a max of 114
[08/24 14:54:37]  Verifer returned sat in 0.773162 secs.
[08/24 14:54:37]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t   losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    5837.234863    5837.135010 -1463.616943  5837.234863  205.199951  5837.135010    0.000000    0.099854      -99.900146     2.0      5837.135010            -1.0            -1     False
1    6042.234863    5937.235107 -1463.616943  6042.234863  205.099854  5937.235107    0.000000  104.999756        5.099854     1.0      6042.234863             0.0         False     False
2    6142.235107    6088.834961 -1463.616943  6142.235107  205.000000  6088.834961    0.000000   53.400146        5.100098     1.0      6142.235107             0.0         False     False
3    6287.734863    6234.735107 -1463.616943  6287.734863  198.899902  6234.735107   45.399902    7.599854        5.199951     1.0      6242.334961             0.0         False     False
4    6478.935059    6337.135010 -1463.616943  6478.935059  198.800049  6337.135010  136.600098    5.199951        5.199951     1.0      6342.334961             0.0         False      True
5    6673.685059    6391.234863 -1463.616943  6673.685059  199.949951  6391.234863  231.350098   51.100098        5.199951     1.0      6342.334961             0.0         False      True
6    6773.784912    6537.135010 -1463.616943  6773.784912  151.199951  6537.135010  231.449951    5.199951        5.199951     1.0      6542.334961             0.0         False      True
7    6919.784912    6637.135010 -1463.616943  6919.784912  151.199951  6637.135010  277.449951    5.199951        5.199951     1.0      6542.334961             0.0         False      True
8    7064.584961    6642.434814 -1463.616943  7064.584961  150.000000  6642.434814  322.250000   99.900146        5.199951     1.0      6742.334961             0.0         False      True
fefficient=True, bounded_queue=True, bounded_loss=False, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=5, buffer=21299/4096.[0m
[08/24 14:54:37]  --------------------------------------------------------------------------------
[08/24 14:54:37]  Iteration: 29 (0 solution, 28 counterexamples)
[08/24 14:54:38]  Generator returned sat in 0.199630 secs.
[08/24 14:54:38]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:40]  Improved gap from 0.0 to 9.375
[08/24 14:54:41]  Improved number of small numbers from 66 to 81 out of a max of 114
[08/24 14:54:41]  Verifer returned sat in 2.909409 secs.
[08/24 14:54:41]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    6061.844727    6035.934863 -1578.954297  6061.844727    0.002686  6035.934863     0.0000  25.909863        9.372363     2.0      6035.934863            -1.0            -1      True
1    6161.842363    6135.934814 -1578.954297  6161.842363  125.907500  6135.934814     0.0000  25.907549        9.370000     1.0      6035.934863             0.0         False      True
2    6261.842529    6240.877363 -1578.954297  6261.842529  125.907715  6240.877363     0.0000  20.965166        9.370166     1.0      6035.934863             0.0         False      True
3    6261.842529    6252.472363 -1488.329297  6261.842529   20.962500  6252.472363     0.0000   9.370166       -0.004834     2.0      6261.842529             0.0         False      True
4    6371.222363    6361.844863 -1488.329297  6371.222363  118.750000  6361.844863     0.0025   9.375000        9.372500     1.0      6261.842529             0.0         False      True
5    6371.222363    6361.847363 -1397.704297  6371.222363    0.010000  6361.847363     0.0025   9.372500       -0.002500     2.0      6371.219863             0.0         False      True
6    6422.339863    6371.222363 -1348.819336  6422.339863   60.490000  6371.222363     0.0025  51.115000       -0.000039     1.0      6371.219863             0.0         False      True
7    6460.844863    6422.339863 -1287.324463  6460.844863   89.620000  6422.339863     0.0025  38.502500       -0.000166     1.0      6371.219863             0.0         False      True
8    6497.399863    6460.842529 -1287.324463  6497.399863   75.057500  6460.842529     0.0025  36.554834      -63.445166     1.0      6497.397363             0.0         False      True
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=False, ramp_down_cwnd=True, total_losses=1, buffer=3749/400.[0m
[08/24 14:54:42]  --------------------------------------------------------------------------------
[08/24 14:54:42]  Iteration: 30 (0 solution, 29 counterexamples)
[08/24 14:54:46]  Generator returned sat in 3.402733 secs.
[08/24 14:54:46]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:46]  Verifer returned unsat in 0.192063 secs.
[08/24 14:54:46]  Proved solution: 
[1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:47]  --------------------------------------------------------------------------------
[08/24 14:54:47]  Iteration: 31 (1 solution, 29 counterexamples)
[08/24 14:54:48]  Generator returned sat in 0.519083 secs.
[08/24 14:54:48]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:49]  Improved gap from 0.005 to 100
[08/24 14:54:49]  Improved number of small numbers from 89 to 93 out of a max of 114
[08/24 14:54:49]  Verifer returned sat in 1.196895 secs.
[08/24 14:54:49]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    6140.842529    6061.842529 -1588.324463  6140.842529  200.000000  6061.842529    0.00125   78.998750       78.998750     1.0      6061.842529            -1.0            -1       -1
1    6261.842529    6140.842529 -1588.324463  6261.842529  199.998750  6140.842529    0.00125  120.998750       99.998750     1.0      6261.841279             0.0         False     True
2    6361.842529    6261.842529 -1588.324463  6361.842529  220.998750  6261.842529    0.00125   99.998750       99.998750     1.0      6261.841279             0.0         False     True
3    6361.842529    6261.842529 -1588.324463  6361.842529    0.001250  6261.842529    0.00125   99.998750       -0.001250     1.0      6361.841279             0.0         False     True
4    6461.844404    6361.842529 -1588.324463  6461.844404  200.000625  6361.842529    0.00125  100.000625        0.000625     1.0      6361.841279             0.0         False     True
5    6682.844092    6561.842529 -1588.324463  6682.844092  321.000313  6561.842529    0.00125  121.000313      121.000313     1.0      6361.841279             0.0         False     True
6    7022.343936    6561.843994 -1588.324463  7022.343936  460.500156  6561.843994    0.00250  460.497441      360.498906     2.0      6361.841279             0.0         False     True
7    7022.343936    6682.844238 -1588.324463  7022.343936    0.010000  6682.844238    0.00250  339.497197      260.498906     2.0      7022.341436             1.0          True     True
8    7022.343936    6761.842529 -1588.324463  7022.343936  321.001709  6761.842529    0.00250  260.498906      160.498906     3.0      7022.341436             1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=True, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=False, total_losses=1, buffer=2307193/6400.[0m
[08/24 14:54:50]  --------------------------------------------------------------------------------
[08/24 14:54:50]  Iteration: 32 (1 solution, 30 counterexamples)
[08/24 14:54:51]  Generator returned sat in 0.234581 secs.
[08/24 14:54:51]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 3/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:52]  Improved gap from 0.1 to 100
[08/24 14:54:52]  Improved number of small numbers from 79 to 83 out of a max of 114
[08/24 14:54:52]  Verifer returned sat in 1.368016 secs.
[08/24 14:54:52]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    6145.178467    6028.516696 -1588.324707  6145.178467     0.002686  6028.516696    0.00250  116.659271       83.333438     1.0      6028.516696            -1.0            -1       -1
1    6145.183363    6145.178363 -1588.324707  6145.183363   116.664167  6145.178363    0.00250    0.002500      -16.661667     1.0      6028.516696             0.0         False     True
2    6261.845029    6161.842529 -1588.324707  6261.845029   116.664167  6161.842529    0.00250  100.000000        0.000000     1.0      6028.516696             0.0         False     True
3    6261.850029    6261.845029 -1588.324707  6261.850029   100.005000  6261.845029    0.00250    0.002500      -99.995000     1.0      6261.847529             0.0         False     True
4    6761.847529    6361.842529 -1588.324707  6761.847529   500.000000  6361.842529    0.00250  400.002500      300.002500     1.0      6261.847529             0.0         False     True
5    7436.841279    6561.842529 -1588.324707  7436.841279  1074.996250  6561.842529  274.99625  600.002500      600.002500     2.0      6261.847529             0.0         False     True
6    7436.841279    6661.842529 -1588.324707  7436.841279     0.010000  6661.842529  274.99625  500.002500      500.002500     3.0      7161.845029             1.0          True     True
7    7436.841279    6661.845215 -1588.324707  7436.841279   399.997500  6661.845215  274.99625  499.999814      400.002500     4.0      7161.845029             1.0         False    False
8    7436.841279    6861.842529 -1588.324707  7436.841279   300.002686  6861.842529  274.99625  300.002500      300.002500     4.0      7161.845029             1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=True, ramp_down_cwnd=True, total_losses=1, buffer=240001/400.[0m
[08/24 14:54:53]  --------------------------------------------------------------------------------
[08/24 14:54:53]  Iteration: 33 (1 solution, 31 counterexamples)
[08/24 14:54:57]  Generator returned sat in 2.891366 secs.
[08/24 14:54:57]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:54:58]  Improved gap from 0.0 to 0
[08/24 14:54:58]  Improved number of small numbers from 66 to 87 out of a max of 114
[08/24 14:54:58]  Verifer returned sat in 1.386561 secs.
[08/24 14:54:58]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    6413.501465    5913.502441 -1588.324951  6413.501465    0.000488  5913.502441  399.99875  100.000273      100.000195     5.0      5913.502441            -1.0            -1     False
1    6413.501465    6013.502197 -1588.324951  6413.501465    0.002686  6013.502197  399.99875    0.000518        0.000195     2.0      5913.502441             0.0         False     False
2    6413.502900    6013.503525 -1588.324951  6413.502900    0.001953  6013.503525  399.99875    0.000625      -99.998369     1.0      6013.504150             0.0         False     False
3    6728.511650    6213.502441 -1588.324951  6728.511650  315.009375  6213.502441  399.99875  115.010459      115.010381     1.0      6013.504150             0.0         False     False
4    6728.511650    6229.524170 -1588.324951  6728.511650    0.010000  6229.524170  399.99875   98.988730       15.010381     2.0      6328.512900             0.0         False     False
5    6728.511650    6328.502441 -1503.335332  6728.511650    0.010000  6328.502441  399.99875    0.010459        0.000000     3.0      6328.512900             0.0         False     False
6    6728.511650    6328.512900 -1403.335449  6728.511650    0.010000  6328.512900  399.99875    0.000000       -0.000117     4.0      6328.512900             0.0         False     False
7    6728.521650    6328.513525 -1303.345459  6728.521650    0.010000  6328.513525  399.99875    0.009375       -0.000127     1.0      6328.512900             0.0         False     False
8    6728.522275    6328.523438 -1203.346191  6728.522275    0.010000  6328.523438  399.99875    0.000088       -0.000234     1.0      6328.512900             0.0         False     False
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=True, ramp_down_cwnd=False, total_losses=0, buffer=471087/4096.[0m
[08/24 14:54:59]  --------------------------------------------------------------------------------
[08/24 14:54:59]  Iteration: 34 (1 solution, 32 counterexamples)
[08/24 14:55:00]  Generator returned sat in 0.456244 secs.
[08/24 14:55:00]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 3/2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:01]  Improved gap from 0.1 to 100
[08/24 14:55:02]  Improved number of small numbers from 59 to 65 out of a max of 114
[08/24 14:55:02]  Verifer returned sat in 1.266481 secs.
[08/24 14:55:02]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t     cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    6429.512695    6429.507900 -2104.330332  6429.512695     0.002686  6429.507900    0.00250    0.002295        0.002295     1.0      6429.507900            -1.0            -1       -1
1    6629.502900    6429.515400 -2104.330332  6629.502900   199.992500  6429.515400    0.00250  199.985000       99.992500     1.0      6429.507900             0.0         False     True
2    6629.507900    6629.502900 -2104.330332  6629.507900   199.990000  6629.502900    0.00250    0.002500       -0.002500     1.0      6629.505400             0.0         False     True
3    6696.173734    6629.507900 -2104.330332  6696.173734    66.668333  6629.507900    0.00250   66.663333      -33.336667     1.0      6696.171234             0.0         False     True
4    7129.512900    6829.507900 -2104.330332  7129.512900   500.002500  6829.507900    0.00250  300.002500      300.002500     1.0      6696.171234             0.0         False     True
5    8379.499150    6829.510254 -2104.330332  8379.499150  1549.988750  6829.510254  849.98625  700.002646      600.005000     2.0      6696.171234             0.0         False     True
6    8379.499150    6929.507900 -2104.330332  8379.499150     0.010000  6929.507900  849.98625  600.005000      500.005000     3.0      7529.512900             1.0          True     True
7    8379.499150    7129.507900 -2104.330332  8379.499150   300.000000  7129.507900  849.98625  400.005000      400.005000     4.0      7529.512900             1.0         False    False
8    8379.499150    7129.510254 -2104.330332  8379.499150   300.000000  7129.510254  849.98625  400.002646      300.005000     5.0      7529.512900             1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=1, buffer=120001/200.[0m
[08/24 14:55:02]  --------------------------------------------------------------------------------
[08/24 14:55:02]  Iteration: 35 (1 solution, 33 counterexamples)
[08/24 14:55:05]  Generator returned sat in 1.718277 secs.
[08/24 14:55:05]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:06]  Improved gap from 0.00125 to 31.25
[08/24 14:55:07]  Improved number of small numbers from 59 to 114 out of a max of 114
[08/24 14:55:07]  Verifer returned sat in 1.489182 secs.
[08/24 14:55:07]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    6598.840332    6299.040527 -2104.330322  6598.840332  299.999756  6299.040527   0.000000  299.799805      199.799805     3.0      6299.040527            -1.0            -1     False
1    6598.940430    6499.040283 -2104.330322  6598.940430  299.899902  6499.040283   0.000000   99.900146       99.899902     3.0      6598.940430             0.0         False     False
2    6830.390381    6599.040283 -2104.330322  6830.390381  331.350098  6599.040283   0.099854  231.250244      231.250000     1.0      6598.940430             0.0         False     False
3    6830.390381    6699.040527 -2104.330322  6830.390381  130.450000  6699.040527   0.099854  131.250000      131.250000     2.0      6830.290527             0.0         False      True
4    6830.390381    6797.578125 -2104.330322  6830.390381   65.225000  6797.578125   0.099854   32.712402       31.250000     3.0      6830.290527             0.0         False      True
5    6830.390381    6799.040527 -2035.580322  6830.390381   32.612500  6799.040527   0.099854   31.250000        0.000000     4.0      6830.290527             0.0         False      True
6    6830.390381    6830.290527 -1968.492676  6830.390381   16.306250  6830.290527   0.099854    0.000000      -32.912354     5.0      6830.290527             0.0         False      True
7    6896.015381    6863.203125 -1901.205566  6896.015381   65.625000  6863.203125   0.099854   32.712402       -0.000244     1.0      6830.290527             1.0         False     False
8    6896.115479    6896.015381 -1901.205566  6896.115479   32.812500  6896.015381   0.099854    0.000244      -99.900146     1.0      6896.015625             0.0         False     False
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=True, ramp_down_cwnd=True, total_losses=0, buffer=925/4.[0m
[08/24 14:55:07]  --------------------------------------------------------------------------------
[08/24 14:55:07]  Iteration: 36 (1 solution, 34 counterexamples)
[08/24 14:55:09]  Generator returned sat in 0.491414 secs.
[08/24 14:55:09]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:10]  Improved gap from 11.242857142857142 to 100
[08/24 14:55:11]  Improved number of small numbers from 92 to 98 out of a max of 114
[08/24 14:55:11]  Verifer returned sat in 1.823233 secs.
[08/24 14:55:11]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    6898.990234    6399.040283 -2204.330078  6898.990234  499.949951  6399.040283       0.00  499.949951      399.949951     6.0      6399.040283            -1.0            -1       -1
1    6898.990234    6499.040283 -2204.330078  6898.990234  499.900146  6499.040283       0.00  399.949951      299.949951     4.0      6898.990234             1.0         False    False
2    7099.040283    6599.040283 -2204.330078  7099.040283  600.000000  6599.040283       0.05  499.950000      399.950000     4.0      6898.990234             0.0         False    False
3    7099.040283    6699.540283 -2204.330078  7099.040283  499.900000  6699.540283       0.05  399.450000      299.950000     5.0      7098.990283             0.0         False     True
4    7099.790283    6899.040283 -2204.330078  7099.790283  400.200000  6899.040283       0.05  200.700000      200.700000     3.0      7099.740283             1.0         False    False
5    7299.190283    6899.090283 -2204.330078  7299.190283  400.100000  6899.090283       0.05  400.050000      300.100000     4.0      7299.140283             0.0         False    False
6    7299.190283    7099.040283 -2204.330078  7299.190283  350.075000  7099.040283       0.05  200.100000      200.100000     3.0      7299.140283             0.0         False    False
7    7473.877783    7199.040283 -2204.330078  7473.877783  374.787500  7199.040283       0.05  274.787500      274.787500     3.0      7299.140283             0.0         False    False
8    7536.484033    7299.040039 -2204.330078  7536.484033  337.393750  7299.040039       0.05  237.393994      237.393750     4.0      7536.434033             0.0         False    False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=0, buffer=7999/20.[0m
[08/24 14:55:11]  --------------------------------------------------------------------------------
[08/24 14:55:11]  Iteration: 37 (1 solution, 35 counterexamples)
[08/24 14:55:15]  Generator returned sat in 2.753322 secs.
[08/24 14:55:15]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:16]  Improved gap from 0.0 to 23.4375
[08/24 14:55:16]  Improved number of small numbers from 70 to 114 out of a max of 114
[08/24 14:55:16]  Verifer returned sat in 0.706808 secs.
[08/24 14:55:16]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t   cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    6842.013428    6741.042480 -2357.455078  6842.013428   0.028809  6741.042480        0.0  100.970947       99.970947     9.0      6741.042480            -1.0            -1       -1
1    6842.013428    6841.781250 -2357.455078  6842.013428   0.029053  6841.781250        0.0    0.232178       -0.029053     8.0      6741.042480             1.0         False    False
2    6865.479980    6842.042480 -2280.892578  6865.479980  23.698730  6842.042480        0.0   23.437500        0.000000     1.0      6741.042480             0.0         False    False
3    6865.479980    6865.479980 -2204.330078  6865.479980   0.029053  6865.479980        0.0    0.000000      -23.437500     2.0      6865.479980             0.0         False    False
4    6927.698730    6899.040039 -2143.111328  6927.698730  62.218750  6899.040039        0.0   28.658691        0.000000     1.0      6865.479980             0.0         False    False
5    6927.698730    6927.698730 -2066.548828  6927.698730  28.629395  6927.698730        0.0    0.000000      -23.437500     2.0      6927.698730             0.0         False    False
6    6970.526855    6951.136230 -1989.986328  6970.526855  42.828125  6951.136230        0.0   19.390625       -4.046875     1.0      6927.698730             0.0         False    False
7    6993.964355    6974.573730 -1913.423828  6993.964355  42.828125  6974.573730        0.0   19.390625       -4.046875     1.0      6927.698730             0.0         False    False
8    7012.340576    6998.011230 -1836.861572  7012.340576  37.766846  6998.011230        0.0   14.329346       -9.108398     1.0      7012.340576             0.0         False    False
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=True, ramp_down_cwnd=True, total_losses=0, buffer=204741/2048.[0m
[08/24 14:55:16]  --------------------------------------------------------------------------------
[08/24 14:55:16]  Iteration: 38 (1 solution, 36 counterexamples)
[08/24 14:55:18]  Generator returned sat in 0.560858 secs.
[08/24 14:55:18]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:18]  Verifer returned unsat in 0.310320 secs.
[08/24 14:55:18]  Proved solution: 
[1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:19]  --------------------------------------------------------------------------------
[08/24 14:55:19]  Iteration: 39 (2 solution, 36 counterexamples)
[08/24 14:55:20]  Generator returned sat in 0.208543 secs.
[08/24 14:55:20]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:20]  Verifer returned unsat in 0.242273 secs.
[08/24 14:55:20]  Proved solution: 
[1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:20]  --------------------------------------------------------------------------------
[08/24 14:55:20]  Iteration: 40 (3 solution, 36 counterexamples)
[08/24 14:55:21]  Generator returned sat in 0.209498 secs.
[08/24 14:55:22]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:22]  Verifer returned unsat in 0.170660 secs.
[08/24 14:55:22]  Proved solution: 
[1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:22]  --------------------------------------------------------------------------------
[08/24 14:55:22]  Iteration: 41 (4 solution, 36 counterexamples)
[08/24 14:55:23]  Generator returned sat in 0.468217 secs.
[08/24 14:55:23]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:25]  Improved gap from 0.0 to 9.375
[08/24 14:55:26]  Improved number of small numbers from 68 to 89 out of a max of 114
[08/24 14:55:26]  Verifer returned sat in 2.093585 secs.
[08/24 14:55:26]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    7948.843750    7848.943730 -3095.236328  7948.843750  403.499756  7848.943730        0.0   99.900020       99.900020     6.0      7848.943730            -1.0            -1       -1
1    8252.343730    7848.943848 -3095.236328  8252.343730  403.400000  7848.943848      100.0  303.399883      203.400000     3.0      8152.343730             1.0         False    False
2    8352.243652    7948.943848 -3095.236328  8352.243652  403.299805  7948.943848      100.0  303.299805      203.299922     2.0      8252.243652             0.0         False     True
3    8352.243652    8100.543945 -3095.236328  8352.243652  303.200000  8100.543945      100.0  151.699707      103.299922     3.0      8252.243652             0.0         False     True
4    8352.243652    8248.943730 -3095.236328  8352.243652  151.600000  8248.943730      100.0    3.299922        3.299922     3.0      8252.243652             0.0         False     True
5    8424.743730    8252.343506 -3071.036328  8424.743730   75.800000  8252.343506      100.0   72.400225        0.000000     1.0      8324.743730             0.0         False     True
6    8424.743730    8324.743730 -2980.411328  8424.743730   37.900000  8324.743730      100.0    0.000000       -9.375000     2.0      8324.743730             0.0         False     True
7    8443.693730    8334.118896 -2889.986328  8443.693730   18.950000  8334.118896      100.0    9.574834        0.000000     1.0      8343.693730             0.0         False     True
8    8443.693730    8343.693730 -2889.986328  8443.693730    9.475000  8343.693730      100.0    0.000000     -100.000000     2.0      8343.693730             0.0         False     True
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=True, ramp_down_cwnd=True, total_losses=0, buffer=1017/5.[0m
[08/24 14:55:26]  --------------------------------------------------------------------------------
[08/24 14:55:26]  Iteration: 42 (4 solution, 37 counterexamples)
[08/24 14:55:29]  Generator returned sat in 1.365497 secs.
[08/24 14:55:29]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:29]  Verifer returned unsat in 0.216132 secs.
[08/24 14:55:29]  Proved solution: 
[1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:29]  --------------------------------------------------------------------------------
[08/24 14:55:29]  Iteration: 43 (5 solution, 37 counterexamples)
[08/24 14:55:32]  Generator returned sat in 1.461733 secs.
[08/24 14:55:32]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:32]  Verifer returned unsat in 0.203189 secs.
[08/24 14:55:32]  Proved solution: 
[1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:32]  --------------------------------------------------------------------------------
[08/24 14:55:32]  Iteration: 44 (6 solution, 37 counterexamples)
[08/24 14:55:34]  Generator returned sat in 0.505379 secs.
[08/24 14:55:34]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][5]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:34]  Verifer returned unsat in 0.186013 secs.
[08/24 14:55:34]  Proved solution: 
[1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][5]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:34]  --------------------------------------------------------------------------------
[08/24 14:55:34]  Iteration: 45 (7 solution, 37 counterexamples)
[08/24 14:55:36]  Generator returned sat in 0.920805 secs.
[08/24 14:55:36]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][6]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:36]  Verifer returned unsat in 0.219641 secs.
[08/24 14:55:36]  Proved solution: 
[1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][6]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:36]  --------------------------------------------------------------------------------
[08/24 14:55:36]  Iteration: 46 (8 solution, 37 counterexamples)
[08/24 14:55:38]  Generator returned sat in 0.544945 secs.
[08/24 14:55:38]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][6]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:39]  Improved number of small numbers from 58 to 62 out of a max of 113
[08/24 14:55:39]  Verifer returned sat in 1.334719 secs.
[08/24 14:55:39]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    8510.416016    8410.441230 -3756.733828  8510.416016    0.025146  8410.441230        0.0   99.974785       -0.025215     2.0       8410.44123            -1.0            -1     False
1    8610.416230    8510.441230 -3756.733828  8610.416230  199.975000  8510.441230        0.0   99.975000       -0.025000     1.0       8410.44123             0.0         False     False
2    8610.441230    8610.441230 -3756.733828  8610.441230  100.000000  8610.441230        0.0    0.000000     -100.000000     1.0       8610.44123             0.0         False     False
3    9110.691230    8710.441230 -3756.733828  9110.691230  500.250000  8710.441230        0.0  400.250000      300.250000     1.0       8610.44123             0.0         False     False
4    9110.691230    8910.416230 -3756.733828  9110.691230  400.125000  8910.416230        0.0  200.275000      200.250000     2.0       9110.69123             0.0         False     False
5    9310.466230    8910.441230 -3756.733828  9310.466230  400.050000  8910.441230        0.0  400.025000      300.025000     3.0       9310.46623             0.0         False     False
6    9310.466230    9020.441230 -3756.733828  9310.466230  350.025000  9020.441230        0.0  290.025000      200.025000     4.0       9310.46623             0.0         False     False
7    9350.453730    9210.441230 -3756.733828  9350.453730  330.012500  9210.441230        0.0  140.012500      140.012500     3.0       9350.45373             0.0         False     False
8    9525.459980    9210.466309 -3756.733828  9525.459980  315.018750  9210.466309        0.0  314.993672      215.018750     4.0       9525.45998             0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=0, buffer=1229927/4096.[0m
[08/24 14:55:40]  --------------------------------------------------------------------------------
[08/24 14:55:40]  Iteration: 47 (8 solution, 38 counterexamples)
[08/24 14:55:44]  Generator returned sat in 2.477062 secs.
[08/24 14:55:44]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][6]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:44]  Improved number of small numbers from 58 to 113 out of a max of 113
[08/24 14:55:44]  Verifer returned sat in 0.423638 secs.
[08/24 14:55:44]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    9109.441406    8709.641357 -3356.644043  9109.441406    0.099854  8709.641357   0.000000  399.800049      299.800049     6.0      8709.641357            -1.0            -1      True
1    9109.441406    8909.641113 -3356.644043  9109.441406    0.100000  8909.641113   0.000000  199.800293      199.800049     6.0      8709.641357             0.0         False      True
2    9109.541016    9009.441406 -3356.644043  9109.541016  199.899902  9009.441406   0.000000  100.099609       99.899658     7.0      8709.641357             0.0         False      True
3    9409.741211    9009.641357 -3356.644043  9409.741211  400.299805  9009.641357   0.000000  400.099854      300.099854     4.0      8709.641357             1.0          True     False
4    9409.941162    9109.641357 -3356.644043  9409.941162  400.299805  9109.641357   0.000000  300.299805      200.299805     2.0      8709.641357             0.0         False     False
5    9509.941162    9309.441406 -3356.644043  9509.941162  400.299805  9309.441406   0.000000  200.499756      200.299805     3.0      8709.641357             0.0         False     False
6    9709.741211    9309.641357 -3356.644043  9709.741211  400.299805  9309.641357   0.000000  400.099854      300.099854     4.0      8709.641357             0.0         False     False
7    9709.941162    9509.641357 -3356.644043  9709.941162  400.299805  9509.641357   0.000000  200.299805      200.299805     3.0      8709.641357             0.0         False     False
8    9909.941162    9509.741455 -3356.644043  9909.941162  400.299805  9509.741455   0.099854  400.099854      300.199951     4.0      8709.641357             0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=False, total_losses=1, buffer=1229619/4096.[0m
[08/24 14:55:45]  --------------------------------------------------------------------------------
[08/24 14:55:45]  Iteration: 48 (8 solution, 39 counterexamples)
[08/24 14:55:47]  Generator returned sat in 0.849802 secs.
[08/24 14:55:47]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:47]  Improved number of small numbers from 113 to 113 out of a max of 113
[08/24 14:55:47]  Verifer returned sat in 0.145924 secs.
[08/24 14:55:47]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    9109.441406    8709.641357 -3356.644043  9109.441406    0.099854  8709.641357   0.000000  399.800049      299.800049     7.0      8709.641357            -1.0            -1      True
1    9109.441406    8909.641113 -3356.644043  9109.441406    0.100000  8909.641113   0.000000  199.800293      199.800049     7.0      8709.641357             0.0         False      True
2    9109.541016    9009.441406 -3356.644043  9109.541016  199.899902  9009.441406   0.000000  100.099609       99.899658     8.0      8709.641357             0.0         False      True
3    9409.741211    9009.641357 -3356.644043  9409.741211  400.299805  9009.641357   0.000000  400.099854      300.099854     4.0      8709.641357             1.0          True     False
4    9409.941162    9109.641357 -3356.644043  9409.941162  400.299805  9109.641357   0.000000  300.299805      200.299805     2.0      8709.641357             0.0         False     False
5    9509.941162    9309.441406 -3356.644043  9509.941162  400.299805  9309.441406   0.000000  200.499756      200.299805     3.0      8709.641357             0.0         False     False
6    9709.741211    9309.641357 -3356.644043  9709.741211  400.299805  9309.641357   0.000000  400.099854      300.099854     4.0      8709.641357             0.0         False     False
7    9709.941162    9509.641357 -3356.644043  9709.941162  400.299805  9509.641357   0.000000  200.299805      200.299805     3.0      8709.641357             0.0         False     False
8    9909.941162    9509.741455 -3356.644043  9909.941162  400.299805  9509.741455   0.099854  400.099854      300.199951     4.0      8709.641357             0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=False, total_losses=1, buffer=1229619/4096.[0m
[08/24 14:55:48]  --------------------------------------------------------------------------------
[08/24 14:55:48]  Iteration: 49 (8 solution, 40 counterexamples)
[08/24 14:55:49]  Generator returned sat in 0.597941 secs.
[08/24 14:55:49]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 1v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:50]  Improved number of small numbers from 113 to 113 out of a max of 113
[08/24 14:55:50]  Verifer returned sat in 0.151129 secs.
[08/24 14:55:50]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t     queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease  v.mode_f
0    9109.441162    8709.641357 -3356.644043  9109.441162    0.099854  8709.641357   0.000000  399.799805      299.799805     8.0      8709.641357            -1.0            -1      True
1    9109.441162    8909.641113 -3356.644043  9109.441162    0.099854  8909.641113   0.000000  199.800049      199.799805     8.0      8709.641357             0.0         False      True
2    9109.541016    9009.441406 -3356.644043  9109.541016  199.899902  9009.441406   0.000000  100.099609       99.899658     9.0      8709.641357             0.0         False      True
3    9409.740967    9009.641357 -3356.644043  9409.740967  400.299561  9009.641357   0.000000  400.099609      300.099609     4.0      8709.641357             1.0          True     False
4    9409.940918    9109.641357 -3356.644043  9409.940918  400.299561  9109.641357   0.000000  300.299561      200.299561     2.0      8709.641357             0.0         False     False
5    9509.940918    9309.441406 -3356.644043  9509.940918  400.299561  9309.441406   0.000000  200.499512      200.299561     3.0      8709.641357             0.0         False     False
6    9709.740967    9309.641357 -3356.644043  9709.740967  400.299561  9309.641357   0.000000  400.099609      300.099609     4.0      8709.641357             0.0         False     False
7    9709.940918    9509.641357 -3356.644043  9709.940918  400.299561  9509.641357   0.000000  200.299561      200.299561     3.0      8709.641357             0.0         False     False
8    9909.940918    9509.741211 -3356.644043  9909.940918  400.299561  9509.741211   0.099854  400.099854      300.199707     4.0      8709.641357             0.0         False     False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=False, total_losses=1, buffer=614809/2048.[0m
[08/24 14:55:50]  --------------------------------------------------------------------------------
[08/24 14:55:50]  Iteration: 50 (8 solution, 41 counterexamples)
[08/24 14:55:53]  Generator returned sat in 1.580427 secs.
[08/24 14:55:53]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 2v.c_f[0][t-1] + 2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:53]  Improved gap from 0.1 to 100
[08/24 14:55:54]  Improved number of small numbers from 68 to 114 out of a max of 114
[08/24 14:55:54]  Verifer returned sat in 0.478085 secs.
[08/24 14:55:54]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t   arrival_0,t     cwnd_0,t  service_0,t  losts_0,t      queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    8409.886230    8409.586182 -3356.644043   8409.886230     0.100000  8409.586182   0.100098     0.199951       -0.100098     9.0      8409.586182            -1.0            -1       -1
1    8509.986328    8409.886230 -3356.644043   8509.986328   100.300049  8409.886230   0.100098   100.000000        0.000000     1.0      8409.586182             1.0         False     True
2    8510.186523    8509.986328 -3356.644043   8510.186523   100.200195  8509.986328   0.100098     0.100098      -99.799805     1.0      8510.086426             0.0         False     True
3    8610.086426    8609.886230 -3356.644043   8610.086426   100.000000  8609.886230   0.100098     0.100098      -99.899902     1.0      8609.986328             0.0         False     True
4    9210.586426    8809.886230 -3356.644043   9210.586426   600.600098  8809.886230   0.100098   400.600098      400.600098     1.0      8609.986328             0.0         False     True
5   10811.186523    8909.886230 -3356.644043  10811.186523  2001.200195  8909.886230   0.100098  1901.200195     1901.200195     2.0      8609.986328             0.0         False     True
6   10811.186523    9009.686279 -3356.644043  10811.186523   399.899902  9009.686279   0.100098  1801.400146     1801.200195     3.0     10811.086426             1.0          True    False
7   10811.186523    9109.886230 -3356.644043  10811.186523   399.800049  9109.886230   0.100098  1701.200195     1701.200195     4.0     10811.086426             1.0         False    False
8   10811.186523    9209.886230 -3356.644043  10811.186523   300.000000  9209.886230   0.100098  1601.200195     1601.200195     5.0     10811.086426             1.0         False    False
fefficient=True, bounded_queue=False, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=False, ramp_down_q=False, ramp_down_cwnd=True, total_losses=0, buffer=19013/10.[0m
[08/24 14:55:54]  --------------------------------------------------------------------------------
[08/24 14:55:54]  Iteration: 51 (8 solution, 42 counterexamples)
[08/24 14:55:56]  Generator returned sat in 0.935784 secs.
[08/24 14:55:56]  Candidate solution: 
[1m[94mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 1/2v.c_f[0][t-1] + 1/2(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:55:59]  Improved gap from 0.0 to 9.375
[08/24 14:56:00]  Improved number of small numbers from 69 to 92 out of a max of 114
[08/24 14:56:00]  Verifer returned sat in 3.092975 secs.
[08/24 14:56:00]  Counter example: 
[93m   tot_arrival_t  tot_service_t     wasted_t  arrival_0,t    cwnd_0,t  service_0,t  losts_0,t    queue_t  bottle_queue_t  qdelay  last_decrease_f  exceed_queue_f this_decrease v.mode_f
0    8591.133789    8591.132324 -3356.644043  8591.133789    0.001250  8591.132324    0.00000   0.001465        0.001309     5.0      8591.132324            -1.0            -1       -1
1    8688.931152    8602.712402 -3354.443848  8688.931152   97.798828  8602.712402    0.00000  86.218750       -0.001133     1.0      8591.132324             1.0         False    False
2    8700.509766    8688.932480 -3266.022705  8700.509766   97.797363  8688.932480    0.00000  11.577285       -0.001377     1.0      8700.509766             0.0         False    False
3    8709.886230    8700.511230 -3175.397949  8709.886230   20.953750  8700.511230    0.00000   9.375000       -0.000156     1.0      8709.886230             0.0         False    False
4    8809.890137    8809.886230 -3175.397949  8809.890137  109.378906  8809.886230    0.00125   0.002656        0.002500     1.0      8709.886230             0.0         False    False
5    8809.897480    8809.889980 -3084.776543  8809.897480    0.010000  8809.889980    0.00125   0.006250       -9.368750     1.0      8809.896230             0.0         False     True
6    8870.374980    8819.264980 -3035.885293  8870.374980   60.483750  8819.264980    0.00125  51.108750        0.000000     1.0      8809.896230             0.0         False     True
7    8908.884980    8870.373730 -2974.395508  8908.884980   89.618750  8870.373730    0.00125  38.510000       -0.000215     2.0      8809.896230             0.0         False     True
8    8930.862480    8908.884766 -2974.395508  8930.862480   60.487500  8908.884766    0.00125  21.976465      -78.022715     1.0      8930.861230             1.0          True    False
fefficient=False, bounded_queue=True, bounded_loss=True, ramp_up_cwnd=False, ramp_down_bq=True, ramp_down_q=False, ramp_down_cwnd=True, total_losses=1, buffer=1/400.[0m
[08/24 14:56:00]  --------------------------------------------------------------------------------
[08/24 14:56:00]  Iteration: 52 (8 solution, 43 counterexamples)
[08/24 14:56:02]  Generator returned unsat in 0.240659 secs.
[08/24 14:56:02]  [96mNo more solutions found[0m
[08/24 14:56:02]  Final solutions:
[08/24 14:56:02]  0: [1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][2]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:56:02]  1: [1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][1]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:56:02]  2: [1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][8]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:56:02]  3: [1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][7]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:56:02]  4: [1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][3]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:56:02]  5: [1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][6]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:56:02]  6: [1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][4]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:56:02]  7: [1m[92mif(v.mode_f[0][t]):
	if(Ld_f[0][t] > Ld_f[0][t-1]):
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 0(S_f[0][t-1]-S_f[0][t-4]) + 0)
	else:
		c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)
else:
	c_f[0][t] = max(0.01, 0v.c_f[0][t-1] + 1(S_f[0][t-1]-S_f[0][t-4]) + 0)

if(Ld_f[0][t] > Ld_f[0][t-1]):
	mode[0][t] = True
elif(qbound[t-1][5]):
	mode[0][t] = False
else:
	mode[0][t] = mode[0][t-1][0m
[08/24 14:56:02]  Took 154.123915 secs.
